<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>有疑者说</title>
  
  
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://www.cyningsun.com/"/>
  <updated>2020-02-27T15:09:25.258Z</updated>
  <id>https://www.cyningsun.com/</id>
  
  <author>
    <name>cyningsun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高并发系统设计(2)——缓存命中率</title>
    <link href="https://www.cyningsun.com/02-27-2020/high-concurrency-cache-miss.html"/>
    <id>https://www.cyningsun.com/02-27-2020/high-concurrency-cache-miss.html</id>
    <published>2020-02-26T16:00:00.000Z</published>
    <updated>2020-02-27T15:09:25.258Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><a href="https://www.cyningsun.com/02-02-2020/high-concurrency-hierarchical-storage.html">上一篇</a>文章讲述了缓存的本质，使用快速的存储，承载尽可能多的请求，那么衡量缓存服务质量有两个标准：</p><ol><li>平均访问延迟AAT（Average Access Time） = HitTime + (Miss Ratio * Miss Penalty)</li><li>缓存命中率 Cache Hit Ratio = [Cache Hits / (Cache Hits + Cache Misses)] x 100 %<br>前者因为不涉及技术问题，不再详谈。后者，却是至关重要。</li></ol><p>缓存命中（Cache Hit），符合我们预期，喜闻乐见；缓存未命中（Cache Miss），就很有可能要了老命。各种称谓也很繁杂</p><blockquote><p>国内按照场景分称为：缓存击穿、缓存穿透、缓存雪崩<br>国外使用不同词汇表达同一含义：<a href="https://en.wikipedia.org/wiki/Thundering_Herd" target="_blank" rel="noopener">Thundering Herd</a>、<a href="https://en.wikipedia.org/wiki/Cache_stampede" target="_blank" rel="noopener">Cache stampede</a>、<a href="https://books.google.com/books?id=daDAnXPnRkcC&pg=PA353" target="_blank" rel="noopener">Dog-Pile Effect</a></p></blockquote><p>以下的篇幅分场景来讲下缓存不命中的场景和常见的解决方案</p><h3 id="数据不在缓存"><a href="#数据不在缓存" class="headerlink" title="数据不在缓存"></a>数据不在缓存</h3><h4 id="Cold-cache"><a href="#Cold-cache" class="headerlink" title="Cold cache"></a>Cold cache</h4><p>缓存最好是使用渐进式策略进行warmup，要做到业务无感就需要引入中间组件，例如Facebook使用 mcrouter 来预热新机群</p><p><img src="/images/high-concurrency-cache-miss/mcrouter.png" alt="mcrouter.png"></p><h4 id="Adding-removing-nodes"><a href="#Adding-removing-nodes" class="headerlink" title="Adding / removing nodes"></a>Adding / removing nodes</h4><p>模哈希路由的主要缺点是缓存节点的数量需要保持稳定，增加节点或者节点下线将导致大多数缓存散列到新节点。即使这些值仍在缓存中，如果将Key分发给其他节点，查找也会 <code>Miss</code>。使用<a href="https://juejin.im/post/5ae1476ef265da0b8d419ef2" target="_blank" rel="noopener">一致性哈希</a>可以使缓存节点增减更加灵活。</p><p><img src="/images/high-concurrency-cache-miss/consistent-hash.png" alt="consistent-hash.png"></p><h4 id="Out-of-cache-memory"><a href="#Out-of-cache-memory" class="headerlink" title="Out of cache memory"></a>Out of cache memory</h4><p>对于不在内存中的数据，有两种可能：</p><ol><li>缓存时间到期（TTL），数据从缓存中淘汰出去了</li><li>由于之前没有访问，数据不在缓存中</li></ol><p>对于不在缓存的访问，处理的方式比较统一，严格限制并发访问后台，具体落实到各个公司各不相同：</p><ul><li>Instagram： 在C++语言中使用 <a href="https://instagram-engineering.com/thundering-herds-promises-82191c8af57d" target="_blank" rel="noopener">Promise</a> 模式来限制并发访问</li><li>Google：在Go语言中使用 <a href="https://pkg.go.dev/golang.org/x/sync/singleflight?tab=doc" target="_blank" rel="noopener">Single Flight</a> 来限制并发访问</li><li>Facebook：使用 <a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf" target="_blank" rel="noopener">Leases</a> 机制，保证同一时间只有第一个访问到不在缓存的请求可以访问下游，并将其添加到缓存；其他请求则返回未命中，然后等待一段时间再次尝试访问缓存。</li></ul><h3 id="数据不存在"><a href="#数据不存在" class="headerlink" title="数据不存在"></a>数据不存在</h3><p>对于数据不存在的情况，尽量通过参数校验的情况予以拦截。拿公众号文章的链接举例:</p><p><strong>早期</strong></p><pre><code class="hljs go">http:<span class="hljs-comment">//mp.weixin.qq.com/s?__biz=MzAwNTMxMzg1MA==&amp;mid=2654067776&amp;idx=1&amp;sn=b4c1261a785a59dd6268142b0b358b50&amp;scene=4#wechat_redirect</span></code></pre><p>可以看到该链接中几个关键的请求参数：</p><blockquote><p>__biz=MzAwNTMxMzg1MA== // 公众号ID base64<br>mid=2654067776        // 推送ID<br>idx=1                // 消息位置（每次推送有多篇文章）</p></blockquote><p>有这些参数，完全可以随意拼接参数，伪造URL爬取微信公众号的数据。如果URL并没有对应的数据，那么微信就会遇到数据不存在穿透到下层存储的问题。</p><p><strong>中期</strong></p><pre><code class="hljs go">http:<span class="hljs-comment">//mp.weixin.qq.com/s?timestamp=1469352451&amp;src=3&amp;ver=1&amp;signature=56kgMk71dIMM59VsUWlueRZ1ljkNODBEgrW78vmgXfJs82nkMESO8W*7EXf2ylOyamiUvL0zQ5OAfVraI8tPp-Hhdzv5WRQKSPa-MF6hiFMZf7rqxmZRvsYsd-7WSsy5qiafAQNfxBSkWzSulgB575CWRYnn6QZTRJ4NdR*gs0s=</span></code></pre><p>唔，带上时间戳了，不太好搞了，但是如果知道签名策略，仍然可以解出来必需的访问参数</p><p><strong>最新</strong></p><pre><code class="hljs go">https:<span class="hljs-comment">//mp.weixin.qq.com/s/zCyzv_DRzLSUjhs5E9gZtQ</span></code></pre><p>最新版就丧心病狂了，直接转成了短链接，外部人员丝毫没有办法，完美解决了问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>除了以上常规且通用的处理方案，业界还有各种贴合业务场景的方案，在此不过多涉及。</p><blockquote><p>非常规方案：</p><ul><li><a href="http://highscalability.com/bunch-great-strategies-using-memcached-and-mysql-better-together" target="_blank" rel="noopener">Pre-Populating Cache</a></li><li><a href="https://kovyrin.net/2008/03/10/dog-pile-effect-and-how-to-avoid-it-with-ruby-on-rails-memcache-client-patch/" target="_blank" rel="noopener">monkey patch</a></li><li>Randomize TTL values</li></ul></blockquote><br/><p>参考链接 </p><ol><li><a href="https://engineering.fb.com/web/introducing-mcrouter-a-memcached-protocol-router-for-scaling-memcached-deployments/" target="_blank" rel="noopener">https://engineering.fb.com/web/introducing-mcrouter-a-memcached-protocol-router-for-scaling-memcached-deployments/</a></li><li><a href="https://github.com/leafney/wxSpider/blob/master/GETCONTENT.md" target="_blank" rel="noopener">https://github.com/leafney/wxSpider/blob/master/GETCONTENT.md</a></li><li><a href="https://instagram-engineering.com/thundering-herds-promises-82191c8af57d" target="_blank" rel="noopener">https://instagram-engineering.com/thundering-herds-promises-82191c8af57d</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.cyningsun.com/02-02-2020/high-concurrency-hierarc
      
    
    </summary>
    
    
      <category term="缓存" scheme="https://www.cyningsun.com/category/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="命中率" scheme="https://www.cyningsun.com/tag/%E5%91%BD%E4%B8%AD%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Prometheus</title>
    <link href="https://www.cyningsun.com/02-22-2020/hidden-secret-to-understanding-prometheus.html"/>
    <id>https://www.cyningsun.com/02-22-2020/hidden-secret-to-understanding-prometheus.html</id>
    <published>2020-02-21T16:00:00.000Z</published>
    <updated>2020-02-22T05:10:06.283Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>对很多人来说，未知、不确定、不在掌控的东西，会有潜意识的逃避。当我第一次接触 Prometheus 的时候也有类似的感觉。对初学者来说， Prometheus 包含的概念太多了，门槛也太高了。</p><blockquote><p>概念： Instance、Job、Metric、Metric Name、Metric Label、Metric Value、Metric Type（Counter、Gauge、Histogram、Summary）、DataType（Instant Vector、Range Vector、Scalar、String）、Operator、Function</p></blockquote><p>马云说：“虽然阿里巴巴是全球最大的零售平台，但阿里不是零售公司，是一家数据公司”。Prometheus 也是一样，本质来说是一个基于数据的监控系统。</p><h3 id="日常监控"><a href="#日常监控" class="headerlink" title="日常监控"></a>日常监控</h3><p>假设需要监控 WebServerA 每个API的请求量为例，需要监控的维度包括：服务名（job）、实例IP（instance）、API名（handler）、方法（method）、返回码(code)、请求量（value）。</p><p><img src="/images/hidden-secret-to-understanding-prometheus/sql.png" alt="promql"></p><p>如果以SQL为例，演示常见的查询操作：</p><ol><li>查询 method=put 且 code=200 的请求量(红框)<blockquote><p>SELECT * from http_requests_total WHERE code=”200” AND method=”put” AND created_at BETWEEN 1495435700 AND 1495435710;</p></blockquote></li><li>查询 handler=prometheus 且 method=post 的请求量(绿框)<blockquote><p>SELECT * from http_requests_total WHERE handler=”prometheus” AND method=”post” AND created_at BETWEEN 1495435700 AND 1495435710;</p></blockquote></li><li>查询 instance=10.59.8.110 且 handler 以 query 开头 的请求量(绿框)<blockquote><p>SELECT * from http_requests_total WHERE handler=”query” AND instance=”10.59.8.110” AND created_at BETWEEN 1495435700 AND 1495435710;</p></blockquote></li></ol><p>通过以上示例可以看出，在常用查询和统计方面，日常监控多用于根据监控的维度进行查询与时间进行组合查询。<strong>如果监控100个服务，平均每个服务部署10个实例，每个服务有20个API，4个方法，30秒收集一次数据，保留60天。那么总数据条数为：100(服务)* 10（实例）* 20（API）* 4（方法）* 86400（1天秒数）* 60(天) / 30（秒）= 138.24 亿条数据，写入、存储、查询如此量级的数据是不可能在Mysql类的关系数据库上完成的</strong>。因此 Prometheus 使用 TSDB 作为 存储引擎</p><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>TSDB 作为 Prometheus 的存储引擎完美契合了监控数据的应用场景</p><ul><li>存储的数据量级十分庞大</li><li>大部分时间都是写入操作</li><li>写入操作几乎是顺序添加，大多数时候数据到达后都以时间排序</li><li>写操作很少写入很久之前的数据，也很少更新数据。大多数情况在数据被采集到数秒或者数分钟后就会被写入数据库</li><li>删除操作一般为区块删除，选定开始的历史时间并指定后续的区块。很少单独删除某个时间或者分开的随机时间的数据</li><li>基本数据大，一般超过内存大小。一般选取的只是其一小部分且没有规律，缓存几乎不起任何作用</li><li>读操作是十分典型的升序或者降序的顺序读</li><li>高并发的读操作十分常见</li></ul><p>那么 TSDB 是怎么实现以上功能的呢？</p><pre><code class="hljs json">"labels": [&#123;"latency":        "500"&#125;]"samples":[&#123;"timestamp": 1473305798,"value": 0.9&#125;]</code></pre><p>原始数据分为两部分 label, samples。前者记录监控的维度（标签:标签值），指标名称和标签的可选键值对唯一确定一条时间序列（使用 series_id 代表）；后者包含包含了时间戳（timestamp）和指标值（value）。</p><pre><code class="hljs txt">series^│. . . . . . . . . . . .   server&#123;latency&#x3D;&quot;500&quot;&#125;│. . . . . . . . . . . .   server&#123;latency&#x3D;&quot;300&quot;&#125;│. . . . . . . . . .   .   server&#123;&#125;│. . . . . . . . . . . . v&lt;-------- time ----------&gt;</code></pre><p>TSDB 使用 timeseries:doc:<timestamp>:<series_id> 为 key 存储 value。为了加速常见查询查询操作：label 和 时间范围结合。TSDB 额外构建了三种索引：<code>Series</code>, <code>Label Index</code> 和 <code>Time Index</code>。</p><p>以标签 <code>latency</code> 为例：</p><ul><li>Series<blockquote><p>存储两部分数据。一部分是按照字典序的排列的所有标签键值对序列（series）；另外一部分是时间线到数据文件的索引，按照时间窗口切割存储数据块记录的具体位置信息，因此在查询时可以快速跳过大量非查询窗口的记录数据</p></blockquote></li><li>Label Index<blockquote><p>每对 label 为会以 index:label:<latency> 为 key，存储该标签所有值的列表，并通过引用指向 <code>Series</code> 该值的起始位置。</p></blockquote></li><li>Time Index<blockquote><p>数据会以 index:timeseries:<series_id>:<split_time> 为 key，指向对应时间段的数据文件</p></blockquote></li></ul><h3 id="数据计算"><a href="#数据计算" class="headerlink" title="数据计算"></a>数据计算</h3><p>强大的存储引擎为数据计算提供了完美的助力，使得 Prometheus 与其他监控服务完全不同。Prometheus 可以<a href="https://prometheus.io/docs/prometheus/latest/querying/basics/#time-series-selectors" target="_blank" rel="noopener">查询出不同的数据序列</a>，然后再加上<a href="https://prometheus.io/docs/prometheus/latest/querying/operators/" target="_blank" rel="noopener">基础的运算符</a>，以及<a href="https://prometheus.io/docs/prometheus/latest/querying/functions/" target="_blank" rel="noopener">强大的函数</a>，就可以执行 <code>metric series</code> 的矩阵运算（见下图）。</p><p><img src="/images/hidden-secret-to-understanding-prometheus/matrix.png" alt="time series matrix"></p><p>如此，Promtheus体系的能力不弱于监控界的“数据仓库”+“计算平台”。因此，在大数据的开始在业界得到应用，就能明白，这就是监控未来的方向。</p><h3 id="一次计算，处处查询"><a href="#一次计算，处处查询" class="headerlink" title="一次计算，处处查询"></a>一次计算，处处查询</h3><p>当然，如此强大的计算能力，消耗的资源也是挺恐怖的。因此，查询预计算结果通常比每次需要原始表达式都要快得多，尤其是在仪表盘和告警规则的适用场景中，仪表盘每次刷新都需要重复查询相同的表达式，告警规则每次运算也是如此。因此，Prometheus提供了 Recoding rules，可以预先计算经常需要或者计算量大的表达式，并将其结果保存为一组新的时间序列， 达到 <a href="https://prometheus.io/docs/prometheus/latest/querying/basics/#avoiding-slow-queries-and-overloads" target="_blank" rel="noopener">一次计算，多次查询</a> 的目的</p><p><img src="/images/hidden-secret-to-understanding-prometheus/rules.png" alt="prometheus rules"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;对很多人来说，未知、不确定、不在掌控的东西，会有潜意识的逃避。当我第一次接触 Prometheus 的时候也有类似的感觉。对初学者来说， P
      
    
    </summary>
    
    
      <category term="Prometheus" scheme="https://www.cyningsun.com/category/Prometheus/"/>
    
    
      <category term="本质" scheme="https://www.cyningsun.com/tag/%E6%9C%AC%E8%B4%A8/"/>
    
  </entry>
  
  <entry>
    <title>高并发系统设计(1)——分级存储</title>
    <link href="https://www.cyningsun.com/02-02-2020/high-concurrency-hierarchical-storage.html"/>
    <id>https://www.cyningsun.com/02-02-2020/high-concurrency-hierarchical-storage.html</id>
    <published>2020-02-01T16:00:00.000Z</published>
    <updated>2020-02-27T15:01:31.974Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>原本想聊下缓存的相关技术，但是纯聊缓存未免眼界太窄，视野太小，既然打算写一个系列，不如就先从底层聊起，然后慢慢铺开。本篇先聊分级存储引入的问题，以及对服务和架构的影响：服务分类、分层架构（服务分层）。</p><h3 id="分级存储"><a href="#分级存储" class="headerlink" title="分级存储"></a>分级存储</h3><p>了解计算机组成的都知道，存储结构是分层（级）的，到底是什么原因呢？</p><p><img src="/images/high-concurrency-hierarchical-storage/computer-architecture.png" alt="computer-architecture.png"></p><p>用户期望提供尽可能高的存取速度和尽量大的存储容量，但价格尽可能低。矛盾的现实是：</p><ol><li>速度越快，单位存储价格就越高；</li><li>在一定的单位存储价格下，容量越大，存储器的总价就越高。</li></ol><p>计算机发挥性能要求存储存取速度与CPU相匹配。离 CPU 越近的存储，速度越快，成本越高，容量也因此越小。</p><p>数据从产生的那一刻起就自然地进入到了一个循环，经过创建、访问、迁移、归档和销毁，最终完成一个生命周期，而这个过程必然需要良好的管理，否则，要么是浪费了过多的资源；要么是资源不足降低了工作效率。</p><p>数据生来并非平等的。不同的数据具有不同的价值，如业务生产相关的关键数据和日志；同一数据在其不同阶段价值也不一样。纵向来看，即访问越多，其价值越高。</p><p><strong>分级存储</strong>，利用了数据访问的<a href="https://en.wikipedia.org/wiki/Locality_of_reference" target="_blank" rel="noopener">局部性原理</a>，使用快速的存储，存储访问最多的数据。当访问数据时，先从内存中取，如果内存中没有，再从磁盘读入内存。以后访问该区域的数据时，就不用再从磁盘读取，因此上层的存储都可以认为是下层的缓存。</p><p>总结一下：局部性原理的缓存体系，平衡了速度和价格的矛盾。</p><h3 id="分级问题"><a href="#分级问题" class="headerlink" title="分级问题"></a>分级问题</h3><p>分级存储并非是解决问题的银弹，解决了矛盾的同时，也给存储本身引入了一些问题：</p><ol><li>命中率<blockquote><p>当数据被上层存储覆盖时，一切尽在掌握，分层存储的机制可以正常的工作。当热点数据穿透上层落到下层时，下层存储的性能将成为整体的瓶颈。</p></blockquote></li><li>一致性<blockquote><p>作为缓存，上层存储在提高系统处理性能的同时，也可能会“滞留”IO操作。如果在系统发生故障时，仍有部分IO“滞留”，真正写到下层存储的数据就会少于服务实际写出的数据，导致数据不一致。</p></blockquote></li><li>存储管理<blockquote><p>由于存在多个层级，数据在生命周期内就需要在不同层级间流动迁移。不同层级需要合适的迁移淘汰策略，满足业务场景的需求。缓存需要缓存策略；内存需要内存管理策略；磁盘需要磁盘管理策略。</p></blockquote></li></ol><h3 id="服务分类"><a href="#服务分类" class="headerlink" title="服务分类"></a>服务分类</h3><p>如同放洗澡水一样，首先检查热水多热，然后检查冷水多冷。然后调节水龙头旋钮，以流出温度合适的水。</p><p>类似的，基于不同类型存储访问速度的巨大差异，需要关注的重点不同。多级存储也给架构设计带来不少问题。</p><p>在大型互联网公司，所有的服务被分为三种类型：</p><ul><li><strong>CPU消耗型</strong>：也称为“计算密集型”，指服务使用CPU完成计算任务，受CPU速度限制。<em>CPU越快，任务处理越快。</em></li><li><strong>内存消耗型</strong>：也称为“内存密集型”，指服务执行任务过程中受内存大小和访问速度限制。<em>内存越大、访问速度越快，任务处理速度越快。</em> 通常为搜索类、缓存类、内存数据库等需求大量内存的服务</li><li><strong>I/O消耗型</strong>：也称为“I/O密集型”，指服务执行任务涉及到大量的网络传输或磁盘I/O，受I/O速度限制。<em>I/O越快，任务处理越快。</em> 一旦发生I/O，服务的工作线程(进程)就会处于等待状态，当I/O结束，数据准备好后，线程(进程)才会继续执行。</li></ul><p>一个服务可以既是“CPU消耗型“，同时也是“内存消耗型”，例如：搜索服务 —— 烧钱玩意儿，腾讯卖掉搜索给搜狗估计也是被烧的肉疼了吧 ：）。</p><p>那为什么如此划分呢？</p><ul><li>一方面，当服务陷入瓶颈的时候能够快速根据类型进行资源预估、调整和性能调优</li><li>另一方面，调度程序可以使用该信息来调度不同类型的服务，使用装包算法（<a href="https://en.wikipedia.org/wiki/Bin_packing_problem" target="_blank" rel="noopener">bin-packingalgorithms</a>）进行最优的混合部署，以达到资源最大利用。<br><img src="/images/high-concurrency-hierarchical-storage/bin-packing.png" alt="bin-packing.png"></li></ul><h3 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h3><p>盘点下业界在高并发场景下，使用的存储方案(至少保证数据不丢失)：</p><ol><li>纯内存数据库：以 mongodb 为代表。成本高昂<br>内存数据库 + 磁盘数据库：以 Redis/memcached + 2. Mysql/TiDB 为代表。使用起来比较复杂，需要业务自己处理分级存储带来的问题</li><li>高性能高可用分布式数据库：以 megastore（谷歌）/ paxosstore(微信) / Dynamo (亚马逊)，技术门槛比较高，大厂专属</li></ol><p>可以看到绝大部分的互联网公司，还是依靠第二种方案扛住高并发的请求。那么应对高并发的架构中，就不能缺少存储层（也可以称为：持久层，数据访问层），否则业务代码会与存储管理的代码交叉耦合在一起</p><p><img src="/images/high-concurrency-hierarchical-storage/layer-architecture.png" alt="layer-architecture.png"></p><p>使用第二种方案，就免不了缓存的是是非非。既然缓存也是存储层级中的一层，所有的问题也就脱不开分级问题的范畴了，后续详聊。</p><br/><p>参考链接：</p><ul><li><a href="https://stackoverflow.com/questions/868568/what-do-the-terms-cpu-bound-and-i-o-bound-mean" target="_blank" rel="noopener">What do the terms “CPU bound” and “I/O bound” mean?</a></li><li><a href="https://www.slideshare.net/kubecon/kubecon-eu-2016-a-practical-guide-to-container-scheduling" target="_blank" rel="noopener">A Practical Guide to Container Scheduling</a></li><li><a href="https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/ch01.html" target="_blank" rel="noopener">Software Architecture Patterns</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;原本想聊下缓存的相关技术，但是纯聊缓存未免眼界太窄，视野太小，既然打算写一个系列，不如就先从底层聊起，然后慢慢铺开。本篇先聊分级存储引入的问
      
    
    </summary>
    
    
      <category term="缓存" scheme="https://www.cyningsun.com/category/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="总述" scheme="https://www.cyningsun.com/tag/%E6%80%BB%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>译｜How to use Prometheus for anomaly detection in GitLab</title>
    <link href="https://www.cyningsun.com/01-22-2020/use-prometheus-for-anomaly-detection.html"/>
    <id>https://www.cyningsun.com/01-22-2020/use-prometheus-for-anomaly-detection.html</id>
    <published>2020-01-21T16:00:00.000Z</published>
    <updated>2020-02-03T06:53:29.725Z</updated>
    
    <content type="html"><![CDATA[<p>Prometheus 查询语言的最基本功能之一是实时汇总时间序列数据。GitLab基础架构团队的杰出工程师 <code>Andrew Newdigate</code> 认为 Prometheus 查询语言也可以用于检测时间序列数据中的异常。本博客文章解释了异常检测如何与 Prometheus 一起工作，并包括您需要在自己的系统上亲自尝试的代码片段。</p><h3 id="为什么异常检测有效？"><a href="#为什么异常检测有效？" class="headerlink" title="为什么异常检测有效？"></a>为什么异常检测有效？</h3><p>异常检测对 GitLab 非常重要的四个关键原因：</p><ul><li>诊断事件：我们可以快速找出哪些服务执行超出正常范围，并减少检测事件的平均时间（MTTD），从而更快地解决问题。</li><li>检测应用程序性能回归：例如，如果引入 n+1 回归，发现一个服务以很高的速率调用另一个服务，可以迅速找到问题并加以解决。</li><li>识别并解决滥用问题：GitLab 提供免费计算（GitLab CI/CD）和托管（GitLab Pages），会被一小部分用户加以利用。</li><li>安全性：异常检测对于发现 GitLab 时间序列数据中的异常趋势至关重要。</li></ul><p>由于以上以及其他许多原因，Andrew 研究了是否可以仅通过使用 Prometheus 查询和规则对 GitLab 时间序列数据执行异常检测。</p><h3 id="正确的聚合级别是什么？"><a href="#正确的聚合级别是什么？" class="headerlink" title="正确的聚合级别是什么？"></a>正确的聚合级别是什么？</h3><p>首先，时间序列数据必须正确聚合。尽管可以将相同的技术应用到许多其他类型的指标，Andrew 使用了标准计数器 <code>http_requests_total</code> 作为数据源进行演示。</p><pre><code class="hljs js">http_requests_total&#123; job=<span class="hljs-string">"apiserver"</span>, method=<span class="hljs-string">"GET"</span>, controller=<span class="hljs-string">"ProjectsController"</span>, status_code=<span class="hljs-string">"200"</span>, environment=<span class="hljs-string">"prod"</span>&#125;</code></pre><p>上述示例指标有一些额外的维度：<code>method</code>，<code>controller</code>，<code>status_code</code>，<code>environment</code>，如同 Prometheus 添加的维度 <code>instance</code> 和 <code>job</code> 一样。</p><p>接下来，您必须为正在使用的数据选择正确的聚合级别。这有点像“金发姑娘问题”-太多，太少还是恰到好处-但这对于发现异常至关重要。过多地汇总数据，数据将缩减为过小的维度，从而产生两个潜在的问题：</p><ol><li>可能会错过真正的异常，因为聚合隐藏了数据子集中出现的问题。</li><li>如果确实检测到异常，则不对异常进行更多调查，则很难将其归因于系统的特定部分。</li></ol><p>但是，聚合的数据汇太少，最终可能会得到一系列样本量非常小的数据。如此可能导致误报，并可能将真实数据标记为离群值（outliers）。</p><p>恰到好处：我们的经验表明，正确的聚合级别是服务级别，因此我们将 <code>job</code> 和 <code>environment</code> 标签标签包括进来，但删除了其他维度。在本演讲的以下部分中使用的数据聚合包括：<code>job</code>、<code>http requests</code>、<code>五分钟速率</code>(基本上是五分钟窗口中覆盖 <code>job</code> 和 <code>environment</code> 之上的速率)。</p><pre><code class="hljs ruby">- <span class="hljs-symbol">record:</span> <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m<span class="hljs-symbol">expr:</span> sum without(instance, method, controller, status_code)(rate(http_requests_total[<span class="hljs-number">5</span>m]))<span class="hljs-comment"># --&gt; job:http_requests:rate5m&#123;job="apiserver", environment="prod"&#125;  21321</span><span class="hljs-comment"># --&gt; job:http_requests:rate5m&#123;job="gitserver", environment="prod"&#125;  2212</span><span class="hljs-comment"># --&gt; job:http_requests:rate5m&#123;job="webserver", environment="prod"&#125;  53091</span></code></pre><h3 id="使用-z-score-进行异常检测"><a href="#使用-z-score-进行异常检测" class="headerlink" title="使用 z-score 进行异常检测"></a>使用 z-score 进行异常检测</h3><p>一些统计学的主要原理可以应用于 Prometheus 检测异常。</p><p>如果知道 Prometheus 序列的平均值和标准偏差（σ），则可以使用该系列中的任何样本来计算 <code>z-score</code>。<code>z-score</code> 表示为：与平均值的标准偏差值。因此 z-score 为 0 表示 z-score 与具有正态分布的数据的平均值相同，而 z-score 为 1 则相对于平均值为 1.0σ，依此类推。</p><p>假设基础数据是正态分布的，则 99.7％ 的样本的 z-score 应介于 0 到 3 之间。z-score 距离 0 越远，它越不可能出现。我们将此特性应用于检测 Prometheus 序列中的异常。</p><ol><li>使用样本数量较大的数据计算指标的平均值和标准偏差。在此示例中，我们使用了一周的数据。如果假设我们每分钟评估一次记录规则，那么一周的时间，能获得 10,000 多个样本。<pre><code class="hljs ruby"><span class="hljs-comment"># Long-term average value for the series</span>- <span class="hljs-symbol">record:</span> <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w<span class="hljs-symbol">expr:</span> avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w])<span class="hljs-comment"># Long-term standard deviation for the series</span>- <span class="hljs-symbol">record:</span> <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>stddev_over_time_1w<span class="hljs-symbol">expr:</span> stddev_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w])</code></pre></li><li>一旦有了聚合的平均值和标准差，就可以计算 Prometheus 查询的 z-score。<pre><code class="hljs sql"><span class="hljs-comment"># Z-Score for aggregation</span>(job:http_requests:rate5m -job:http_requests:rate5m:avg_over_time_1w) /  job:http_requests:rate5m:stddev_over_time_1w</code></pre></li></ol><p>根据正态分布的统计原理，我们可以假设任何超出大约 +3 到 -3 范围的值都是异常。我们可以围绕这一原则建立警报。例如，当聚合超出此范围超过五分钟时，我们将收到警报。</p><p><img src="/images/use-prometheus-for-anomaly-detection/gitlab-page-rps.png" alt="gitlab-page-rps.png"><br>GitLab.com 页面服务 48 小时的 RPS， ±3 z-score 区域为绿色</p><p>z-score 在图形上难以解释，因为它们没有度量单位。但是此图表上的异常很容易检测。出现在绿色区域（表示 z-score 在 +3 或 -3 范围内）之外的任何值都是异常。</p><h3 id="如果不是正态分布怎么办？"><a href="#如果不是正态分布怎么办？" class="headerlink" title="如果不是正态分布怎么办？"></a>如果不是正态分布怎么办？</h3><p>但是，请稍等：我们大跃进的假设潜在的聚合具有正态分布。如果我们使用非正态分布的数据计算 z-score，结果将不正确。有许多统计技术可以测试您的数据是否为正态分布，但是最好的选择是测试您的潜在数据的 z-score 约为 +4 到 -4。</p><pre><code class="hljs ruby">( max_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w]) - avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w])) / stddev_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w])<span class="hljs-comment"># --&gt; &#123;job="apiserver", environment="prod"&#125;  4.01</span><span class="hljs-comment"># --&gt; &#123;job="gitserver", environment="prod"&#125;  3.96</span><span class="hljs-comment"># --&gt; &#123;job="webserver", environment="prod"&#125;  2.96</span>( min_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w]) - avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w])) / stddev_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w])<span class="hljs-comment"># --&gt; &#123;job="apiserver", environment="prod"&#125;  -3.8</span><span class="hljs-comment"># --&gt; &#123;job="gitserver", environment="prod"&#125;  -4.1</span><span class="hljs-comment"># --&gt; &#123;job="webserver", environment="prod"&#125;  -3.2</span></code></pre><p>两个 Prometheus 查询测试 z-score 的最小和最大值。</p><p>如果结果返回的范围是 +20 到 -20，则尾巴太长，结果将倾斜。还要记住，这需要在聚合而不是非聚合的序列上运行。可能没有正态分布的指标包括诸如错误率、等待时间、队列长度等，但是无论如何，在固定阈值下告警，许多这些指标都趋向于工作的很好。</p><h3 id="使用季节性检测异常"><a href="#使用季节性检测异常" class="headerlink" title="使用季节性检测异常"></a>使用季节性检测异常</h3><p>尽管时间序列数据为正态分布时，计算 z-score 效果很好，但是还有第二种方法可以产生更准确的异常检测结果。季节性是时间序列指标的一个特征，其中该指标会经历定期且可预测的变化，这些变化会在每个周期重复出现。</p><p><img src="/images/use-prometheus-for-anomaly-detection/gitaly-rps-weeks.png" alt="gitaly-rps-weeks.png"><br>周一至周日连续四个星期的每秒 Gitaly 请求（RPS）</p><p>该图说明了连续四周的周一到周日的7天中 Gitaly 的 RPS（每秒请求数）速率。七天范围称为“偏移”，表示需要度量的模式。图上的每个星期都有不同的颜色。数据的季节性由图表中所示趋势的一致性表示 —— 每个星期一早晨，RPS 速率都会上升，而在星期五晚上，RPS 速率会逐渐下降，每周如此。</p><p>通过利用时间序列数据中的季节性，可以创建更准确的预测，从而更好地进行异常检测。</p><h3 id="如何利用季节性？"><a href="#如何利用季节性？" class="headerlink" title="如何利用季节性？"></a>如何利用季节性？</h3><p>使用 Prometheus 计算季节性，需要在一些不同的统计原理上迭代。</p><p>在第一次迭代中，我们通过将目前滚动的一周的增长趋势（注：平均值）与前一周的值相加来计算。通过从目前滚动的一周平均值中减去上周的滚动一周平均值来计算增长趋势。</p><pre><code class="hljs ruby">- <span class="hljs-symbol">record:</span> <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m_prediction  <span class="hljs-symbol">expr:</span> &gt;    <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m offset <span class="hljs-number">1</span>w                     <span class="hljs-comment"># Value from last period</span>    + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w            <span class="hljs-comment"># One-week growth trend</span>    - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">1</span>w</code></pre><p>第一次迭代有点狭窄；我们使用本周和上周的五分钟窗口来得出我们的预测。</p><p>在第二次迭代中，将上周的四个小时平均值作为平均值，并将其与本周进行比较，以扩大范围。因此，如果要预测一个星期一上午8点的指标值，不是使用一周前的相同五分钟窗口，而是使用前一周早上的上午6点至上午10点的指标平均值。</p><pre><code class="hljs ruby">- <span class="hljs-symbol">record:</span> <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m_prediction  <span class="hljs-symbol">expr:</span> &gt;    avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">4</span>h] offset <span class="hljs-number">166</span>h) <span class="hljs-comment"># Rounded value from last period</span>    + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w             <span class="hljs-comment"># Add 1w growth trend</span>    - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">1</span>w</code></pre><p>在查询中使用166个小时而不是一周，因为要根据一天中的当前时间使用四个小时，因此需要将偏移减少两个小时。</p><p><img src="/images/use-prometheus-for-anomaly-detection/gitaly-rps-weeks-prediction.png" alt="gitaly-rps-weeks-prediction.png"><br>两周的 Gitaly 服务 RPS（黄色）vs 预测（蓝色）。</p><p>将实际的 Gitaly RPS（黄色）与 预测（蓝色）进行比较表明，计算相当准确。但是，这种方法有缺陷。因为5月1日是国际劳动节，一个许多国家庆祝的节日，GitLab 的使用量低于平常的星期三。由于增长率是由前一周的使用情况决定的，因此我们对下周（5月8日，星期三）RPS 的预测会比 如果5月1日（星期三）没有假期更低。</p><p>可以通过在5月1日（星期三）之前连续三周（之前的星期三，再之前的星期三和三周之前的星期三）进行三个预测来解决此问题。查询保持不变，但偏移量已调整。</p><pre><code class="hljs ruby">- <span class="hljs-symbol">record:</span> <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m_prediction  <span class="hljs-symbol">expr:</span> &gt;   quantile(<span class="hljs-number">0</span>.<span class="hljs-number">5</span>,     label_replace(       avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">4</span>h] offset <span class="hljs-number">166</span>h)       + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">1</span>w       , <span class="hljs-string">"offset"</span>, <span class="hljs-string">"1w"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>)     <span class="hljs-keyword">or</span>     label_replace(       avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">4</span>h] offset <span class="hljs-number">334</span>h)       + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">2</span>w       , <span class="hljs-string">"offset"</span>, <span class="hljs-string">"2w"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>)     <span class="hljs-keyword">or</span>     label_replace(       avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">4</span>h] offset <span class="hljs-number">502</span>h)       + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">3</span>w       , <span class="hljs-string">"offset"</span>, <span class="hljs-string">"3w"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>)   )   without (offset)</code></pre><p><img src="/images/use-prometheus-for-anomaly-detection/gitaly-rps-three-weeks-prediction.png" alt="gitaly-rps-three-weeks-prediction.png"><br>三个星期三的三个预测与实际 5月8日（星期三，国际劳动节之后的一周）的 Gitaly RPS</p><p>在该图上，绘制了5月8日星期三和5月8日之前连续三个星期的三个预测。可以看到其中两个预测是好的，但是5月1日的预测仍远未达到基准。</p><p>而且，我们不需要三个预测，我们想要<strong>一个预测</strong>。取平均值是不可行的，因为它将被倾斜的 5月1日 RPS数据所稀释。相反，我们要计算中位数。Prometheus没有中位数查询，但可以使用分位数聚合来代替中位数。该方法的一个问题是，试图在一个聚合中包括三个系列，而这三个系列实际上在三周内都是相同的系列。换句话说，它们都具有相同的标签，因此连接它们很棘手。为避免混淆，我们创建了一个名为 <code>offset</code> 的标签，并使用 label-replace 函数为三个星期添加offset。接下来，在分位数聚合中，将其去除，以获得了三个中间值。</p><pre><code class="hljs ruby">- <span class="hljs-symbol">record:</span> <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m_prediction  <span class="hljs-symbol">expr:</span> &gt;   quantile(<span class="hljs-number">0</span>.<span class="hljs-number">5</span>,     label_replace(       avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">4</span>h] offset <span class="hljs-number">166</span>h)       + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">1</span>w       , <span class="hljs-string">"offset"</span>, <span class="hljs-string">"1w"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>)     <span class="hljs-keyword">or</span>     label_replace(       avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">4</span>h] offset <span class="hljs-number">334</span>h)       + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">2</span>w       , <span class="hljs-string">"offset"</span>, <span class="hljs-string">"2w"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>)     <span class="hljs-keyword">or</span>     label_replace(       avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">4</span>h] offset <span class="hljs-number">502</span>h)       + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">3</span>w       , <span class="hljs-string">"offset"</span>, <span class="hljs-string">"3w"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>)   )   without (offset)</code></pre><p>现在，从三个聚合系列中得出中值的预测更加准确。</p><p><img src="/images/use-prometheus-for-anomaly-detection/gitaly-rps-median-weeks-prediction.png" alt="gitaly-rps-median-weeks-prediction.png"><br>中位数预测与实际 Gitaly RPS 的比较，5月8日（星期三，国际劳动节之后的一周）</p><h3 id="怎么知道预测是真正准确的？"><a href="#怎么知道预测是真正准确的？" class="headerlink" title="怎么知道预测是真正准确的？"></a>怎么知道预测是真正准确的？</h3><p>为了测试预测的准确性，可以返回 z-score。可以使用 z-score 来测量样本与标准偏差预测值之间的差距。偏离预测的标准偏差越多，则特定值是异常可能性就越大。</p><p><img src="/images/use-prometheus-for-anomaly-detection/gitaly-rps-normal-range-prediction.png" alt="gitaly-rps-normal-range-prediction.png"><br>Gitaly 服务的预测正常范围 ±1.5σ</p><p>我们可以更新 Grafana 图表以使用季节性预测而不是每周滚动平均值。一天中特定时间的正常范围以绿色阴影显示。任何落在绿色阴影区域之外的东西都被认为是异常值。在这种情况下，离群值发生在周日下午，此时我们的云提供商遇到了一些网络问题。在我们的预测的任一侧使用±2σ的边界是确定季节性预测的异常值的一种很好的方法。</p><h3 id="如何使用Prometheus设置警报"><a href="#如何使用Prometheus设置警报" class="headerlink" title="如何使用Prometheus设置警报"></a>如何使用Prometheus设置警报</h3><p>如果要为异常事件设置警报，可以对 Prometheus 应用一个非常简单的规则，该规则检查指标的 z-score 是否在标准偏差 +2 或 -2 之间。</p><pre><code class="hljs ruby">- <span class="hljs-symbol">alert:</span> RequestRateOutsideNormalRange  <span class="hljs-symbol">expr:</span> &gt;   abs(     (       <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m_prediction     ) / <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>stddev_over_time_1w   ) &gt; <span class="hljs-number">2</span>  <span class="hljs-symbol">for:</span> <span class="hljs-number">10</span>m  <span class="hljs-symbol">labels:</span>    <span class="hljs-symbol">severity:</span> warning  <span class="hljs-symbol">annotations:</span>    <span class="hljs-symbol">summary:</span> Requests <span class="hljs-keyword">for</span> job &#123;&#123; $labels.job &#125;&#125; are outside of expected operating parameters</code></pre><p>在 GitLab，我们使用了自定义路由规则，该规则会在检测到任何异常时 pings Slack，但不会寻呼值班的支持人员。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>Prometheus 可用于某些类型的异常检测</li><li>正确级别的数据聚合是异常检测的关键</li><li>如果数据具有正态分布，则 z-score 是一种有效的方法</li><li>季节性指标可以为异常检测提供出色的结果</li></ol><p>视频链接：<a href="https://vimeo.com/341141334" target="_blank" rel="noopener">https://vimeo.com/341141334</a><br>原文链接：<a href="https://about.gitlab.com/blog/2019/07/23/anomaly-detection-using-prometheus/" target="_blank" rel="noopener">https://about.gitlab.com/blog/2019/07/23/anomaly-detection-using-prometheus/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Prometheus 查询语言的最基本功能之一是实时汇总时间序列数据。GitLab基础架构团队的杰出工程师 &lt;code&gt;Andrew Newdigate&lt;/code&gt; 认为 Prometheus 查询语言也可以用于检测时间序列数据中的异常。本博客文章解释了异常检测如何与 P
      
    
    </summary>
    
    
      <category term="Prometheus" scheme="https://www.cyningsun.com/category/Prometheus/"/>
    
    
      <category term="Anomaly detection" scheme="https://www.cyningsun.com/tag/Anomaly-detection/"/>
    
  </entry>
  
  <entry>
    <title>深度探索 Go 对象模型</title>
    <link href="https://www.cyningsun.com/01-12-2020/inside-the-go-object-model.html"/>
    <id>https://www.cyningsun.com/01-12-2020/inside-the-go-object-model.html</id>
    <published>2020-01-11T16:00:00.000Z</published>
    <updated>2020-02-03T06:53:29.646Z</updated>
    
    <content type="html"><![CDATA[<p>了解一门语言的高级特性，仅仅从浮于表面，是无法把握住语言的精髓的。学习过 C++ 的高阶开发者，一定读过神书《Inside The C++ Object Model》，本文的目标是一样的：通过对象模型，掌握 Go 语言的底层机制，从更深层次解释语言特性。</p><h3 id="编译与执行"><a href="#编译与执行" class="headerlink" title="编译与执行"></a>编译与执行</h3><p>众所周知，Go 源码并不能直接运行，所有代码必须一行行，通过“编译”——“汇编”——“链接” 阶段 转化为低级的机器语言指令，即可执行程序。</p><p><img src="/images/go-object-model/compile.png" alt="compile.png"></p><p>“汇编”和“链接”阶段各种语言并无区别，所以一般通过“编译”和“执行”阶段来支持各种语言特性。对于 Go 语言，执行过程并无法直接修改执行指令，因此所有语言特性都是“编译”相关的。理解这一点很重要，因为下面依赖“编译”的产物 <strong>汇编代码</strong> 来解读对象模型。</p><h3 id="什么是对象模型？"><a href="#什么是对象模型？" class="headerlink" title="什么是对象模型？"></a>什么是对象模型？</h3><p>何为 Go 对象模型？ Go 对象模型可以概括为以下两部分：</p><ol><li>支持面向对象程序设计的部分<blockquote><ul><li>封装</li><li>继承</li><li>多态</li></ul></blockquote></li><li>各种特性的底层实现机制<blockquote><ul><li>反射</li></ul></blockquote></li></ol><p>下面分别从 struct 和 interface 来解释模型如何支持以上两部分。</p><h3 id="Struct-语意学"><a href="#Struct-语意学" class="headerlink" title="Struct 语意学"></a>Struct 语意学</h3><p><img src="/images/go-object-model/struct.png" alt="struct.png"></p><p>面向对象编程，把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数，前者为成员变量，后者为成员函数。所以研究对象需要分别从成员变量和成员函数入手。</p><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>以下有三段程序：</p><pre><code class="hljs go"><span class="hljs-comment">// First: global varible</span><span class="hljs-keyword">var</span> (   X,Y,Z <span class="hljs-keyword">float32</span>)<span class="hljs-comment">// Second: simple type</span><span class="hljs-keyword">type</span> point3d <span class="hljs-keyword">struct</span> &#123;X, Y, Z <span class="hljs-keyword">float32</span>&#125;<span class="hljs-comment">// Third: inherit type</span><span class="hljs-keyword">type</span> point <span class="hljs-keyword">struct</span> &#123;X <span class="hljs-keyword">float32</span>&#125;<span class="hljs-keyword">type</span> point2d <span class="hljs-keyword">struct</span> &#123;pointY <span class="hljs-keyword">float32</span>&#125;<span class="hljs-keyword">type</span> point3d <span class="hljs-keyword">struct</span> &#123;point2dZ <span class="hljs-keyword">float32</span>&#125;</code></pre><p>从风格来看，三段程序截然不同。有许多令人信服的讨论告诉我们，为什么“数据封装”（Second &amp; Third）要比使用“全局变量”好。但，从程序员的角度看，会有几个疑问：</p><blockquote><ol><li>“数据封装” 之后，内存成本增加了多少？</li><li>“数据封装” 之后，在执行过程中，变量的存储效率是否降低了？</li></ol></blockquote><h5 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h5><p>先看内存变化。了解内存变化最好的办法就是通过代码打印对象的内存大小，先看全局变量大小</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> (X, Y, Z <span class="hljs-keyword">float32</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">"X size:%v, Y size:%v, Z size:%v\n"</span>, unsafe.Sizeof(X), unsafe.Sizeof(Y), unsafe.Sizeof(Z))fmt.Printf(<span class="hljs-string">"X addr:%v, Y addr:%v, Z addr:%v\n"</span>, &amp;X, &amp;Y, &amp;Z)&#125;</code></pre><p>执行程序输出为：</p><pre><code class="hljs sh">$ go run variable.goX size:4, Y size:4, Z size:4X addr:0x118ee88, Y addr:0x118ee8c, Z addr:0x118ee90</code></pre><p>可以看到，X、Y、Z三个字段大小均为4字节，且三个字段内存地址顺序排列。</p><p>再看第二段代码的输出</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestLayout</span><span class="hljs-params">(t *testing.T)</span></span> &#123;p := point3d&#123;X: <span class="hljs-number">1</span>, Y: <span class="hljs-number">2</span>, Z: <span class="hljs-number">3</span>&#125;fmt.Printf(<span class="hljs-string">"point3d size:%v, align:%v\n"</span>, unsafe.Sizeof(p), unsafe.Alignof(p))typ := reflect.TypeOf(p)fmt.Printf(<span class="hljs-string">"Struct:%v is %d bytes long\n"</span>, typ.Name(), typ.Size())fmt.Printf(<span class="hljs-string">"X at offset %v, size=%d\n"</span>, unsafe.Offsetof(p.X), unsafe.Sizeof(p.X))fmt.Printf(<span class="hljs-string">"Y at offset %v, size=%d\n"</span>, unsafe.Offsetof(p.Y), unsafe.Sizeof(p.Y))fmt.Printf(<span class="hljs-string">"Z at offset %v, size=%d\n"</span>, unsafe.Offsetof(p.Z), unsafe.Sizeof(p.Z))&#125;</code></pre><p>执行程序输出为：</p><pre><code class="hljs sh">$ go <span class="hljs-built_in">test</span> -v -run TestLayout=== RUN   TestLayoutpoint3d size:12, align:4Struct:point3d is 12 bytes longX at offset 0, size=4Y at offset 4, size=4Z at offset 8, size=4</code></pre><p>可以看到，X、Y、Z三个字段大小一样为4字节，内存排列也与上一个版本一样。</p><p>继续，第三段代码</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestLayout</span><span class="hljs-params">(t *testing.T)</span></span> &#123;p := point3d&#123;point2d: point2d&#123;point: point&#123;X: <span class="hljs-number">1</span>&#125;, Y: <span class="hljs-number">2</span>&#125;, Z: <span class="hljs-number">3</span>&#125;fmt.Printf(<span class="hljs-string">"point3d size:%v, align:%v\n"</span>, unsafe.Sizeof(p), unsafe.Alignof(p))typ := reflect.TypeOf(p)fmt.Printf(<span class="hljs-string">"Struct:%v is %d bytes long\n"</span>, typ.Name(), typ.Size())fmt.Printf(<span class="hljs-string">"X at offset %v, size=%d\n"</span>, unsafe.Offsetof(p.X), unsafe.Sizeof(p.X))fmt.Printf(<span class="hljs-string">"Y at offset %v, size=%d\n"</span>, unsafe.Offsetof(p.Y), unsafe.Sizeof(p.Y))fmt.Printf(<span class="hljs-string">"Z at offset %v, size=%d\n"</span>, unsafe.Offsetof(p.Z), unsafe.Sizeof(p.Z))&#125;</code></pre><p>执行程序输出为：</p><pre><code class="hljs sh">$ go <span class="hljs-built_in">test</span> -v -run TestLayout=== RUN   TestLayoutpoint3d size:12, align:4Struct:point3d is 12 bytes longX at offset 0, size=4Y at offset 4, size=4Z at offset 8, size=4</code></pre><p>可以看到，X、Y、Z三个字段大小一样为4字节，内存排列也与之前两个版本一样。</p><p>综上所述，我们可以看到，无论是否封装，还是多深的继承层次，对成员变量的内存布局都并无影响，均按照字段定义的顺序排列（不考虑内存对齐的情况）。即内存布局类似如下：</p><p><img src="/images/go-object-model/memory-offset.png" alt="memory-offset.png"></p><h5 id="变量存取"><a href="#变量存取" class="headerlink" title="变量存取"></a>变量存取</h5><p>成员变量有两种读取方式，既可以通过对象读取，也可以通过对象的指针读取。两种读取方式与直接变量读取会有什么不同么？使用一段代码再看下：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> point <span class="hljs-keyword">struct</span> &#123;X <span class="hljs-keyword">float32</span>&#125;<span class="hljs-keyword">type</span> point2d <span class="hljs-keyword">struct</span> &#123;pointY <span class="hljs-keyword">float32</span>&#125;<span class="hljs-keyword">type</span> point3d <span class="hljs-keyword">struct</span> &#123;point2dZ <span class="hljs-keyword">float32</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> (w <span class="hljs-keyword">float32</span>)point := point3d&#123;point2d: point2d&#123;point: point&#123;X: <span class="hljs-number">1</span>&#125;, Y: <span class="hljs-number">2</span>&#125;, Z: <span class="hljs-number">3</span>&#125; <span class="hljs-comment">// L25</span>p := &amp;point  <span class="hljs-comment">// L26</span>w = point.Y  <span class="hljs-comment">// L27</span>fmt.Printf(<span class="hljs-string">"w:%f\n"</span>, w)w = p.Y     <span class="hljs-comment">// L29</span>fmt.Printf(<span class="hljs-string">"w:%f\n"</span>, w)&#125;</code></pre><p>还记得之前提过的“编译”阶段么？我们使用 go tool 可以查看源代码汇编之后的代码</p><pre><code class="hljs x86asm"><span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x10948d8</span>f30f11442444<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x44</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x10948de</span>f30f11442448<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x48</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x10948e4</span>f30f1144244c<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x4c</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x10948ea</span>f30f10055ab50400<span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.</span>3f800000(SB), X0<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x10948f2</span>f30f11442444<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x44</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x10948f8</span>f30f100550b50400<span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.40000000</span>(SB), X0<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x1094900</span>f30f11442448<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x48</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x1094906</span>f30f100546b50400<span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.40400000</span>(SB), X0<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x109490e</span>f30f1144244c<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x4c</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">26</span><span class="hljs-number">0x1094914</span>488d442444LEAQ <span class="hljs-number">0x44</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span><span class="hljs-symbol">data_access.go:</span><span class="hljs-number">26</span><span class="hljs-number">0x1094919</span><span class="hljs-number">4889442450</span><span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0x50</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">27</span><span class="hljs-number">0x109491e</span>f30f10442448<span class="hljs-keyword">MOVSS</span> <span class="hljs-number">0x48</span>(<span class="hljs-built_in">SP</span>), X0// 读取 Y 到寄存器 X0<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">27</span><span class="hljs-number">0x1094924</span>f30f11442440<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x40</span>(<span class="hljs-built_in">SP</span>)// 赋值 寄存器 X0 给 w...<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">29</span><span class="hljs-number">0x10949c7</span>488b442450<span class="hljs-keyword">MOVQ</span> <span class="hljs-number">0x50</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span>// 读取 对象地址 到寄存器 <span class="hljs-built_in">AX</span> <span class="hljs-symbol">data_access.go:</span><span class="hljs-number">29</span><span class="hljs-number">0x10949cc</span><span class="hljs-number">8400</span>TESTB <span class="hljs-built_in">AL</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">AX</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">29</span><span class="hljs-number">0x10949ce</span>f30f104004<span class="hljs-keyword">MOVSS</span> <span class="hljs-number">0x4</span>(<span class="hljs-built_in">AX</span>), X0// 从对象起始地址偏移<span class="hljs-number">4</span>字节读取数据到寄存器 X0 <span class="hljs-symbol">data_access.go:</span><span class="hljs-number">29</span><span class="hljs-number">0x10949d3</span>f30f11442440<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x40</span>(<span class="hljs-built_in">SP</span>)// 赋值 寄存器 X0 给 w</code></pre><p>可以看到，每个成员变量的偏移量在编译时即可获知，不管其有多么复杂的继承，都是一样的。通过对象存取一个data member，其效率和存取一个非成员变量是一样的。</p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>前面的例子提过，对象的总大小刚好等于所有的成员变量之和，也就意味着成员函数并不占用对象的内存大小。那成员函数的调用是怎么实现的呢？我们通过一段代码看下</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> point3d <span class="hljs-keyword">struct</span> &#123;X, Y, Z <span class="hljs-keyword">float32</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *point3d)</span> <span class="hljs-title">Println</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">"%v,%v,%v\n"</span>, p.X, p.Y, p.Z)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;p := point3d&#123;X: <span class="hljs-number">1</span>, Y: <span class="hljs-number">2</span>, Z: <span class="hljs-number">3</span>&#125; <span class="hljs-comment">// L14</span>p.Println()                   <span class="hljs-comment">// L15</span>&#125;</code></pre><p>同样使用 go tool获取对应的汇编代码</p><pre><code class="hljs x86asm"><span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094a7d</span>0f57c0<span class="hljs-keyword">XORPS</span> X0, X0<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094a80</span>f30f1144240c<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0xc</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094a86</span>f30f11442410<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x10</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094a8c</span>f30f11442414<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x14</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094a92</span>f30f100592b30400<span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.</span>3f800000(SB), X0<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094a9a</span>f30f1144240c<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0xc</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094aa0</span>f30f100588b30400<span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.40000000</span>(SB), X0<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094aa8</span>f30f11442410<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x10</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094aae</span>f30f10057eb30400<span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.40400000</span>(SB), X0<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094ab6</span>f30f11442414<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x14</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">call.go:</span><span class="hljs-number">15</span><span class="hljs-number">0x1094abc</span>488d44240cLEAQ <span class="hljs-number">0xc</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span> //将对象 q 的起始地址保存到寄存器<span class="hljs-built_in">AX</span><span class="hljs-symbol">call.go:</span><span class="hljs-number">15</span><span class="hljs-number">0x1094ac1</span><span class="hljs-number">48890424</span><span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">SP</span>)  //将对象 q 的起始地址 压栈<span class="hljs-symbol">call.go:</span><span class="hljs-number">15</span><span class="hljs-number">0x1094ac5</span>e8d6fdffff<span class="hljs-keyword">CALL</span> main.(*point3d).Println(SB)  // 调用 struct point 的 Println() 函数</code></pre><p>可以看到成员函数的调用都是先把参数压栈，然后调用对应的的函数。可见，成员函数与普通的函数调用并无不同。那么函数的内存在哪里呢？</p><p>还记得进程的内存分布么？</p><p><img src="/images/go-object-model/process-memory.png" alt="process-memory.png"></p><p>没错，所有的函数都在进程的代码段（Text Segment）</p><h3 id="Interface-语意学"><a href="#Interface-语意学" class="headerlink" title="Interface 语意学"></a>Interface 语意学</h3><p>第一部分讲了，封装和继承的影响，剩下这部分会讲清楚 Go 如何使用 interface 实现<code>多态</code>和<code>反射</code>。其中interface又有两种形式，一种是有函数的非空interface，一种是空的interface（interface{}）。话不多说，直接上代码，看下这两种类型的interface的变量在内存大小上有何区别：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">interface</span> &#123;Println()&#125;<span class="hljs-keyword">type</span> point <span class="hljs-keyword">struct</span> &#123;X <span class="hljs-keyword">float32</span>&#125;<span class="hljs-keyword">type</span> point2d <span class="hljs-keyword">struct</span> &#123;pointY <span class="hljs-keyword">float32</span>&#125;<span class="hljs-keyword">type</span> point3d <span class="hljs-keyword">struct</span> &#123;point2dZ <span class="hljs-keyword">float32</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPolymorphism</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">var</span> (p Point)p = &amp;point&#123;X: <span class="hljs-number">1</span>&#125;fmt.Printf(<span class="hljs-string">"point size:%v\n\n"</span>, unsafe.Sizeof(p))p = &amp;point2d&#123;point: point&#123;X: <span class="hljs-number">1</span>&#125;, Y: <span class="hljs-number">2</span>&#125;fmt.Printf(<span class="hljs-string">"point2d size:%v\n\n"</span>, unsafe.Sizeof(p))p = &amp;point3d&#123;point2d: point2d&#123;point: point&#123;X: <span class="hljs-number">1</span>&#125;, Y: <span class="hljs-number">2</span>&#125;, Z: <span class="hljs-number">3</span>&#125;fmt.Printf(<span class="hljs-string">"point3d size:%v\n\n"</span>, unsafe.Sizeof(p))&#125;</code></pre><p>执行程序输出为：</p><pre><code class="hljs sh">$ go <span class="hljs-built_in">test</span> -v -run TestPolymorphism=== RUN   TestPolymorphismp size:16, nilP size:16p size:16, nilP size:16p size:16, nilP size:16</code></pre><p>可以看到两种类型的interface 变量大小并无不同，均为16字节。可以明确一点：interface 变量中存储的并非对象的指针，而是特殊的定义类型的变量。那么 interface 是怎么支持<code>多态</code>和<code>反射</code>的呢？</p><p>通过 <code>reflect</code> 包，我们找到了答案。原来，针对以上两种类型的interface， Go 语言底层定义了两个结构分别为 iface 和 eface。两者实现是类似的，以下我们仅针对非空interface进行分析</p><h4 id="interface-底层"><a href="#interface-底层" class="headerlink" title="interface 底层"></a>interface 底层</h4><pre><code class="hljs go"><span class="hljs-keyword">type</span> iface <span class="hljs-keyword">struct</span> &#123;    tab  *itab          <span class="hljs-comment">// 类型信息</span>    data unsafe.Pointer  <span class="hljs-comment">// 接口指向对象的指针</span>&#125;<span class="hljs-comment">// 类型信息</span><span class="hljs-keyword">type</span> itab <span class="hljs-keyword">struct</span> &#123;    inter  *interfacetype    <span class="hljs-comment">// 接口的类型信息</span>    _type  *_type           <span class="hljs-comment">// 接口指向对象的类型信息</span>hash  <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// copy of _type.hash. Used for type switches.</span>_     [<span class="hljs-number">4</span>]<span class="hljs-keyword">byte</span>    fun    [<span class="hljs-number">1</span>]<span class="hljs-keyword">uintptr</span>       <span class="hljs-comment">// 接口方法实现列表，即函数地址列表，按字典序排序</span>&#125;<span class="hljs-comment">// 接口类型信息</span><span class="hljs-keyword">type</span> interfacetype <span class="hljs-keyword">struct</span> &#123;   typ     _type   pkgpath name   mhdr    []imethod      <span class="hljs-comment">// 接口方法声明列表，按字典序排序</span>&#125;</code></pre><p>通过代码，可以看到，iface 类型包含两个指针，刚好为16字节（64位机器）。iface 不但包含了<code>指向对象</code>、<code>指向对象的类型</code>，还包含了<code>接口类型</code>。如此</p><ol><li>iface 就可以在其中扮演粘结剂的角色，通过 reflect 包在对象、接口、类型之间进行转换了。</li><li>iface 的变量可以在<code>编译</code>阶段，在变量赋值处，增加拷贝指向对象（父类或者子类）的类型信息的指令，就可以在运行期完成多态的支持了</li></ol><p><img src="/images/go-object-model/interface.png" alt="interface.png"></p><h4 id="理论验证"><a href="#理论验证" class="headerlink" title="理论验证"></a>理论验证</h4><p>下面我们还是通过测试代码来验证我们的理论，我们自己定义底层的相关类型，然后通过强制类型转换，来尝试解析interface变量中的数据：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Iface <span class="hljs-keyword">struct</span> &#123;Tab *ItabData unsafe.Pointer&#125;<span class="hljs-keyword">type</span> Itab <span class="hljs-keyword">struct</span> &#123;Inter <span class="hljs-keyword">uintptr</span>Type <span class="hljs-keyword">uintptr</span>Hash <span class="hljs-keyword">uint32</span>_ [<span class="hljs-number">4</span>]<span class="hljs-keyword">byte</span>Fun [<span class="hljs-number">1</span>]<span class="hljs-keyword">uintptr</span>&#125;<span class="hljs-keyword">type</span> Eface <span class="hljs-keyword">struct</span> &#123;Type <span class="hljs-keyword">uintptr</span>Data unsafe.Pointer&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestInterface</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">var</span> (p    PointnilP <span class="hljs-keyword">interface</span>&#123;&#125;)point := &amp;point3d&#123;X: <span class="hljs-number">1</span>, Y: <span class="hljs-number">2</span>, Z: <span class="hljs-number">3</span>&#125;nilP = pointfmt.Printf(<span class="hljs-string">"eface size:%v\n"</span>, unsafe.Sizeof(nilP))eface := (*face.Eface)(unsafe.Pointer(&amp;nilP))spew.Dump(eface.Type)spew.Dump(eface.Data)fmt.Printf(<span class="hljs-string">"eface offset: eface._type = %v, eface.data = %v\n\n"</span>,unsafe.Offsetof(eface.Type), unsafe.Offsetof(eface.Data))p = pointfmt.Printf(<span class="hljs-string">"point size:%v\n"</span>, unsafe.Sizeof(p))iface := (*face.Iface)(unsafe.Pointer(&amp;p))spew.Dump(iface.Tab)spew.Dump(iface.Data)fmt.Printf(<span class="hljs-string">"Iface offset: iface.tab = %v, iface.data = %v\n\n"</span>,unsafe.Offsetof(iface.Tab), unsafe.Offsetof(iface.Data))&#125;</code></pre><p>执行程序输出为：</p><pre><code class="hljs sh">$ go <span class="hljs-built_in">test</span> -v -run TestInterface=== RUN   TestInterfaceeface size:16(uintptr) 0x111f2c0(unsafe.Pointer) 0xc00008e250eface offset: eface._type = 0, eface.data = 8point size:16(*face.Itab)(0x116ec40)(&#123; Inter: (uintptr) 0x1122680, Type: (uintptr) 0x111f2c0, Hash: (uint32) 960374823, _: ([4]uint8) (len=4 <span class="hljs-built_in">cap</span>=4) &#123;  00000000  00 00 00 00                                       |....| &#125;, Fun: ([1]uintptr) (len=1 <span class="hljs-built_in">cap</span>=1) &#123;  (uintptr) 0x10fce20 &#125;&#125;)(unsafe.Pointer) 0xc00008e250Iface offset: iface.tab = 0, iface.data = 8</code></pre><p>下面我们再通过汇编代码看下，赋值操作做了什么？</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">interface</span> &#123;Println()&#125;<span class="hljs-keyword">type</span> point3d <span class="hljs-keyword">struct</span> &#123;X, Y, Z <span class="hljs-keyword">float32</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *point3d)</span> <span class="hljs-title">Println</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">"%v,%v,%v\n"</span>, p.X, p.Y, p.Z)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;point := point3d&#123;X: <span class="hljs-number">1</span>, Y: <span class="hljs-number">2</span>, Z: <span class="hljs-number">3</span>&#125; <span class="hljs-comment">// L18</span><span class="hljs-keyword">var</span> (nilP <span class="hljs-keyword">interface</span>&#123;&#125;   <span class="hljs-comment">// L20</span>p    Point        <span class="hljs-comment">// L21</span>)nilP = &amp;point         <span class="hljs-comment">// L23</span>p = &amp;point            <span class="hljs-comment">// L24</span>fmt.Println(nilP, p) &#125;</code></pre><p>通过 go tool 查看汇编代码如下：</p><pre><code class="hljs x86asm">TEXT main<span class="hljs-number">.</span>main(SB) /Users/cyningsun/Documents/go/src/github<span class="hljs-number">.</span>com/cyningsun/go-<span class="hljs-keyword">test</span>/<span class="hljs-number">20200102</span>-inside-golang-object-model/main/build<span class="hljs-number">.</span>go<span class="hljs-symbol">  build.go:</span><span class="hljs-number">17</span><span class="hljs-number">0x1094de0</span>65488b0c2530000000      <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">GS</span>:<span class="hljs-number">0x30</span>, <span class="hljs-built_in">CX</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">17</span><span class="hljs-number">0x1094de9</span>488d4424b0              LEAQ -<span class="hljs-number">0x50</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">17</span><span class="hljs-number">0x1094dee</span>483b4110                CMPQ <span class="hljs-number">0x10</span>(<span class="hljs-built_in">CX</span>), <span class="hljs-built_in">AX</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">17</span><span class="hljs-number">0x1094df2</span>0f86b9010000            <span class="hljs-keyword">JBE</span> <span class="hljs-number">0x1094fb1</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">17</span><span class="hljs-number">0x1094df8</span>4881ecd0000000          SUBQ <span class="hljs-number">$0</span>xd0, <span class="hljs-built_in">SP</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">17</span><span class="hljs-number">0x1094dff</span>4889ac24c8000000        <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">BP</span>, <span class="hljs-number">0xc8</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">17</span><span class="hljs-number">0x1094e07</span>488dac24c8000000        LEAQ <span class="hljs-number">0xc8</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">BP</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e0f</span>488d05ea1e0200          LEAQ type.*+<span class="hljs-number">137216</span>(SB), <span class="hljs-built_in">AX</span>   // point := point3d&#123;X: <span class="hljs-number">1</span>, Y: <span class="hljs-number">2</span>, Z: <span class="hljs-number">3</span>&#125;<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e16</span><span class="hljs-number">48890424</span>                <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e1a</span>e81160f7ff              <span class="hljs-keyword">CALL</span> runtime<span class="hljs-number">.</span>newobject(SB)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e1f</span>488b442408              <span class="hljs-keyword">MOVQ</span> <span class="hljs-number">0x8</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e24</span><span class="hljs-number">4889442458</span>              <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0x58</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e29</span>0f57c0                  <span class="hljs-keyword">XORPS</span> X0, X0<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e2c</span>f30f11442434            <span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x34</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e32</span>f30f11442438            <span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x38</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e38</span>f30f1144243c            <span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x3c</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e3e</span>f30f1005a6b80400        <span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.</span>3f800000(SB), X0<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e46</span>f30f11442434            <span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x34</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e4c</span>f30f100d9cb80400        <span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.40000000</span>(SB), X1<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e54</span>f30f114c2438            <span class="hljs-keyword">MOVSS</span> X1, <span class="hljs-number">0x38</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e5a</span>f30f101592b80400        <span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.40400000</span>(SB), X2<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e62</span>f30f1154243c            <span class="hljs-keyword">MOVSS</span> X2, <span class="hljs-number">0x3c</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e68</span>488b442458              <span class="hljs-keyword">MOVQ</span> <span class="hljs-number">0x58</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e6d</span>f30f1100                <span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0</span>(<span class="hljs-built_in">AX</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e71</span>f30f114804              <span class="hljs-keyword">MOVSS</span> X1, <span class="hljs-number">0x4</span>(<span class="hljs-built_in">AX</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e76</span>f30f115008              <span class="hljs-keyword">MOVSS</span> X2, <span class="hljs-number">0x8</span>(<span class="hljs-built_in">AX</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">20</span><span class="hljs-number">0x1094e7b</span>0f57c0                  <span class="hljs-keyword">XORPS</span> X0, X0 // nilP interface&#123;&#125;<span class="hljs-symbol">  build.go:</span><span class="hljs-number">20</span><span class="hljs-number">0x1094e7e</span>0f11442470              <span class="hljs-keyword">MOVUPS</span> X0, <span class="hljs-number">0x70</span>(<span class="hljs-built_in">SP</span>)// nilP 开始地址为<span class="hljs-number">0x70</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">21</span><span class="hljs-number">0x1094e83</span>0f57c0                  <span class="hljs-keyword">XORPS</span> X0, X0 // p Point<span class="hljs-symbol">  build.go:</span><span class="hljs-number">21</span><span class="hljs-number">0x1094e86</span>0f11442460              <span class="hljs-keyword">MOVUPS</span> X0, <span class="hljs-number">0x60</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">23</span><span class="hljs-number">0x1094e8b</span>488b442458              <span class="hljs-keyword">MOVQ</span> <span class="hljs-number">0x58</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span>// nilP = &amp;point  ；<span class="hljs-number">0x58</span>(<span class="hljs-built_in">SP</span>) 为 point 的地址<span class="hljs-symbol">  build.go:</span><span class="hljs-number">23</span><span class="hljs-number">0x1094e90</span><span class="hljs-number">4889442448</span>              <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0x48</span>(<span class="hljs-built_in">SP</span>) // <span class="hljs-built_in">SP</span> 指向 point 地址<span class="hljs-symbol">  build.go:</span><span class="hljs-number">23</span><span class="hljs-number">0x1094e95</span>488d0da4860100          LEAQ type.*+<span class="hljs-number">98368</span>(SB), <span class="hljs-built_in">CX</span> // ；从内存加载 Point类型地址 到 <span class="hljs-built_in">CX</span> 寄存器<span class="hljs-symbol">  build.go:</span><span class="hljs-number">23</span><span class="hljs-number">0x1094e9c</span>48894c2470              <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">CX</span>, <span class="hljs-number">0x70</span>(<span class="hljs-built_in">SP</span>) // ；将 Point类型地址（<span class="hljs-number">8</span>字节） 保存到 <span class="hljs-number">0x70</span>（即eface<span class="hljs-number">.</span>_type）<span class="hljs-symbol">  build.go:</span><span class="hljs-number">23</span><span class="hljs-number">0x1094ea1</span><span class="hljs-number">4889442478</span>              <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0x78</span>(<span class="hljs-built_in">SP</span>) // ；将 point 对象地址（<span class="hljs-number">8</span>字节） 保存到 <span class="hljs-number">0x78</span>（即eface<span class="hljs-number">.</span>data）<span class="hljs-symbol">  build.go:</span><span class="hljs-number">24</span><span class="hljs-number">0x1094ea6</span>488b442458              <span class="hljs-keyword">MOVQ</span> <span class="hljs-number">0x58</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span>// p = &amp;point<span class="hljs-symbol">  build.go:</span><span class="hljs-number">24</span><span class="hljs-number">0x1094eab</span><span class="hljs-number">4889442448</span>              <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0x48</span>(<span class="hljs-built_in">SP</span>)// ；<span class="hljs-built_in">SP</span> 指向 point 地址<span class="hljs-symbol">  build.go:</span><span class="hljs-number">24</span><span class="hljs-number">0x1094eb0</span>488d0d09d50400          LEAQ go<span class="hljs-number">.</span>itab.*main<span class="hljs-number">.</span>point3d,main<span class="hljs-number">.</span>Point(SB), <span class="hljs-built_in">CX</span>// ；从内存加载 Point类型 itab 地址 到 <span class="hljs-built_in">CX</span> 寄存器<span class="hljs-symbol">  build.go:</span><span class="hljs-number">24</span><span class="hljs-number">0x1094eb7</span>48894c2460              <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">CX</span>, <span class="hljs-number">0x60</span>(<span class="hljs-built_in">SP</span>)// ；将 Point类型地址（<span class="hljs-number">8</span>字节） 保存到 <span class="hljs-number">0x70</span>（即iface<span class="hljs-number">.</span>tab）<span class="hljs-symbol">  build.go:</span><span class="hljs-number">24</span><span class="hljs-number">0x1094ebc</span><span class="hljs-number">4889442468</span>              <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0x68</span>(<span class="hljs-built_in">SP</span>)// ；将 point 对象地址（<span class="hljs-number">8</span>字节） 保存到 <span class="hljs-number">0x78</span>（即iface<span class="hljs-number">.</span>data）<span class="hljs-symbol">  build.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x1094ec1</span>488b442468              <span class="hljs-keyword">MOVQ</span> <span class="hljs-number">0x68</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span>// fmt<span class="hljs-number">.</span>Println(nilP, p)  ...</code></pre><p>事实正如理论一般，在<code>编译</code>阶段，赋值命令被转化为类型信息和对象指针的拷贝，保存下来执行期转换所需要的一切信息。</p><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p>从底层代码和汇编出发，分析 struct 和 interface 的 对象模型，理清了Go 语言高级特性的底层机制。再去学习反射等表层细节，事半功倍。</p><p>参考链接：</p><ul><li><a href="https://www.cnblogs.com/qcrao-2018/p/11124360.html" target="_blank" rel="noopener">https://www.cnblogs.com/qcrao-2018/p/11124360.html</a></li><li><a href="https://yougg.github.io/2017/03/27/%E7%90%86%E8%A7%A3go%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B1interface%E5%BA%95%E5%B1%82%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">https://yougg.github.io/2017/03/27/理解go语言模型1interface底层详解/</a></li><li><a href="https://wudaijun.com/2018/01/go-interface-implement/" target="_blank" rel="noopener">https://wudaijun.com/2018/01/go-interface-implement/</a></li><li><a href="https://chai2010.cn/advanced-go-programming-book/ch3-asm/readme.html" target="_blank" rel="noopener">https://chai2010.cn/advanced-go-programming-book/ch3-asm/readme.html</a></li><li><a href="https://www.cnblogs.com/lsgxeva/p/8948153.html" target="_blank" rel="noopener">https://www.cnblogs.com/lsgxeva/p/8948153.html</a></li></ul><p><em>源代码：<a href="https://github.com/cyningsun/go-test" target="_blank" rel="noopener">https://github.com/cyningsun/go-test</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;了解一门语言的高级特性，仅仅从浮于表面，是无法把握住语言的精髓的。学习过 C++ 的高阶开发者，一定读过神书《Inside The C++ Object Model》，本文的目标是一样的：通过对象模型，掌握 Go 语言的底层机制，从更深层次解释语言特性。&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Object model" scheme="https://www.cyningsun.com/tag/Object-model/"/>
    
  </entry>
  
  <entry>
    <title>译 | Concurrency is not Parallelism</title>
    <link href="https://www.cyningsun.com/12-09-2019/concurrency-is-not-parallelism.html"/>
    <id>https://www.cyningsun.com/12-09-2019/concurrency-is-not-parallelism.html</id>
    <published>2019-12-08T16:00:00.000Z</published>
    <updated>2020-02-03T06:53:29.645Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Concurrency-vs-Parallelism"><a href="#Concurrency-vs-Parallelism" class="headerlink" title="Concurrency vs Parallelism"></a>Concurrency vs Parallelism</h3><p><img src="/images/concurrency-is-not-parallelism/F684CB18-B7F7-4F72-937B-AB9486A9DD17.png" alt=""><br>如果你看看今天的编程语言，可能会发现这个世界是面向对象的，但实际上并非如此，世界是并行的。你通过网络等等，从最底层（例如：多核计算机）获取所有的东西，一路攀升到了解星球、宇宙。世界上所有的东西都在同时发生，但我们拥有的计算工具实际上并不擅长表达这种世界观。看起来似乎是一种失败，如果我们了解什么是并发性，以及如何使用它，就可以解决这个问题。</p><p><img src="/images/concurrency-is-not-parallelism/0B4B7CFD-C8F6-47F5-A1E6-88D65BB85FE9.png" alt=""><br>我将假设你们中的大多数人至少听说过 Go 编程语言，它也是我最近几年在 Google 工作的内容。Go 是一种并发语言，也就是说它使并发性有用，有像上帝一样同时执行事物的能力；有在同时执行的事物之间进行通信的能力；有叫做 <code>select</code> 语句的东西，它是一个多路并发控制开关。如果你搞不懂是怎么回事，不用担心。</p><p><img src="/images/concurrency-is-not-parallelism/E38701F9-2700-4C07-B65D-A29D775B97C6.png" alt=""><br>在大约两年前，当我们发布 Go 时，在场的程序员都说：”哦，并发工具，我知道做什么的，并行运行，耶“。但实际并非如此，并发性和并行性是不一样的，这是个常被误解的问题。我在这里试图解释原因，并向您展示并发性实际上更好。那些困惑的人会碰到什么事情：他们执行的程序，在更多的处理器上会变得更慢。他们会认为有问题，不管用，想要逃开。但真正有问题的是世界观，我希望我能改正它。</p><p><img src="/images/concurrency-is-not-parallelism/4F88E118-687C-4F42-8BE2-2D5580831530.png" alt=""><br>什么是并发性？并发性，如我当前使用的一样，用于计算机科学领域，是一种构建事物的方法。它是由独立执行的事物组成，通常是 <code>function</code>，虽然不一定必须如此。我们通常称之为交互式进程。称其为进程，并不是指 Linux 进程，指的是一种普遍的概念，它包括线程、协程、进程等等，所以尽可能抽象的理解。并发性由独立执行的进程组成；</p><p><img src="/images/concurrency-is-not-parallelism/ED376883-6235-46F5-91CA-37BCC88A753C.png" alt=""><br>另一方面，并行性是同时执行多个事物，可能相关，也可能无关。</p><p><img src="/images/concurrency-is-not-parallelism/7C6D5DA7-C6F2-4225-AA5B-23BCE7004567.png" alt=""><br>如果你用语焉不详的方式思考，并发性是指同时负责很多事情；并行性是指同时做很多事情。它们显然是相关的，但实际上是不同的概念，如果没有合适的工具包，尝试思考它们会有些困惑。一个是关于结构并发性，另一个是关于执行并行性。我会告诉你为什么这些概念很重要。并发性是一种构造事物的方法，以便可以使用并行性更好地完成工作。但并行性不是并发性的目标，并发性的目标是好的结构。</p><h4 id="An-analogy"><a href="#An-analogy" class="headerlink" title="An analogy"></a>An analogy</h4><p><img src="/images/concurrency-is-not-parallelism/9F2DC49E-17EB-4AA6-9BEB-5B7572D57E3B.png" alt=""><br>如果你在运行一个操作系统的话，会很熟悉的一个类比。操作系统可能有鼠标驱动程序、键盘驱动程序、显示驱动程序、网络驱动程序等等，都是由操作系统管理的，内核中的独立事物。它们都是并发的事物，却不一定是并行的。如果只有一个处理器，同一时间其中只有一个处于运行。I/O 设备具有一个并发模型，但本质不是并行的，它不需要是并行的。并行的事物可能类似向量点积，可以分解为微观操作，以使得可以在一些精美的计算机上并行执行。非常不同的概念，完全不是同一个东西。</p><h4 id="Cocurrency-plus-communication"><a href="#Cocurrency-plus-communication" class="headerlink" title="Cocurrency plus communication"></a>Cocurrency plus communication</h4><p><img src="/images/concurrency-is-not-parallelism/2D14E937-5A14-45E8-BDAC-7C62467C07F0.png" alt=""><br>为了能利用并发性，必须添加 <code>communication</code> 的概念。我今天不会聚焦于该概念太多，但一会儿你会看到一点点。并发性提供了一种将程序构造为独立块的方法，然后，必须使这些块协调一致。要使之工作，需要某种形式的 <code>communication</code>。<code>Tony Hoare</code> 在1978年写了一篇论文叫做 <code>《communicating sequential processes》</code>，实在是计算机科学中最伟大的论文之一。如果你还没读过，要是从本次演讲中真有什么领悟的话，回家你应该读读那篇论文。它太不可思议了，基于此论文，很多人未进行太多考虑就遵循、并构建工具，以将其思想运用到并发语言中，比如另一种很棒的语言Erlang。GO 中也有其一些思想，关键点都在原稿中，除了稍后会提到的几个小例外。</p><h4 id="Gophers"><a href="#Gophers" class="headerlink" title="Gophers"></a>Gophers</h4><p><img src="/images/concurrency-is-not-parallelism/C9C673A4-F191-49EA-9B1B-1BB894D5D75C.png" alt=""><br>但，你看这一切太抽象了。我们需要 Gopher 的帮忙，来一些 Gopher。</p><p><img src="/images/concurrency-is-not-parallelism/FD9C0294-1503-471E-B9D8-59696940C557.png" alt=""><br>有一个真正的问题我们要解决。有一堆过时的手册，可以是 C++98 手册，现在已经是 C++11；或许是 C++11 书籍，但不再需要了。关键是我们想要清理掉它们，它们占用了大量空间。所以我们的 Gopher 有一个任务，把书从书堆里取出来，放到焚化炉里清理掉。但是，如果是一大堆书，只有一个 Gopher 需要很长时间。Gopher 也不擅长搬运书籍，尽管我们提供了小车。</p><p><img src="/images/concurrency-is-not-parallelism/AA95F628-5041-42A0-B149-482B966B7D43.png" alt=""><br>所以再增加一个 Gopher 来解决这个问题，只有 Gopher 不会好起来，对吧？</p><p><img src="/images/concurrency-is-not-parallelism/E12F9D73-BF48-4C56-9AB6-A61B421B8464.png" alt=""><br>因为它需要工具，无可厚非，我们需要提供所有它需要的东西。Gopher 不仅需要作为 Gopher 的能力，也需要工具来完成任务。再给它一辆车，现在这样应该会更快。在两个 Gopher 推车的情况下，肯定能更快地搬运书。但可能存在一个小问题，因为我们必须使它们同步。来回奔波中，书堆互相妨碍，它们可能会被困在焚化炉里，所以它们需要协调一点。所以你可以想象 Gopher 们发送 <code>Tony Hoare</code> 的短信息，说：我到了，我需要空间把书放进焚化炉。不管是什么，但你明白了，这很傻。但我想解释清楚，这些概念并不深刻，它们非常好。</p><p><img src="/images/concurrency-is-not-parallelism/2EEF58D1-D127-441E-8DF4-EF08E1C6CBAD.png" alt=""><br>如何让它们搬运得更快，我们把一切都增加一倍。我们提供两个 Gopher，把书堆，焚化炉和 Gopher 一样也增加一倍。现在我们可以在相同的时间里搬运两倍的书，这是并行，对吧？</p><p><img src="/images/concurrency-is-not-parallelism/90B02D9C-3BE5-419A-82C5-2EAB915CBA46.png" alt=""><br>但是，想象它不是并行，而是两个 Gopher 的并发组合。并发性是我们表达问题的方式，两个 Gopher 可以做到这一点。我们通过实例化 Gopher 程序的更多实例来并行，这被称为进程（在此情况下称为 Gopher）的并发组合。</p><p><img src="/images/concurrency-is-not-parallelism/B71AB8B0-A361-4E9C-92CB-75437AF18B2B.png" alt=""><br>现在这种设计不是自动并行的。确实有两个 Gopher，但是谁说它们必须同时工作呢？我可以说，同时只有一个 Gopher 可以移动，就像单核计算机，此设计仍然是并发的，很好很正确，但它本质上不是并行的，除非让两个 Gopher 同时搬运。当并行出现时，有两个事物同时执行，而不仅仅是拥有两个事物。这是一个非常重要的模型，一旦断定理解了它，我们就会明白可以把问题分解成并发的块。</p><p><img src="/images/concurrency-is-not-parallelism/157116FA-6AF0-4F38-9F1A-7E59FE41A390.png" alt=""><br>我们可以想出其他模型，下面有一个不同的设计。在图中有三个 Gopher，同一堆书，同一个焚化炉，但是现在有三个 Gopher。有一个 Gopher，它的工作就是装车；有一个 Gopher，它的工作就是推车，然后再把空的还回去；还有一个 Gopher，它的工作就是装入焚化炉。三个 Gopher，速度理应会更快。但可能不会快多少，因为它们会被阻塞。书可能在错误的地方，在那里没有什么需要用车来做的。</p><p><img src="/images/concurrency-is-not-parallelism/2493625A-CFD7-4F6C-913D-4EAE6CA70EA5.png" alt=""><br>让我们处理下这个问题，另外增加一个Gopher归还空车，这明显很傻。但我想指出一个相当深刻的问题，这个版本的问题实际上会比之前版本的问题执行得更好。尽管为了完成更多的工作，增加了一个 Gopher 来回奔波。因此，一旦我们理解了并发性的概念，就可以向图片增加 Gopher，真的可以做更多的工作，使之运行得更快。因为管理的更好的块的并发组合真的可以运行得更快。工作可能不会恰好完美地进行，但是可以想象如果所有的 Gopher 的时间都恰到好处，它们知道每次搬运多少书。并发组合真的可以让4个 Gopher 都一直在忙碌。事实上，此版本可能比原来的版本快四倍。虽然可能性不大，但是我想让你理解，是可能的。</p><p><img src="/images/concurrency-is-not-parallelism/74721CF7-F9B0-4CEE-98F2-3495E0A5F8B7.png" alt=""><br>此时有一个发现，它非常重要而且很微妙，有些柔性。我们在现有的设计中通过添加并发程序来提高程序的性能。我们真的添加了更多的东西，整个过程变得更快了。如果仔细想想，有点奇怪，也有点不奇怪。因为额外添加了一个 Gopher，而且 Gopher 确实工作。但是如果你忘记了它是个 Gopher 的事实，并认为只是增加了东西，设计确实可以使它更高效。并行性可以出自于对问题更好的并发表达，这是一个相当深刻的见解。因为 Gopher 们的参与所以看起来不像。但是没关系。</p><p><img src="/images/concurrency-is-not-parallelism/92E07F4D-25AE-4575-819E-9992C18E7C26.png" alt=""><br>此时有四个进程并发运行。一个 Gopher 将东西装到车中；一个 Gopher 把车运到焚化炉；还有另一个 Gopher 将车中的物品卸到焚化炉中；第四个 Gopher 把空车还回来。您可以将它们视为独立的进程，完全独立运行的进程，我们只是将它们并行组合以构建完整的程序解决方案。这不是我们唯一可以构造的方案，以下是一个完全不同的设计。</p><p><img src="/images/concurrency-is-not-parallelism/4C538C68-A0E3-4EBA-AB71-7CC7FCA76F81.png" alt=""><br>通过增加另外一个堆书、焚化炉、和4个 Gopher，可以使该设计更加并行。但关键是，采用已有概念以分解问题。一旦清楚这是并发分解，就可以在不同的纬度上使其并行化。无论能否获得更好的吞吐量，但是至少，我们得以更细粒度的理解问题，可以控制这些块。在此情况下，如果一切刚好，会有8个 Gopher 努力以烧掉那些C++手册。</p><p><img src="/images/concurrency-is-not-parallelism/23DD3245-CDD7-49FF-8004-B8E3785CE7FD.png" alt=""><br>当然，也许根本没有发生并行，谁说这些 Gopher 必须同时工作，我可能每次只能运行一个 Gopher。在这种情况下，该设计只能像原始问题一样，以单个 Gopher 的速率运行。它执行时，其他7个将全部空闲。但该设计仍然是正确的。这很了不得，因为意味着我们在保证并发性时不必担心并行性。如果并发性正确，并行性实际上是一个自由变量，决定有多少个 Gopher 处于忙碌。我们可以为整个事情做一个完全不同的设计。</p><p><img src="/images/concurrency-is-not-parallelism/94750AF1-3D35-43D8-A44F-0A5BCE4CDC19.png" alt=""><br>让我们忘记将旧模式投入到新模式。在故事中有两个 Gopher，不再让一个 Gopher 从书堆一直运到焚化炉，而是在中间加入暂存区。因此，第一个 Gopher 将书籍搬运到暂存区，将它们丢下，跑回去再运另外一些。第二个 Gopher 坐在那里等待书达到暂存区，并把书从该位置搬运到焚化炉。如果一切良好，则有两个 Gopher 进程运行。它们是相同的类型，但有些细微不同，参数略有不同。如果系统将正常运行，一旦启动，其运行速度就会是原始模式的两倍。即使某些方面说它是完全不同的设计。一旦我们有了这个组合，我们可以采取另外的做法。</p><p><img src="/images/concurrency-is-not-parallelism/9622DA01-FA9C-4EC1-BE6A-AF554458F36C.png" alt=""><br>将以惯常的做法使其并行，同时运行整个程序的两个版本。翻倍之后，有了4个 Gopher，吞吐量将高达四倍。</p><p><img src="/images/concurrency-is-not-parallelism/CD8E183B-0510-485A-BD2D-27AD65026A1D.png" alt=""><br>或者，我们可以采用另一种做法，在刚才的并发多 Gopher 问题中，在中间加入暂存区。因此，现在我们有8个 Gopher 在运行，书籍非常快的速度被焚烧。</p><p><img src="/images/concurrency-is-not-parallelism/0524DA9D-3545-4F1C-B1A7-E8CB6F9B81C3.png" alt=""><br>但这样还不够好，因为我们可以在另一个维度并行，运力全开。此时，有16个 Gopher 将这些书搬运到焚化炉中。显然，增加 Gopher 使问题解决的更好，是非常简单和愚蠢的。但我希望您了解，从概念上讲，这真的就是您考虑并行运行事物的方式。您无需考虑并行运行，而是考虑如何将问题以可分解、可理解、可操作的方式，分解为独立的块，然后组合起来以解决整个问题。</p><h4 id="Lesson"><a href="#Lesson" class="headerlink" title="Lesson"></a>Lesson</h4><p><img src="/images/concurrency-is-not-parallelism/6FB652B7-954B-424E-8063-88E31B9B50B6.png" alt=""><br>以上就是的所有例子有什么意义呢？</p><p>首先，有很多方法可以做到这一点，我刚刚展示了一些。如果你坐在那里拿着一本速写册，你可能会想出另外50种让 Gopher 搬运书的方法。有很多不同的设计,它们不必都相同，但它们都能工作。然后，您可以对这些并发设计进行重构、重新排列、按不同的维度进行缩放，得到不同的功能以处理问题。真是太好了，因为不管你怎么做，处理这个问题的算法的正确性很容易保证。这样做不会搞砸，我的意思它们只是 Gopher，你知道这些设计本质上是安全的，因为你是那样做的。但是，这无疑是一个愚蠢的问题，与实际工作无关。嗯，事实上确实有关。</p><p><img src="/images/concurrency-is-not-parallelism/5E0FB781-8D54-40A7-8C96-1BFC52045109.png" alt=""><br>因为如果你拿到这个问题，把书堆换成一些网络内容；把 Gopher 换成 CPU，把推车换成网络或编码代码等等；把问题变成你需要移动数据；焚化炉是网络代理，或是浏览器，你想到的任何的数据使用者。您刚刚构建了一个 Web 服务体系结构的设计。你可能不认为你的 Web 服务架构是这样的，但事实上差不多就是这样。你可以把这两块替换掉看看，这正是你想的那种设计。当你谈论代理、转发代理和缓冲区之类会，扩容更多的实例的东西时，它们都在这个图上，只是不被这么想。本质上并不难理解它们，Gopher 能做到，我们也能。</p><h3 id="A-little-background-about-Go"><a href="#A-little-background-about-Go" class="headerlink" title="A little background about Go"></a>A little background about Go</h3><p><img src="/images/concurrency-is-not-parallelism/7754106E-933B-4A4B-9749-B234117F4857.png" alt=""><br>现在让我来展示如何在使用Go构建东西时采用这些概念。我不打算在这次演讲中教你 Go，希望你们有些人已经知道它，希望大家在之后能去更多了解它。但我要教一点点 Go，希望其他人也能像我们一样融入其中。</p><h4 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h4><p><img src="/images/concurrency-is-not-parallelism/4C5DDD77-2B78-4649-81B9-EFC7FF60BB4A.png" alt=""><br>Go 有叫做 goroutine 的东西，可以认为有点像线程，但实际上是不同的。与其详细地谈有什么不同，不如说说它是什么吧。假设我们有一个函数，函数有两个参数。如果在程序中调用该函数 F，则在执行下一条语句之前要等待该函数完成。很熟悉，大家都知道。但是，如果在调用该函数之前放置关键字 go。你调用该函数，函数开始运行，虽然不一，至少在概念上可以立即继续运行。想想并发与并行，从概念上讲，当 F 不在时，程序一直在运行，你在做 F 的事情，不用等 F 回来。如果你觉得很困惑，那就把它想象成一个很像 shell 里的 &amp; 符号。这就像在后台运行 F &amp;，确切地说是一个 goroutine。</p><p><img src="/images/concurrency-is-not-parallelism/4A73A123-176A-4751-BCAC-07B7CF11988C.png" alt=""><br>它有点像线程，因为一起运行在同一个地址空间中，至少在一个程序中如此。但 goroutine 要廉价得多，创建很容易，创建成本也很低。然后根据需要，goroutine 动态地多路映射到执行中的操作系统线程上，所以不必担心调度、阻塞等等，系统会帮你处理。当 goroutine 确实需要阻塞执行像 read 之类的系统调用时，其他 goroutine 不需要等待它，它们都是动态调度的。所以 goroutine 感觉像线程，却是更轻量版本的线程。这不是一个原始的概念，其他语言和系统已经实现了类似的东西。我们给它起了自己的名字来说明它是什么。所以称之为 goroutine。</p><h4 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h4><p><img src="/images/concurrency-is-not-parallelism/796A1563-AE4E-4143-AFF2-2E880045C514.png" alt=""><br>刚刚已经提到需要在 goroutine 之间通信。为了做到这一点，在 Go 中，称之为 channel。它有点像 shell 中的管道，但它有类型，还有其他一些很棒的特性，今天就不深入了。但以下有一个相当小的例子。我们创建了一个<code>timer channel</code>，显然它是一个时间值的 channel；然后在后台启动这个函数；sleep 一定的时间 deltaT，然后在 <code>timer channel</code> 上发送当时的时间 <code>time.now()</code>。因为此函数是用 go 语句启动的，不需要等待它。它可以做任何想做的事情，当需要知道其他 goroutine 完成时，它说我想从 <code>timer channel</code> 接收那个值。该 goroutine 会阻塞直到有一个值被传递过来。一旦完成，它将设置为得到的时间，即其他 goroutine 完成的时间。小例子，但你需要的一切都在那张小幻灯片里。</p><h4 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h4><p><img src="/images/concurrency-is-not-parallelism/DA19096F-B0A1-4C7B-9CD6-CE1D77E3F7C2.png" alt=""><br>最后一部分叫做 <code>select</code>。它让你可以通过同时监听多个 channel 控制程序的行为。一旦就能看出谁准备好通信了，你就可以读取。在这种情况下，<code>channel 1</code> 或 <code>channel 2</code>，程序的行为将不同，取决于 <code>channel 1</code> 或 <code>channel 2</code> 是否准备就绪。在这种情况下，如果两个都没有准备好，那么 <code>default</code> 子句将运行，这意味着，如果没有人准备好进行通信，那么你会 <code>fall through</code>。如果 <code>default</code> 子句不存在，执行 <code>select</code>，需要等待其中一个或另一个 channel 就绪。如果它们都准备好了，系统会随机挑选一个。所以这种要晚一点才能结束。像 <code>switch</code> 语句，但用于通信场景。如果你知道 <code>Dijkstra</code> 的监督命令，应该会很熟悉</p><p><img src="/images/concurrency-is-not-parallelism/7C761468-B2E1-4D42-AE2F-CA64A57D3D11.png" alt=""><br>当我说 Go 支持并发，是说它确实支持并发，在 Go 程序中创建数千个 goroutine 是常规操作。我们曾经在会议现场调试一个go程序，它运行在生产环境，已经创建了130万个 goroutine，并且在调试它的时候，有1万个活跃的。当然，要做到如此，goroutine 必须比线程廉价得多，这是重点。goroutine 不是免费的，涉及到内存分配，但不多。它们根据需要增长和缩小，而且管理得很好。它们非常廉价，你可以认为和 Gopher 一样廉价。</p><h4 id="Closures"><a href="#Closures" class="headerlink" title="Closures"></a>Closures</h4><p><img src="/images/concurrency-is-not-parallelism/AF92253B-DC36-4493-B4EC-325838093F68.png" alt=""><br>你还需要闭包，我刚在前面的页面展示过闭包，这只是在 Go 语言中可以使用它的证据。因为它们是非常方便的并发表达式，可以创建匿名的 <code>procedure</code>。因此，您可以创建一个函数，在本例中，组合多个函数返回一个函数。这只是一个有效的证明，它是真正的闭包，可以使用 go 语句运行。</p><p><img src="/images/concurrency-is-not-parallelism/6EED864D-47F1-4FC1-9792-E1EDAEB3912E.png" alt=""><br>让我们使用这些元素来构建一些示例。我希望你能潜移默化的学习一些 Go 并发编程，这是最好的学习方法。</p><h3 id="Some-examples"><a href="#Some-examples" class="headerlink" title="Some examples"></a>Some examples</h3><h4 id="Launching-daemons"><a href="#Launching-daemons" class="headerlink" title="Launching daemons"></a>Launching daemons</h4><p><img src="/images/concurrency-is-not-parallelism/098D8054-EFAC-4326-9323-A1174FA5C93B.png" alt=""><br>从启动一个守护进程开始，您可以使用闭包来包装一些您希望完成但不想等待的后台操作。在这种情况下，我们有两个 channel 输入和输出，无论出于什么原因，我们需要将输入传递到输出，但不想等到复制完成。所以我们使用 go func 和 闭包，然后有一个 for 循环，它读取输入值并写入输出，Go 中的 for range 子句将耗尽 channel。它一直运行直到 channel 为空，然后退出。所以这一小段代码会自动耗尽 channel。因为在后台运行，所以你不需要等待它。这是一个小小的范例，但你知道它还不错，而且已经习惯了。</p><h4 id="A-simple-load-balancer"><a href="#A-simple-load-balancer" class="headerlink" title="A simple load balancer"></a>A simple load balancer</h4><p><img src="/images/concurrency-is-not-parallelism/3A5AF902-C3FB-4985-B416-67BABA8D15F1.png" alt=""><br>现在让我向您展示一个非常简单的 <code>Load Balancer</code>。如果有时间的话，我会给你看另一个例子。这个例子很简单，想象一下你有一大堆工作要完成。我们将它们抽象出来，将它们具体化为一个包含三个整数值的 <code>Work</code> 结构体，您需要对其执行一些操作。</p><p><img src="/images/concurrency-is-not-parallelism/71E08B08-D525-4B69-9014-EE148E8D1FC3.png" alt=""><br><code>worker</code> 要做的是根据这些值执行一些计算。然后我在此处加入 <code>Sleep</code>，以保证我们考虑阻塞。因为 <code>worker</code> 可能会被阻塞的一定的时间。我们构造它的方式是让 <code>worker</code> 从 input channel 读取要做的工作，并通过 output channel 传递结果，它们是这个函数的参数。在循环中，遍历输入值，执行计算，sleep 一段任意长的时间，然后将响应传递给输出，传递给等待的任务，所以我们得操心阻塞。那一定很难，对吧，以下就是全部的解决方案。</p><p><img src="/images/concurrency-is-not-parallelism/FC1A9044-A2B3-4407-961A-45F7FAEF062F.png" alt=""><br>之所以如此简单，是因为channel 以及它与语言的其他元素一起工作的方式，让您能够表达并发的东西，并很好地组合它们。做法是创建两个 channel， input channel 和 output channel，连接到 <code>worker</code>。 所有 <code>worker</code> 从 input channel 读取，然后传输到 output channel；然后启动任意数量的 <code>worker</code>。注意中间的 go 子句，所有 <code>worker</code> 都在并发运行，也许是并行运行；然后你开始另一项工作，如屏幕显示为这些 <code>worker</code> 创造大量的工作，然后在函数调用中挂起，接收大量的结果，即从 ouput channel 中按照结果完成的顺序读取其值。因为作业结构化的方式，不管是在一个处理器上运行还是在一千个处理器上运行，都会正确而完整地运行。任何人使用该资源都可以同样完成，系统已经为你做好了一切。如果你思考这个问题，它很微不足道。但实际上，在大多数语言中，如果没有并发性，很难简洁地编写。并发性使得做这种事情，可以非常紧凑。</p><p><img src="/images/concurrency-is-not-parallelism/B77B1881-167C-48E2-ACC2-EC139D5C9351.png" alt=""><br>更重要的是，它是隐式并行性的（尽管不是，如果你不想，可以不必考虑该问题），它也能很好地扩展。没有同步或不同步。<code>worker</code> 数量可能是一个巨大的数字，而且它仍然可以高效地工作，因此并发工具使得为较大问题构建此类解决方案变得很容易。</p><p><img src="/images/concurrency-is-not-parallelism/C6C11FC2-52F1-4FD4-8398-213CBE16B4F7.png" alt=""><br>还要注意，没有锁了，没有互斥锁了，所有这些都是在考虑旧的并发模型时需要考虑的，新模型没有了，你看不到它们的存在。然而，一个正确的无锁的并发、并行算法，一定很好，对吧？</p><p><img src="/images/concurrency-is-not-parallelism/3E039CA6-0811-43CD-8810-EECBFFDBFEA7.png" alt=""><br>但这太容易了，我们有时间看一个更难的。</p><h4 id="Load-balancer"><a href="#Load-balancer" class="headerlink" title="Load balancer"></a>Load balancer</h4><p><img src="/images/concurrency-is-not-parallelism/FF2107A6-2CC9-484A-969D-1E3617BE6D3B.png" alt=""><br>此例子有点棘手，相同的基本概念，但做的事情更符合现实。假设我们要写一个 <code>Loader Balancer</code>，有一堆 <code>Requester</code> 生成实际的工作，有一堆工作任务。希望将所有这些 <code>Requester</code> 的工作负载分配给任意数量的 <code>Worker</code>，并使其达到某种负载平衡，所以工作会分配给负荷最少的<code>Worker</code>。 所以你可以认为 <code>Worker</code> 们一次可能有大量的工作要做。他们可能同时要做的不止一个，可能有很多。因为有很多请求在处理，所以这会是一个很忙碌的系统。正如我演示的一样，它们也许是在同一台机器上。您也可以想象，其中一些线代表了正在进行适当负载均衡的网络连接，从结构上讲，我们的设计仍然是安全的。</p><p><img src="/images/concurrency-is-not-parallelism/67B02F3A-722F-45D5-8F00-03A490D582BD.png" alt=""><br><code>Request</code> 现在看起来很不一样了。有一个任意数量函数的闭包，表示我们要做的计算；有一个 channel 可以返回结果。请注意，不像其他一些类似 Erlang 的语言，在 Go 中 channel 是 <code>Reuqest</code> 的一部分，channel 的概念就在那里，它是语言中 <code>first-class</code> 的东西，使得可以到处传递 channel。它在某种意义上类似于文件描述符，持有 channel 的对象就可以和其他对象通信，但没有 channel 的对象是做不到的。就好像打电话给别人，或者通过文件描述符传递文件一样，是一个相当有影响的概念。想法是，要发送一个需要计算的请求，它包含一个计算完成返回结果的 channel。</p><p><img src="/images/concurrency-is-not-parallelism/1F452F0A-0A0C-47B2-811C-24556D5D107A.png" alt=""><br>以下是一个虚构但能起到说明作用的版本的 <code>Requester</code>。所做的是，有一个请求可以进入的 channel，在这个 <code>work channel</code> 上生成要做的要做的任务；创建了一个 channel，并放入每个请求的内部，以便返回给我们答案。做了一些工作，使用 <code>Sleep</code> 代表（谁知道实际上在做什么）。你在 <code>work channel</code> 上发送一个带有用于计算的函数的请求对象，不管是什么，我不在乎；还有一个把答案发回去的 channel；然后你在那个 channel 等待结果返回。一旦你得到结果，你可能得对结果做些什么。这段代码只是按照一定速度生成工作。它只是产生结果，但是通过使用 input 和 output channel 通信来实现的。</p><p><img src="/images/concurrency-is-not-parallelism/1F23ED56-4E01-4ABE-8998-B8B6B2620F0C.png" alt=""><br>然后是 <code>Worker</code>，在前面的页面，记得么？有一些 <code>Requester</code>，右边的是<code>Worker</code>，它被提供给 balancer，是我最后要给你看的。<code>Worker</code> 拥有一个接收请求的 channel；一个等待任务的计数，<code>Worker</code> 拥有任务的数量代表其负载，它注定很忙；然后是一个 index，是堆结构的一部分，我们马上展示给你看。<code>Worker</code> 所做的就是从它的 <code>Requester</code> 那里接收工作。<code>Request</code> channel 是 <code>Worker</code> 对象的一部分。</p><p><img src="/images/concurrency-is-not-parallelism/3A18168E-B383-4CED-A796-99E3C8784A79.png" alt=""><br>调用 <code>Worker</code> 的函数，把请求传递给它，把从 <code>Requester</code> 生成的实际的函数通过均衡器传递给  <code>Worker</code>。<code>Worker</code> 计算答案，然后在 channel 上返回答案。请注意，与许多其他负载均衡架构不同，从  <code>Worker</code> 返回给 <code>Requester</code> 的 channel 不通过 <code>Loader Balancer</code>。一旦 <code>Requester</code> 和 <code>Worker</code> 建立连接，图中的“中介”就会消失，请求上的工作直接进行通信。因为在系统运行时，系统内部可以来回传递 channel。如果愿意，也可以在里面放一个 <code>goroutine</code>，在这里放一个 go 语句，然后在 <code>Worker</code> 上并行地处理所有的请求。如果这样做的话，一样会工作的很好，但这已经足够了。</p><p><img src="/images/concurrency-is-not-parallelism/B8215781-BFD9-4512-B40A-2ABB67B82675.png" alt=""><br><code>Balancer</code> 有点神奇，你需要一个 <code>Worker</code> 的 <code>pool</code>； 需要一些 <code>Balancer</code> 对象，以绑定一些方法到 <code>Balancer</code>。<code>Balancer</code> 包含一个 <code>pool</code>；一个 <code>done channel</code>，用以让  <code>Worker</code> 告诉  <code>Loader Balancer</code> 它已经完成了最近的计算。</p><p><img src="/images/concurrency-is-not-parallelism/EA2A6D83-4160-4367-8CB4-FD3FD9D0447A.png" alt=""><br>所以 <code>balance</code> 很简单，它所做的只是永远执行一个 <code>select</code> 语句，等待做更多来自 <code>Requester</code> 的工作。在这种情况下，它会分发请求给负载最轻的 <code>Worker</code>；或者 <code>Worker</code> 告知，它已经完成计算，在这种情况下，可以通过更新数据结构表明 <code>Worker</code> 完成了它的任务。所以这只是一个简单的两路 <code>select</code>。然后，我们需要增加这两个函数，而要做到这一点，实际上要做的就是构造一个堆。</p><p><img src="/images/concurrency-is-not-parallelism/C20CFC3C-72AB-43A9-A102-B6C6438D736C.png" alt=""><br>我跳过这些令人很兴奋的片段，你们已经知道什么意思。</p><p><img src="/images/concurrency-is-not-parallelism/A17A867D-76BE-4B60-B158-2B77CA7406A4.png" alt=""><br><code>Dispatch</code>, <code>dispatch</code> 要做的就是找到负载最少的 <code>Worker</code>，它是基于堆实现的一个标准优先级队列。所以你把负载最少的 <code>Worker</code> 从堆里取出来，通过将请求写入 request channel 来发送任务。因为增加了一个任务，需要增加负载，这会影响负载分布。然后你把它放回堆的同一个地方，就这样。你刚刚调度了它，并且在结构上进行了更新，这就是可执行代码行的内容。</p><p><img src="/images/concurrency-is-not-parallelism/2CD0909F-3050-4154-9233-D0823A98CD99.png" alt=""><br>然后是 <code>complete</code> 的任务，也就是工作完成后，必须做一些相反的事情。 <code>Worker</code> 的队列中减少了一个任务，所以减少了它的等待计数。从堆里弹出 <code>Worker</code>，然后把它放回堆中，优先级队列会把它放回中它所属的位置，这是一个半现实的 <code>Loader Balancer</code> 的完整实现。此处的关键点是数据结构使用的是 channel 和 goroutine 来构造并发的东西。</p><h4 id="Lesson-1"><a href="#Lesson-1" class="headerlink" title="Lesson"></a>Lesson</h4><p><img src="/images/concurrency-is-not-parallelism/0A7657F5-CDCA-41C7-B39A-08FB257670C5.png" alt=""><br>结果是可伸缩的，是正确的，很简单，没有显式的锁，而架构让它得以实现。因此，并发性使此例子的内在并行性成为可能。你可以运行这个程序，我有这个程序，它是可编译、可运行的，而且工作正常，负载均衡也做得很好。物体保持在均匀的负载下，按照模块量化，很不错。我从来没说过有多少 <code>Worker</code>，有多少问题。可能每个都有一个，另一个有数10个；或者每个都有一千，或者每个都有一百万，扩缩容仍然有效，并且仍然高效。</p><h4 id="One-more-example"><a href="#One-more-example" class="headerlink" title="One more example"></a>One more example</h4><p><img src="/images/concurrency-is-not-parallelism/77A4B1D5-95A2-40E7-8D13-F6862E6E0285.png" alt=""><br>再举一个例子，这个例子有点令人惊讶，但它适合一张幻灯片就可以完成。</p><p><img src="/images/concurrency-is-not-parallelism/19E4D7F9-D39C-4CBF-A8ED-B3444351AF58.png" alt=""><br>想象一下如何复制数据库，你得到了几个数据库，每个数据库中有相同的数据，谷歌称之为分片，称呼相同的实例。您要做的是向所有数据库传递一个请求，一个查询，并返回结果。结果会是一样的，你选择第一个应答请求来加快速度，因为首先要回来的是你想要的答案。如果其中一个坏了，断开了或者什么的，你不在乎。因为会有其他响应回来，这就是如何做到这一点。这就是它的全部实现。您有一些连接数组和一些要执行的查询，您创建一个 channel，该 channel 缓冲查询数据库中的元素数、副本内的副本数大小的内容，然后您只需在数据库的所有连接上执行。对于其中的每一个，您启动一个 goroutine 以将查询传递到该数据库，然后获取答案。但是通过这个 DoQuery 调用，将答案传递到唯一的 channel，这个 channel 保存所有请求的结果。然后，在你执行之后，所有的 goroutine 都只需在底部这行等待。我们等待第一个回到 channel 的请求，就是你想要的答案。返回它，就完成了。这看起来像个玩具，而且有点像。但这实际上是一个完全正确的实现，唯一缺少的是干净的回收。你想告诉那些还没回来的服务器关闭。当你已经得到答案，不再需要它们。你可以做，增加更多且合理的代码，但那就不适合放在幻灯片上了。所以我只想告诉你，在很多系统中，这是一个相当复杂的问题，但在这里，它只是自然地脱离了架构。因为你已经有了并发工具来表示一个相当大的复杂的分布式问题，它运行得非常好。</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p><img src="/images/concurrency-is-not-parallelism/758B1387-AEFE-4250-8442-9DDD1A725127.png" alt=""><br>还剩五秒钟，很好。结论：并发性是强大的，但它不是并行性的，但它支持并行性，而且它使并行性变得容易。如果你明白了，那我就完成了我的工作。</p><h3 id="For-more-information"><a href="#For-more-information" class="headerlink" title="For more information"></a>For more information</h3><p><img src="/images/concurrency-is-not-parallelism/C4DE1ADD-6DF7-4C0D-B96F-409F4BB5DD9B.png" alt=""><br>如果你想看更多，这里有很多链接。<code>golang.org</code> 有关于 GO 你想知道的一切。有一份很好的历史 paper，链接如上。几年前我做了一个演讲，让我们真正开始开发Go语言，你可能会觉得很有趣。CMU 的 Bob Harper 有一篇非常不错的博客文章，叫做“并行不是并发”，这与“并发不是并行”的观点非常相似，虽然不完全一样。还有一些其他的东西，最令人惊讶的是，道格·马图尔（Doug Mathur）,我在贝尔实验室（Bell Labs）的老板，所做的并行幂级数的工作，这是一篇了不起的论文。但如果你想与众不同的话。幻灯片上的最后一个链接是到另一种语言 sawzall，我从贝尔实验室（Bell Labs）来到谷歌后不久做的，这很了不起，因为它是不可思议的并行的语言，但它绝对没有并发性。现在我想你可能明白了这是可能的，所以非常感谢你的倾听和感谢 Hiroko 给我写信。我想是时候喝点什么了。</p><p><em>视频：<a href="https://vimeo.com/49718712" target="_blank" rel="noopener">https://vimeo.com/49718712</a></em><br><em>Slide：<a href="https://talks.golang.org/2012/waza.slide#1" target="_blank" rel="noopener">https://talks.golang.org/2012/waza.slide#1</a></em><br><em>源代码：<a href="https://github.com/golang/talks/tree/master/content/2012/waza" target="_blank" rel="noopener">https://github.com/golang/talks/tree/master/content/2012/waza</a></em>       </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Concurrency-vs-Parallelism&quot;&gt;&lt;a href=&quot;#Concurrency-vs-Parallelism&quot; class=&quot;headerlink&quot; title=&quot;Concurrency vs Parallelism&quot;&gt;&lt;/a&gt;Concurre
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Concurrency" scheme="https://www.cyningsun.com/tag/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>译 | Share Memory By Communicating</title>
    <link href="https://www.cyningsun.com/09-29-2019/share-memory-by-communicating-cn.html"/>
    <id>https://www.cyningsun.com/09-29-2019/share-memory-by-communicating-cn.html</id>
    <published>2019-09-28T16:00:00.000Z</published>
    <updated>2020-02-03T06:53:29.645Z</updated>
    
    <content type="html"><![CDATA[<p>传统的线程模型（例如，通常在编写Java，C++ 和 Python 程序时使用）要求程序员使用共享内存在线程之间进行通信。通常，共享数据结构受锁保护，线程争夺这些锁以访问数据。在某些情况下，通过使用线程安全的数据结构可以使操作变得更容易，例如 Python 的 Queue。</p><p>Go的并发原语 — goroutine 和 chan nel— 提供了一种优雅而独特的方式来构造并发软件（ 这些概念有一个<a href="https://swtch.com/~rsc/thread/" target="_blank" rel="noopener">有趣的历史</a>，始于 C. A. R. Hoare 的 <a href="http://www.usingcsp.com/" target="_blank" rel="noopener">Communicating Sequential Processes</a> ）。Go 并未显式地使用锁来达成对共享数据的访问，而是鼓励使用 channel 在goroutine 之间传递对数据的引用。该方法可确保在给定时间只有一个 goroutine 可以访问数据。该概念在<a href="https://golang.org/doc/effective_go.html" target="_blank" rel="noopener">Effective Go</a>（Go程序员必读）中进行了总结：</p><blockquote><p>Do not communicate by sharing memory; instead, share memory by communicating.<br>不要通过共享内存进行通信；而是通过通信共享内存。</p></blockquote><p>考虑一个轮询 URL 列表的程序。在传统的线程环境中，人们可能会如下构造其数据：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Resource <span class="hljs-keyword">struct</span> &#123;    url        <span class="hljs-keyword">string</span>    polling    <span class="hljs-keyword">bool</span>    lastPolled <span class="hljs-keyword">int64</span>&#125;<span class="hljs-keyword">type</span> Resources <span class="hljs-keyword">struct</span> &#123;    data []*Resource    lock *sync.Mutex&#125;</code></pre><p>然后，Poller 函数（许多类似的函数会运行在单独的线程中）如下：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Poller</span><span class="hljs-params">(res *Resources)</span></span> &#123;    <span class="hljs-keyword">for</span> &#123;        <span class="hljs-comment">// get the least recently-polled Resource</span>        <span class="hljs-comment">// and mark it as being polled</span>        res.lock.Lock()        <span class="hljs-keyword">var</span> r *Resource        <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> res.data &#123;            <span class="hljs-keyword">if</span> v.polling &#123;                <span class="hljs-keyword">continue</span>            &#125;            <span class="hljs-keyword">if</span> r == <span class="hljs-literal">nil</span> || v.lastPolled &lt; r.lastPolled &#123;                r = v            &#125;        &#125;        <span class="hljs-keyword">if</span> r != <span class="hljs-literal">nil</span> &#123;            r.polling = <span class="hljs-literal">true</span>        &#125;        res.lock.Unlock()        <span class="hljs-keyword">if</span> r == <span class="hljs-literal">nil</span> &#123;            <span class="hljs-keyword">continue</span>        &#125;        <span class="hljs-comment">// poll the URL</span>        <span class="hljs-comment">// update the Resource's polling and lastPolled</span>        res.lock.Lock()        r.polling = <span class="hljs-literal">false</span>        r.lastPolled = time.Nanoseconds()        res.lock.Unlock()    &#125;&#125;</code></pre><p>此功能大约一页纸长，并且需要更多细节才能完成。它甚至不包括 URL 轮询逻辑（它本身只有几行），也不能优雅地应对资源池耗尽。</p><p>让我们看一下使用 Go 风格实现的相同功能。在此示例中，Poller 函数从输入 channel 接收要轮询的资源，并在完成后将其发送到输出 channel。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Resource <span class="hljs-keyword">string</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Poller</span><span class="hljs-params">(in, out <span class="hljs-keyword">chan</span> *Resource)</span></span> &#123;    <span class="hljs-keyword">for</span> r := <span class="hljs-keyword">range</span> in &#123;        <span class="hljs-comment">// poll the URL</span>        <span class="hljs-comment">// send the processed Resource to out</span>        out &lt;- r    &#125;&#125;</code></pre><p>前一个例子中的微妙逻辑显然没有了，并且 Resource 数据结构不再包含记账数据。实际上，剩下的都是重要的部分。以上应该使您对这些简单的语言功能的威力有所了解。</p><p>上面的代码片段有很多遗漏之处。如需走读使用以上想法的，完整的、惯用的 Go 程序，请参阅 Codewalk <a href="https://golang.org/doc/codewalk/sharemem/" target="_blank" rel="noopener">Share Memory By Communicating</a>。</p><p><em>原文：<a href="https://blog.golang.org/share-memory-by-communicating" target="_blank" rel="noopener">https://blog.golang.org/share-memory-by-communicating</a></em><br><em>源代码：<a href="https://github.com/cyningsun/go-test" target="_blank" rel="noopener">https://github.com/cyningsun/go-test</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;传统的线程模型（例如，通常在编写Java，C++ 和 Python 程序时使用）要求程序员使用共享内存在线程之间进行通信。通常，共享数据结构受锁保护，线程争夺这些锁以访问数据。在某些情况下，通过使用线程安全的数据结构可以使操作变得更容易，例如 Python 的 Queue。
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Concurrency" scheme="https://www.cyningsun.com/tag/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>译｜Let’s talk about logging</title>
    <link href="https://www.cyningsun.com/09-27-2019/lets-talk-about-logging-cn.html"/>
    <id>https://www.cyningsun.com/09-27-2019/lets-talk-about-logging-cn.html</id>
    <published>2019-09-26T16:00:00.000Z</published>
    <updated>2020-02-03T06:53:29.644Z</updated>
    
    <content type="html"><![CDATA[<p>本文受 <a href="https://forum.golangbridge.org/t/whats-so-bad-about-the-stdlibs-log-package/1435/" target="_blank" rel="noopener">Nate Finch started on the Go Forum</a> 的一个话题启发。本文专注于 Go，但是如果你能看透，我认为这里提出的想法是广泛适用的。</p><h3 id="Why-no-love"><a href="#Why-no-love" class="headerlink" title="Why no love ?"></a>Why no love ?</h3><p>Go 的 <a href="https://golang.org/pkg/log/" target="_blank" rel="noopener">log package</a> 没有日志级别，你必须自己手动添加 debug、info、warn 和 error 等前缀。另外，Go 的 日志类型无法以包为基础打开或者关闭这些不同级别。通过比较，让我们看一些第三方的替代品：</p><p>Google 的 <a href="https://godoc.org/github.com/golang/glog" target="_blank" rel="noopener">glog</a> 提供以下级别：</p><ul><li>Info</li><li>Warning</li><li>Error</li><li>Fatal (终止程序)</li></ul><p>看看另外一个库， 我们为 Juju 开发的 <a href="https://godoc.org/github.com/juju/loggo" target="_blank" rel="noopener">loggo</a>，提供以下级别：</p><ul><li>Trace</li><li>Debug</li><li>Info</li><li>Warning</li><li>Error</li><li>Critical</li></ul><p>Loggo 还提供了根据每个包调整日志的详细程度的功能。</p><p>因此，以上两个示例显然受到其他语言的其他日志库的影响。实际上，它们的命令行可以追溯到 syslog(3)，甚至更早。我认为他们是错的。</p><p>我站相反的立场。我认为_所有_日志库都不好，因为它提供了_太多_的功能。一系列令人困惑的选择，使程序员必须清楚地思考如何与未来的读者沟通，而读者将要使用他们的日志。</p><p>我认为成功的日志包需要的功能要少得多，当然需要的级别也更少。</p><h3 id="Let’s-talk-about-warnings"><a href="#Let’s-talk-about-warnings" class="headerlink" title="Let’s talk about warnings"></a>Let’s talk about warnings</h3><p>我们从最简单的一个开始。没有人需要 warning 的日志级别。</p><p>没有人阅读 warning，因为按照定义，没有出错。也许将来会出问题，但这听起来像是别人的问题。</p><p>此外，如果你在使用某种分级日志，那么为什么将级别设置为 warning? 你可以将级别设置为 info 或 error。将级别设置为 warning 是承认你可能正在以 warninng 级别打印错误日志</p><p>消除 warning 级别，因为它既可能是信息性的消息，也可能是错误的情况。（潜台词：语义不明确）</p><h3 id="Let’s-talk-about-fatal"><a href="#Let’s-talk-about-fatal" class="headerlink" title="Let’s talk about fatal"></a>Let’s talk about fatal</h3><p>Fatal 级别，有效打印消息日志，然后调用 <code>os.Exit(1)</code>。原则上，这意味着：</p><ul><li>其他goroutines中的defer语句不会运行。</li><li>缓冲区不刷新。</li><li>临时文件和目录不会被删除。</li></ul><p>实际上，<code>log.Fatal</code> 的详细程度要比 <code>panic</code> 少，但在语义上却等同于它。</p><p>普遍认为，库不应该使用 panic<sup>1</sup>，但是如果调用 log.Fatal<sup>2</sup> 具有相同的效果，那么当然也应该将其定为非法。</p><p>解决此清理问题的建议是，可以通过在日志系统中注册 shutdown handler，但如此导致日志系统与发生清理操作的每个位置之间紧密耦合。它也违反了关注点分离。</p><p>不要以 <code>Fatal</code> 级别写日志，而要将错误返回给调用方。如果错误一直冒泡到 <code>main.main</code>, 那么退出之前，是处理所有清理操作的正确位置。</p><h3 id="Let’s-talk-about-error"><a href="#Let’s-talk-about-error" class="headerlink" title="Let’s talk about error"></a>Let’s talk about error</h3><p>错误处理和日志密切相关，因此从表面上看，以 error 级别进行日志打印应该很容易解释。但，我不同意。</p><p>在 Go 中，如果函数或方法调用返回错误值，实际上您有两个选择：</p><ul><li>处理错误</li><li>将错误返回给您的呼叫者（您可以选择包装错误，但这对于本次讨论并不重要）</li></ul><p>如果您选择通过打印日志来处理错误，那么按照定义，你已经处理了它，错误就不存在了。打印错误处理错误的行为，意味着不再适合将其打印为错误日志。</p><p>让我尝试用以下代码片段说服您：</p><pre><code class="hljs go">err := somethingHard()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;        log.Error(<span class="hljs-string">"oops, something was too hard"</span>, err)        <span class="hljs-keyword">return</span> err <span class="hljs-comment">// what is this, Java ?</span>&#125;</code></pre><p>您永远不应该在 error 级别打印任何内容的日志，因为您应该处理错误，或者将其传递回调用方。</p><p>准确地说，我并不是说您不应该将发生的情况打印日志</p><pre><code class="hljs code">if err :&#x3D; planA(); err !&#x3D; nil &#123;        log.Infof(&quot;could&#39;t open the foo file, continuing with plan b: %v&quot;, err)        planB()&#125;</code></pre><p>但实际上 <code>log.Info</code> 和 <code>log.Error</code> 有异曲同工之妙。</p><p>我并不是说不要打印错误日志！相反，问题是，最小的日志API是什么？当提到错误时，我相信绝大多数打印日志为 error 级别的项目，都是通过这种简单地方式完成的，因为它们与错误相关。实际上，它们只是提供信息，意味着可以从API中删除以 error 级别打印日志。</p><h3 id="What’s-left"><a href="#What’s-left" class="headerlink" title="What’s left ?"></a>What’s left ?</h3><p>我们已经排除了 warning，认为不应该以 error 级别打印任何内容的日志，并且表明只有应用程序的顶层应该具有某种 <code>log.Fatal</code> 行为。还剩什么 ？</p><p>我认为只有两种东西您应该打印日志：</p><ol><li>开发人员在开发或调试软件时会关心的东西。</li><li>用户在使用您的软件时关心的东西。</li></ol><p>显然，分别是 debug 和 info 级别。</p><p><code>log.Info</code> 应该简单地将该行写入日志输出。不应有将其关闭的选项，因为仅应告知用户对他们有用的事情。如果发生<em>无法_处理的错误，它将冒泡到 <code>main.main</code>， 程序终止的地方。必须在最后一条日志消息前面插入 _FATAL</em> 前缀，或直接用 <code>fmt.Fprintf</code> 写入 <code>os.Stderr</code> 所带来的小小不便，不足以解释日志包需要添加 <code>log.Fatal</code> 方法。</p><p><code>log.Debug</code>，则完全不同。由开发人员或支持工程师控制。在开发过程中，调试语句应足够多，而不必求助于 trace 或 debug<sup>2</sup> 级别。日志包应支持细粒度的控制，以启用或禁用调试，并且仅在该包或可能更精细的范围内的语句调试。</p><h3 id="Wrapping-up"><a href="#Wrapping-up" class="headerlink" title="Wrapping up"></a>Wrapping up</h3><p>如果这是推特民意调查，请您选择</p><ul><li>打印日志很重要</li><li>打印日志很难</li></ul><p>但是事实是，打印日志是两者兼而有之。解决这个问题的方法_必须_是解构和残酷地消除不必要的干扰。</p><p>你怎么看？这仅仅是疯狂到足以工作，还是纯粹是疯狂的？</p><h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h3><ol><li>一些库可能使用 <code>panic</code>/<code>recover</code> 作为内部控制流机制，但最重要的原则是它们一定不能让这些控制流操作泄漏到程序包边界之外。</li><li>具有讽刺意味的是，尽管缺少 debug 级别的输出，但 Go 标准日志包同时具有 <code>Fatal</code> 和 <code>Panic</code> 功能。在此程序包中，导致程序突然退出的功能数量超过了没有退出功能的数量。</li></ol><p><em>原文：<a href="https://dave.cheney.net/2015/11/05/lets-talk-about-logging" target="_blank" rel="noopener">https://dave.cheney.net/2015/11/05/lets-talk-about-logging</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文受 &lt;a href=&quot;https://forum.golangbridge.org/t/whats-so-bad-about-the-stdlibs-log-package/1435/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nate Finch
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Logging" scheme="https://www.cyningsun.com/tag/Logging/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus Client定制</title>
    <link href="https://www.cyningsun.com/09-15-2019/micro-service-monitor-prometheus-client.html"/>
    <id>https://www.cyningsun.com/09-15-2019/micro-service-monitor-prometheus-client.html</id>
    <published>2019-09-14T16:00:00.000Z</published>
    <updated>2020-02-03T06:53:29.644Z</updated>
    
    <content type="html"><![CDATA[<p>Prometheus提供的Client无法直接使用到生产环境，需要根据需求进行定制，以下为Client中的主要概念。<br><img src="/images/micro-service-monitor/prometheus-client.png" alt=""></p><ul><li>Desc：该结构是图中最关键的结构体，需要详细说明。<blockquote><ul><li>fqName：由Namespace、Subsystem和metric的Name组成。相同fqName的监控指标在整个系统中需要保证唯一(dimhash, label dimensions hash)，包括：type、labels(顺序无关)、help。</li><li>labels：包含该metric的label列表</li></ul></blockquote></li><li>Metric：Desc相同，但label值不同的指标定义为Metric，即LabelPair列表+Desc确定一个Metric，每个Metric都有其type（counter、gauge、summary、histogram）和vaule</li><li>MetricVec：相同fqName的Metric会存放在同一个MetricVec</li><li>Collector：任何可以被收集监控指标的接口（MetricVec、Metric均实现了该接口）；通常在使用时类似Package，自定义的Collector将多个相关的MetricVec打包，以供收集，例如：goCollector、processCollector。</li><li>Registry：实现了Gatherer(数据收集)和Registerer（指标注册）接口，并提供了以上功能。</li></ul><p>在生产环境使用的之前需要考虑以下问题：</p><ul><li>如何分配和包装好fqName，fqName至关重要，将会影响整套监控系统的维护难度。</li><li>如何定义框架指标和业务指标接口</li><li>是否为指标添加固定的label，如：服务名、环境、IDC等</li><li>Client不会自动剔除不再使用的Metric(除非服务重启)，是否需要提供Metric <a href="https://github.com/armon/go-metrics/blob/master/prometheus/prometheus.go" target="_blank" rel="noopener">Sink</a>的功能</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Prometheus提供的Client无法直接使用到生产环境，需要根据需求进行定制，以下为Client中的主要概念。&lt;br&gt;&lt;img src=&quot;/images/micro-service-monitor/prometheus-client.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Prometheus" scheme="https://www.cyningsun.com/category/Prometheus/"/>
    
    
      <category term="Client" scheme="https://www.cyningsun.com/tag/Client/"/>
    
  </entry>
  
  <entry>
    <title>高可用Prometheus集群</title>
    <link href="https://www.cyningsun.com/09-13-2019/micro-service-monitor-prometheus-ha.html"/>
    <id>https://www.cyningsun.com/09-13-2019/micro-service-monitor-prometheus-ha.html</id>
    <published>2019-09-12T16:00:00.000Z</published>
    <updated>2020-02-03T06:53:29.643Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>一个应用于生产环境的监控服务，单机Promtheus往往是无法满足需求的，此时就要搭建一套Prometheus集群，此时就需要考虑：<br>服务高可用：服务要冗余备份，以消除单点故障。<br>数据一致性：冗余结点之间数据需要保证一致性。<br>水平可扩展：可以通过增加服务数量，线性提高服务能力。<br>数据持久化：节点故障数据不丢失、海量历史数据存储</p><h3 id="服务高可用"><a href="#服务高可用" class="headerlink" title="服务高可用"></a>服务高可用</h3><p>Prometheus采用Pull模型收集监控数据，服务高可用意味着同一个服务需要至少两个节点同时拉取<br><img src="/images/micro-service-monitor/1-prometheus-replica.png" alt=""></p><p>或者切换为Push模型，使用一致性哈希，将不同实例的Metrics推送到固定推送到其中一台服务<br><img src="/images/micro-service-monitor/2-prometheus-push.png" alt=""></p><p>此模式优势是，在保障服务可用性的同时，资源消耗量少一半；新节点不需要重新配置抓取规则，可以做到快速平行扩容。但缺点是，节点故障将导致历史数据丢失。</p><h3 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h3><p>Pull模式下，冗余节点存在以下两个问题：<br>两个数据源（Prometheus）的metrics是重复的<br>两个数据源的同样的metrics有细微差异（两次抓取）</p><p>解决这些问题有两种方案：<br>方案一：使用HA Proxy保证同时只有一个数据数据源提供服务，另外一个节点作为备份，当检测故障时接管主节点提供服务。<br><img src="/images/micro-service-monitor/3-promtheus-ha.png" alt=""></p><p>方案二：使用Thanos来接管Prometheus提供服务，将Thanos Sidecar与Prometheus同机部署，Thanos Query可以调用Sidecar获取metrics，并且进行去重。此时 Thanos Query代替Prometheus对外提供Http API接口<br><img src="/images/micro-service-monitor/4-thanos.png" alt=""></p><p>相反，Push模式下，所有节点都可以提供服务，数据没有重复，所以不存在数据一致性的问题。</p><h3 id="水平可扩展"><a href="#水平可扩展" class="headerlink" title="水平可扩展"></a>水平可扩展</h3><p>Prometheus解决水平扩展的方式是：Sharding。当单台Promthues Server无法处理大量的采集任务时，用户可以考虑基于Prometheus联邦集群的方式将监控采集任务划分到不同的Promthues实例。<br><img src="/images/micro-service-monitor/5-scale-out.png" alt=""></p><p>可以根据场景选择根据Sharding的方式<br>按照功能分区：例如一个Promthues Server负责采集基础设施相关的监控指标，另外一个Prometheus Server负责采集应用监控指标<br>按照实例分区：当单个采集任务的Target数也变得非常巨大。简单通过联邦集群进行功能分区，Prometheus也无法有效处理时。需要考虑继续在实例级别进行功能划分</p><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>Prometheus的本地存储设计可以减少其自身运维和管理的复杂度，同时能够满足大部分用户监控规模的需求。但是本地存储也意味着Prometheus无法持久化数据，无法存储大量历史数据。Prometheus并没有尝试在自身中解决以上问题，而是让用户可以通过接口将数据保存到任意第三方的分布式存储中，即：Remote Storage。<br><img src="/images/micro-service-monitor/5.1-remote-storage.png" alt=""></p><p>一旦开始查询历史数据，我们很快便意识到，在我们检索几周，几个月，乃至最终数年的数据时，这里存在的大O复杂度会让查询变得越来越慢。Prometheus暂时并未提供完整的方案来解决该问题，此时需要依靠Thanos解决方案的 <code>Downsampling</code>了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综上所述，根据不同的业务场景，选择合适的高可用部署方案，并根据自身需求进行灵活调整。下面列出来的是三套完整的高可用的方案：<br><img src="/images/micro-service-monitor/6-prometheus-pull.png" alt=""></p><p><img src="/images/micro-service-monitor/7-thanos-pull.png" alt=""></p><p><img src="/images/micro-service-monitor/8-thanos-push.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;一个应用于生产环境的监控服务，单机Promtheus往往是无法满足需求的，此时就要搭建一套Prometheus集群，此时就需要考虑：&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Prometheus" scheme="https://www.cyningsun.com/category/Prometheus/"/>
    
    
      <category term="HA" scheme="https://www.cyningsun.com/tag/HA/"/>
    
  </entry>
  
  <entry>
    <title>译｜Don’t just check errors, handle them gracefully</title>
    <link href="https://www.cyningsun.com/09-09-2019/dont-just-check-errors-handle-them-gracefully-cn.html"/>
    <id>https://www.cyningsun.com/09-09-2019/dont-just-check-errors-handle-them-gracefully-cn.html</id>
    <published>2019-09-08T16:00:00.000Z</published>
    <updated>2020-02-03T06:53:29.642Z</updated>
    
    <content type="html"><![CDATA[<p>本文摘自我最近在日本东京举行的<a href="http://gocon.connpass.com/event/27521/" target="_blank" rel="noopener">GoCon春季</a>会议上的演讲。</p><p><img src="http://dave.cheney.net/wp-content/uploads/2016/04/Screen-Shot-2016-04-23-at-11.39.26.png" alt="Don&#39;t just check errors, handle them gracefully"></p><h4 id="Errors-are-just-values"><a href="#Errors-are-just-values" class="headerlink" title="Errors are just values"></a>Errors are just values</h4><p>我花了很多时间考虑Go程序中错误处理的最佳方法。我真希望存在单一的错误处理方式，可以通过死记硬背教给所有Go程序员，就像教数学或英文字母表一样。</p><p>但是，我得出结论，不存在单一的错误处理方式。 相反，我认为Go的错误处理可以分为三个核心策略。</p><h4 id="Sentinel-errors"><a href="#Sentinel-errors" class="headerlink" title="Sentinel errors"></a>Sentinel errors</h4><p>第一类错误处理就是我所说的_sentinel errors_。</p><pre><code class="hljs go"><span class="hljs-keyword">if</span> err == ErrSomething &#123; … &#125;</code></pre><p>该名称源于计算机编程中使用特定值的实践，表示不可能进一步处理。 因此，对于Go，我们使用特定值来表示错误。</p><p>例子包括 <code>io.EOF</code> 类的值，或低层级的错误，如 <code>syscall</code> 包中的常 <code>syscall.ENOENT</code>。</p><p>甚至还有 <code>sentinel errors</code> 表示_没有_发生错误，比如 <code>go/build.NoGoError</code> , 和 <code>path/filepath.Walk</code> 的 <code>path/filepath.SkipDir</code>。</p><p>使用 <code>sentinel</code> 值是灵活性最小的错误处理策略，因为调用者必须使用等于运算符，将结果与预先声明的值进行比较。 当您想要提供更多上下文时就会出现问题，因为返回一个不同的错误会破坏相等检查。</p><p>即使是用心良苦的使用 <code>fmt.Errorf</code> 为错误添加一些上下文，将使调用者的相等测试失败。 调用者转而被迫查看  <code>error</code>的 <code>Error</code> 方法的输出，以查看它是否与特定字符串匹配。</p><h5 id="Never-inspect-the-output-of-error-Error"><a href="#Never-inspect-the-output-of-error-Error" class="headerlink" title="Never inspect the output of error.Error"></a>Never inspect the output of error.Error</h5><p>另外，我认为永远不应该检查  <code>error.Error</code> 方法的输出。<code>error</code> 接口上的 <code>Error</code> 方法是为人类，而不是代码。</p><p>该字符串的内容属于日志文件，或显示在屏幕上。 您不应该尝试通过检查它以更改程序的行为。</p><p>我知道有时候这是不可能的，正如有人在推特上指出的那样，此建议并不适用于编写测试。 更重要的是，在我看来，比较错误的字符串形式是一种代码气味，你应该尽量避免它。</p><h5 id="Sentinel-errors-become-part-of-your-public-API"><a href="#Sentinel-errors-become-part-of-your-public-API" class="headerlink" title="Sentinel errors become part of your public API"></a>Sentinel errors become part of your public API</h5><p>如果您的 public 函数或方法返回特定值的错误，那么该值必须是 public 的，当然还要有文档记录。 这会增加API的面积。</p><p>如果您的API定义了一个返回特定错误的接口，则该接口的所有实现都将被限制为仅返回该错误，即使它们可能提供更具描述性的错误。</p><p>通过 <code>io.Reader</code> 看到这一点 。 像 <code>io.Copy</code> 这样的函数，需要一个 reader 实现来_精确_地返回 <code>io.EOF</code>，以便向调用者发出不再有数据的信号，但这不是错误 。</p><h5 id="Sentinel-errors-create-a-dependency-between-two-packages"><a href="#Sentinel-errors-create-a-dependency-between-two-packages" class="headerlink" title="Sentinel errors create a dependency between two packages"></a>Sentinel errors create a dependency between two packages</h5><p>到目前为止，<code>sentinel error values</code> 的最大问题是它们在两个包之间创建源代码依赖性。 例如，要检查错误是否等于 <code>io.EOF</code>，您的代码必 import <code>io</code> 包。</p><p>这个具体示例听起来并不那么糟糕，因为它很常见，但想象一下，当项目中的许多包导出 <code>error values</code>，项目中的其他包必须 import 以检查特定的错误条件时存在的耦合。</p><p>在一个玩弄这种模式的大型项目中工作过，我可以告诉你，以 import 循环的形式出现的糟糕设计的幽灵从未远离我们的脑海。</p><h5 id="Conclusion-avoid-sentinel-errors"><a href="#Conclusion-avoid-sentinel-errors" class="headerlink" title="Conclusion: avoid sentinel errors"></a>Conclusion: avoid sentinel errors</h5><p>所以，我的建议是在你编写的代码中避免使用 <code>sentinel error values</code>。 在某些情况下，它们会在标准库中使用，但你不应该模仿这种模式。</p><p>如果有人要求您从包中导出错误值，您应该礼貌地拒绝，而是建议一种替代方法，例如我将在下面讨论的方法。</p><h4 id="Error-types"><a href="#Error-types" class="headerlink" title="Error types"></a>Error types</h4><p><code>Error types</code> 是我想讨论的Go错误处理的第二种形式。</p><pre><code class="hljs go"><span class="hljs-keyword">if</span> err, ok := err.(SomeType); ok &#123; … &#125;</code></pre><p>错误类型是您创建的实现错误接口的类型。 在此示例中，<code>MyError</code> 类型跟踪文件和行，以及解释所发生情况的消息。</p><pre><code class="hljs go">type MyError struct &#123;Msg stringFile stringLine int&#125;func (e *MyError) Error() string &#123;return fmt.Sprintf("%s:%d: %s”, e.File, e.Line, e.Msg)&#125;return &amp;MyError&#123;"Something happened", “server.go", 42&#125;</code></pre><p>由于 <code>MyError error</code> 是一种类型，因此调用者可以使用类型断言从错误中提取额外的上下文。</p><pre><code class="hljs go">err := something()<span class="hljs-keyword">switch</span> err := err.(<span class="hljs-keyword">type</span>) &#123;<span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:<span class="hljs-comment">// call succeeded, nothing to do</span><span class="hljs-keyword">case</span> *MyError:fmt.Println(“error occurred on line:”, err.Line)<span class="hljs-keyword">default</span>:<span class="hljs-comment">// unknown error</span>&#125;</code></pre><p><code>error types</code> 相对于 <code>error values</code> 的重大改进是，它们能够包装底层错误以提供更多上下文。</p><p>一个很好的例子是 <code>os.PathError</code> 类型，它通过它试图执行的操作和它试图使用的文件来注释底层错误。</p><pre><code class="hljs go"><span class="hljs-comment">// PathError records an error and the operation</span><span class="hljs-comment">// and file path that caused it.</span><span class="hljs-keyword">type</span> PathError <span class="hljs-keyword">struct</span> &#123;Op <span class="hljs-keyword">string</span>Path <span class="hljs-keyword">string</span>Err error <span class="hljs-comment">// the cause</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *PathError)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span></code></pre><h5 id="Problems-with-error-types"><a href="#Problems-with-error-types" class="headerlink" title="Problems with error types"></a>Problems with error types</h5><p>调用者可以使用类型断言或类型 switch，<code>error types</code> 必须是 public。</p><p>如果您的代码实现了一个接口，其契约需要特定的错误类型，则该接口的所有实现者都需要依赖于定义错误类型的包。</p><p>对包类型的深入了解，会建立与调用者很强耦合，从而形成一个脆弱的API。</p><h5 id="Conclusion-avoid-error-types"><a href="#Conclusion-avoid-error-types" class="headerlink" title="Conclusion: avoid error types"></a>Conclusion: avoid error types</h5><p>虽然 <code>error types</code> 比 <code>sentinel error values</code> 更好，因为它们可以捕获更多关于错误的上下文，错误类型同样拥有许多 <code>error values</code> 的问题。</p><p>所以我的建议是避免 <code>error types</code>，或者至少避免使它们成为公共API的一部分。</p><h4 id="Opaque-errors"><a href="#Opaque-errors" class="headerlink" title="Opaque errors"></a>Opaque errors</h4><p>现在我们来看第三类错误处理。 在我看来，这是最灵活的错误处理策略，因为它需要的代码和调用者之间的耦合最小。</p><p>我将这种方式称为不透明的错误处理，因为虽然您知道发生了错误，但您无法查看错误内部。 作为调用者，您对操作结果的所有了解都是有效的，或者没有。</p><p>这就是不透明的错误处理 - 只返回错误而不假设其内容。 如果采用此方式，则错误处理可以作为调试辅助工具，变得非常有用。</p><pre><code class="hljs go"><span class="hljs-keyword">import</span> “github.com/quux/bar”<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;x, err := bar.Foo()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;<span class="hljs-comment">// use x</span>&#125;</code></pre><p>例如，<code>Foo</code> 的契约不保证它将在错误的上下文中返回什么。通过传递错误附带额外的上下文，<code>Foo</code> 的作者现在可以自由地注释错误，而不会违反与调用者的契约。</p><h5 id="Assert-errors-for-behaviour-not-type"><a href="#Assert-errors-for-behaviour-not-type" class="headerlink" title="Assert errors for behaviour, not type"></a>Assert errors for behaviour, not type</h5><p>在少数情况下，使用二分法（是否有错误）来进行错误处理是不够的。</p><p>例如，与进程外部的服务（例如网络活动）的交互，要求调用者查看错误的性质，以确定重试操作是否合理。</p><p>在这种情况下，我们可以断言错误实现了特定的行为，而不是断言错误是特定的类型或值。 考虑这个例子：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> temporary <span class="hljs-keyword">interface</span> &#123;Temporary() <span class="hljs-keyword">bool</span>&#125;<span class="hljs-comment">// IsTemporary returns true if err is temporary.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsTemporary</span><span class="hljs-params">(err error)</span> <span class="hljs-title">bool</span></span> &#123;te, ok := err.(temporary)<span class="hljs-keyword">return</span> ok &amp;&amp; te.Temporary()&#125;</code></pre><p>可以将任何错误传递给 <code>IsTemporary</code> 以确定错误是否可以重试。</p><p>如果错误没有实现 <code>temporary</code> 接口; 也就是说，它没有 <code>Temporary</code> 方法，那么错误不是临时的。</p><p>如果错误确实实现了 <code>Temporary</code>，那么如果 <code>true</code> 返回true ，调用者可以重试该操作。</p><p>这里的关键是，此逻辑可以在不导入定义错误的包，或者直接知道任何关于 <code>err</code>的基础类型的情况下实现 - 我们只是对它的行为感兴趣。</p><h4 id="Don’t-just-check-errors-handle-them-gracefully"><a href="#Don’t-just-check-errors-handle-them-gracefully" class="headerlink" title="Don’t just check errors, handle them gracefully"></a>Don’t just check errors, handle them gracefully</h4><p>让我想到了第二句Go谚语，我想谈谈; 不要仅仅检查错误，优雅地处理它们。 你能用以下代码提出一些问题吗？</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AuthenticateRequest</span><span class="hljs-params">(r *Request)</span> <span class="hljs-title">error</span></span> &#123;err := authenticate(r.User)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><p>一个明显的建议是，函数的五行可以替换为:</p><pre><code class="hljs go"><span class="hljs-keyword">return</span> authenticate(r.User)</code></pre><p>但这是每个人都应该在代码审查中发现的简单问题。这段代码更根本的问题是无法分辨原始错误来自哪里。</p><p>如果 <code>authenticate</code> 返回错误，那么 <code>AuthenticateRequest</code> 会将错误返回给调用者，调用者也可能会这样做，依此类推。 在程序的顶部，程序的主体将错误打印到屏幕或日志文件，所有打印的都会是： <code>No such file or directory</code> 。 </p><p><img src="http://dave.cheney.net/wp-content/uploads/2016/04/Screen-Shot-2016-04-27-at-07.00.21.png" alt="No such file or directory"></p><p>没有生成错误的文件和行的信息。 没有导致错误的调用堆栈的 <code>stack trace</code>。 该代码的作者将被迫进行一个长的会话，将他们的代码二等分，以发现哪个代码路径触发了文件未找到错误。</p><p>Donovan和Kernighan的_The Go Programming Language_建议您使用 <code>fmt.Errorf</code> 向错误路径添加上下文</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AuthenticateRequest</span><span class="hljs-params">(r *Request)</span> <span class="hljs-title">error</span></span> &#123;err := authenticate(r.User)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> **fmt.Errorf(<span class="hljs-string">"authenticate failed: %v"</span>, err)**&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><p>但是正如我们之前看到的，这种模式与使用 <code>sentinel error values</code> 或类型断言不兼容，因为将错误值转换为字符串，将其与另一个字符串合并，然后使用 <code>fmt.Errorf</code> 将其转换回错误,破坏了相等性，同时完全破坏了原始错误中的上下文。</p><h5 id="Annotating-errors"><a href="#Annotating-errors" class="headerlink" title="Annotating errors"></a>Annotating errors</h5><p>我想建议一种方法来为错误添加上下文，为此，我将介绍一个简单的包。 该代码在 <a href="https://godoc.org/github.com/pkg/errors" target="_blank" rel="noopener"><code>github.com/pkg/errors</code></a> 提供。 错误包有两个主要函数：</p><pre><code class="hljs go"><span class="hljs-comment">// Wrap annotates cause with a message.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Wrap</span><span class="hljs-params">(cause error, message <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span></code></pre><p>第一个函数是 <code>Wrap</code>，它接收一个错误和一段消息，并产生一个新的错误。</p><pre><code class="hljs go"><span class="hljs-comment">// Cause unwraps an annotated error.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Cause</span><span class="hljs-params">(err error)</span> <span class="hljs-title">error</span></span></code></pre><p>第二个函数是 <code>Cause</code>，它接收可能已被包装的错误，并将其解包以恢复原始错误。</p><p>使用这两个函数，我们现在可以注释任何错误，并在需要检查时恢复底层错误。 考虑一个将文件内容读入内存的函数的例子。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadFile</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> &#123;f, err := os.Open(path)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, **errors.Wrap(err, <span class="hljs-string">"open failed"</span>)**&#125;<span class="hljs-keyword">defer</span> f.Close()buf, err := ioutil.ReadAll(f)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, **errors.Wrap(err, <span class="hljs-string">"read failed"</span>)**&#125;<span class="hljs-keyword">return</span> buf, <span class="hljs-literal">nil</span>&#125;</code></pre><p>我们将使用此函数编写一个函数来读取配置文件，然后从 <code>main</code> 调用它。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadConfig</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> &#123;home := os.Getenv(<span class="hljs-string">"HOME"</span>)config, err := ReadFile(filepath.Join(home, <span class="hljs-string">".settings.xml"</span>))<span class="hljs-keyword">return</span> config, **errors.Wrap(err, <span class="hljs-string">"could not read config"</span>)**&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;_, err := ReadConfig()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err)os.Exit(<span class="hljs-number">1</span>)&#125;&#125;</code></pre><p>如果 <code>ReadConfig</code> 代码路径失败，因为我们使用了 <code>errors.Wrap</code>，我们在K＆D样式中得到一个很好的注释错误。</p><pre><code class="hljs sh">could not <span class="hljs-built_in">read</span> config: open failed: open /Users/dfc/.settings.xml: no such file or directory</code></pre><p>因为 <code>errors.Wrap</code> 会产生堆栈错误，所以我们可以检查该堆栈以获取其他调试信息。 这又是一个相同的例子，但这次我们用 <code>fmt.Println</code> 替换 <code>errors.Print</code></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;_, err := ReadConfig()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;errors.Print(err)os.Exit(<span class="hljs-number">1</span>)&#125;&#125;</code></pre><p>我们会得到如下信息：</p><pre><code class="hljs sh">readfile.go:27: could not <span class="hljs-built_in">read</span> configreadfile.go:14: open failedopen /Users/dfc/.settings.xml: no such file or directory</code></pre><p>第一行来自 <code>ReadConfig</code>，第二行来自 <code>ReadFile</code> 的 <code>os.Open</code> 部分，其余部分来自 <code>os</code> 包本身，它不携带位置信息。</p><p>现在我们已经介绍了包装错误生成堆栈的概念，我们需要讨论反向操作，展开它们。 这是 <code>errors.Cause</code> 函数的域。</p><pre><code class="hljs go"><span class="hljs-comment">// IsTemporary returns true if err is temporary.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsTemporary</span><span class="hljs-params">(err error)</span> <span class="hljs-title">bool</span></span> &#123;te, ok := **errors.Cause(err)**.(temporary)<span class="hljs-keyword">return</span> ok &amp;&amp; te.Temporary()&#125;</code></pre><p>在操作中，每当您需要检查错误是否与特定值或类型匹配时，您应首先使用 <code>errors.Cause</code> 函数恢复原始错误。</p><h4 id="Only-handle-errors-once"><a href="#Only-handle-errors-once" class="headerlink" title="Only handle errors once"></a>Only handle errors once</h4><p>最后，我想提一下：你应该只处理一次错误。 处理错误意味着检查错误值并做出决定。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Write</span><span class="hljs-params">(w io.Writer, buf []<span class="hljs-keyword">byte</span>)</span></span> &#123;w.Write(buf)&#125;</code></pre><p>如果不做决定，则忽略该错误。 正如我们在这里看到的那样，<code>w.Write</code> 的错误被丢弃了。</p><p>但是，针对单个错误做出多个决策也存在问题。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Write</span><span class="hljs-params">(w io.Writer, buf []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> &#123;_, err := w.Write(buf)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">// annotated error goes to log file</span>log.Println(<span class="hljs-string">"unable to write:"</span>, err)<span class="hljs-comment">// unannotated error returned to caller</span><span class="hljs-keyword">return</span> err&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><p>In this example if an error occurs during <code>Write</code>, a line will be written to a log file, noting the file and line that the error occurred, and the error is also returned to the caller, who possibly will log it, and return it, all the way back up to the top of the program.</p><p>So you get a stack of duplicate lines in your log file, but at the top of the program you get the original error without any context. Java anyone?</p><p>在此示例中，如果在 <code>Write</code> 期间发生错误，则会将一行写入日志文件，注意错误发生的文件和行，并且错误也会返回给调用者，调用者可能会将其记录并返回，一路回到程序的顶部。</p><p>因此，您在日志文件中获得了重复的行的堆栈，但是在程序的顶部，您将获得没有原始错误的任何上下文。 有人使用Java吗？</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Write</span><span class="hljs-params">(w io.Write, buf []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> &#123;_, err := w.Write(buf)<span class="hljs-keyword">return</span> **errors.Wrap(err, <span class="hljs-string">"write failed"</span>)**&#125;</code></pre><p>使用 <code>errors</code> 包，您可以以人和机器都可检查的方式向错误值添加上下文。</p><h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><p>总之，错误是包 public API 的一部分，对待它们就像对待 public API 的其他部分一样小心。</p><p>为了获得最大的灵活性，我建议您尝试将所有错误都视为不透明的。在不能这样做的情况下，断言行为错误，而不是类型或值错误。</p><p>最小化程序中的 <code>sentinel error values</code>，并在错误发生时立即用 <code>errors.Wrap</code> 将其包装，从而将错误转换为不透明错误。</p><p>最后，如果需要检查，请使用 <code>errors.Cause</code> 恢复底层错误。</p><p><em>原文：<a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">Don’t just check errors, handle them gracefully</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文摘自我最近在日本东京举行的&lt;a href=&quot;http://gocon.connpass.com/event/27521/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GoCon春季&lt;/a&gt;会议上的演讲。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http:/
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Error" scheme="https://www.cyningsun.com/tag/Error/"/>
    
  </entry>
  
  <entry>
    <title>一张图看懂Go包管理历史</title>
    <link href="https://www.cyningsun.com/09-07-2019/package-management.html"/>
    <id>https://www.cyningsun.com/09-07-2019/package-management.html</id>
    <published>2019-09-06T16:00:00.000Z</published>
    <updated>2020-02-03T06:53:29.642Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/go-package-management/package-management.png" alt=""></p><h4 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h4><ul><li>2012年3月 Go 1 发布，此时没有版本的概念</li><li>2013年 Golang 团队在 FAQ 中提议开发者保证相同 <code>import path</code> 的兼容性，后来成为一纸空文</li><li>2013年10月 <a href="https://github.com/tools/godep" target="_blank" rel="noopener">Godep</a></li><li>2014年7月 <a href="https://github.com/Masterminds/glide" target="_blank" rel="noopener">glide</a></li><li>2014年 有人提出 <code>external packages</code> 的概念，在项目的目录下增加一个 vendor 目录来存放外部的包</li><li>2015年8月  Go 1.5 实验性质加入 vendor 机制</li><li>2015年 有人提出了采用语义化版本的草案</li><li>2016年2月 Go 1.6 vendor 机制 默认开启</li><li>2016年5月 Go 团队的 Peter Bourgon 建立委员会，讨论依赖管理工具，也就是后面的 dep</li><li>2016年8月 Go 1.7: vendor 目录永远启用</li><li>2017年1月 Go 团队发布 <a href="https://github.com/golang/dep" target="_blank" rel="noopener">Dep</a>，作为准官方试验</li><li>2018年8月 Go 1.11发布 <a href="https://golang.org/doc/go1.11#modules" target="_blank" rel="noopener">Modules</a> 作为官方试验</li><li>2019年2月 Go 1.12发布 <a href="https://golang.org/doc/go1.12#modules" target="_blank" rel="noopener">Modules</a> 默认为 auto</li></ul><h4 id="混沌初开"><a href="#混沌初开" class="headerlink" title="混沌初开"></a>混沌初开</h4><p>Go 从 Google 走出来，内部使用 blaze 系统，所以项目的源代码公用一个 repo, 任何修改都要跑 test 保证整个 repo 不出问题。因此 go get仅仅支持获取 master branch 上的 latest 代码，没有指定 version、branch 或 revision 的能力。</p><p>对应的开源的方案就是一个 $GOPATH 走天下，并没有关心依赖问题。如此做法会给gopher带来不便：依赖的第三方包总是在变。一旦第三方包提交了无法正常build或接口不兼容的代码，依赖方立即就会受到影响，但开源社区是无穷多个小 repo 的合集，像 go get 直接拉个最新的 master 版本带来了隐患：依赖一更新，已有代码就可能编译不过。</p><blockquote><p>“If you’re using an externally supplied package and worry that it might change in unexpected ways, the simplest solution is to copy it to your local repository. (This is the approach Google takes internally.) Store the copy under a new import path that identifies it as a local copy. For example, you might copy <code>original.com/pkg</code> to <code>you.com/external/original.com/pkg</code>.” - <a href="https://golang.org/doc/faq#get_version" target="_blank" rel="noopener">Go FAQ</a></p></blockquote><h4 id="八龙治水"><a href="#八龙治水" class="headerlink" title="八龙治水"></a>八龙治水</h4><p>第一个主要的社区工具是 <a href="https://github.com/tools/godep" target="_blank" rel="noopener">Godep</a>。早期它提供了一种方法来快照您在您使用的VCS修订版GOPATH，然后将其恢复到GOPATH。这为不同的应用程序提供了一种使用相同依赖项的不同修订版的方法。</p><p>Godep 确实有一些在应用程序之间切换时必须执行的手动步骤。例如，您需要将该应用程序的依赖项修订版还原到GOPATH。但是，它可以与Google工作流程一起工作，因此它可以工作。</p><p>大约在同一时间，社区自发形成了其他各式各样的包管理工具，仅<a href="https://github.com/golang/go/wiki/PackageManagementTools" target="_blank" rel="noopener">官方推荐的包管理工具</a>总数就有15种之多，大部分工具都解决了差不多的问题，只是使用上有些许的区别。这些眼花缭乱工具，对选择困难症来说，不是什么好事情。</p><h4 id="乾坤始奠"><a href="#乾坤始奠" class="headerlink" title="乾坤始奠"></a>乾坤始奠</h4><p>时间走到了 2015 年，Golang 官方终于看不下去了，在推出 go1.5 版本的同时，首次实验性质的加入了 vendor 机制 功能。vendor 标准化了项目依赖的第三方库的存放位置（不再需要Godeps/_workspace了），同时也无需对GOPATH环境变量进行“偷梁换柱”了，go compiler原生优先感知和使用vendor下缓存的第三方包。</p><p>只是有了 vendor，就有了官方的正名！项目的形态也跟以前的统一起来了，好处显而易见。但即便有了vendor的支持，vendor内第三方依赖包的代码的管理依旧是不规范的，要么是手动的，要么是借助godep这样的第三方包管理工具。 Go 项目自身对 vendor 中代码的管理方式也是手动更新，Go自身并未使用任何第三方的包管理工具。</p><p>从Go官方角度出发，官方go包依赖的解决方案的下一步就应该是解决对vendor下的第三方包如何进行管理的问题：依赖包的分析、记录和获取等，进而实现项目的reproducible build。</p><h4 id="继往开来"><a href="#继往开来" class="headerlink" title="继往开来"></a>继往开来</h4><p>2018年初，Go team 的技术 Leader，<a href="https://research.swtch.com/" target="_blank" rel="noopener">Russ Cox</a> 在<a href="https://research.swtch.com/" target="_blank" rel="noopener">博客</a>上连续发表<a href="https://research.swtch.com/vgo" target="_blank" rel="noopener">七篇文章</a>，系统阐述了 Go team “包依赖管理”方案: <a href="https://github.com/golang/vgo" target="_blank" rel="noopener">vgo</a>。vgo 主要思路包括：<a href="https://research.swtch.com/vgo-import" target="_blank" rel="noopener">Semantic Import Versioning</a>、<a href="https://research.swtch.com/vgo-mvs" target="_blank" rel="noopener">Minimal Version Selection</a>、<a href="https://research.swtch.com/vgo-module" target="_blank" rel="noopener">引入Go module</a>等。文章引发了Go社区激烈地争论，让很多 Go 包管理工具的维护者“不满”，其中包括“准官方工具”：<a href="https://github.com/golang/dep" target="_blank" rel="noopener">dep</a>。vgo方案的提出也意味着dep项目等一系列包管理工具的生命周期即将进入尾声。</p><p>2018年5月，Russ Cox的 <a href="https://github.com/golang/go/issues/24301" target="_blank" rel="noopener">Proposal “cmd/go: add package version support to Go toolchain”</a> 被 accepted，此后 vgo 代码 merge 到 Go 主干，并正式命名为“modules”。后续Go modules机制将直接在Go主干上继续演化。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://xuanwo.io/2019/05/27/go-modules/" target="_blank" rel="noopener">https://xuanwo.io/2019/05/27/go-modules/</a></li><li><a href="https://blog.lab99.org/post/golang-2017-10-09-video-the-new-era-of-go-package-management.html" target="_blank" rel="noopener">https://blog.lab99.org/post/golang-2017-10-09-video-the-new-era-of-go-package-management.html</a></li><li><a href="https://www.zhihu.com/question/52177662" target="_blank" rel="noopener">https://www.zhihu.com/question/52177662</a></li><li><a href="https://dave.cheney.net/tag/dependency-management" target="_blank" rel="noopener">https://dave.cheney.net/tag/dependency-management</a></li><li><a href="https://juejin.im/entry/5b04fb8c51882542ac7d99e5" target="_blank" rel="noopener">https://juejin.im/entry/5b04fb8c51882542ac7d99e5</a></li><li><a href="https://nathany.com/go-packages/" target="_blank" rel="noopener">https://nathany.com/go-packages/</a></li><li><a href="https://www.ardanlabs.com/blog/2013/10/manage-dependencies-with-godep.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2013/10/manage-dependencies-with-godep.html</a></li><li><a href="https://golang.org/doc/devel/release.html" target="_blank" rel="noopener">https://golang.org/doc/devel/release.html</a></li><li><a href="https://tonybai.com/2018/07/15/hello-go-module/" target="_blank" rel="noopener">https://tonybai.com/2018/07/15/hello-go-module/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/go-package-management/package-management.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;时间线&quot;&gt;&lt;a href=&quot;#时间线&quot; class=&quot;headerlink&quot; title=&quot;时间线&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Package Management" scheme="https://www.cyningsun.com/tag/Package-Management/"/>
    
  </entry>
  
  <entry>
    <title>译｜Errors are values</title>
    <link href="https://www.cyningsun.com/08-19-2019/errors-are-values-cn.html"/>
    <id>https://www.cyningsun.com/08-19-2019/errors-are-values-cn.html</id>
    <published>2019-08-18T16:00:00.000Z</published>
    <updated>2020-02-03T06:53:29.641Z</updated>
    
    <content type="html"><![CDATA[<p>Go程序员，尤其是那些刚接触语言的人，常见的讨论点是如何处理错误。 谈话经常变成对以下代码段出现次数的失望</p><pre><code class="hljs go"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;    <span class="hljs-keyword">return</span> err&#125;</code></pre><p>我们最近扫描了我们可以找到的所有开源项目，发现这个代码段每一页或每两页只发生一次，比你们想象的更少。 尽管如此，如果必须总是写</p><pre><code class="hljs go"><span class="hljs-keyword">if</span> err != nuil</code></pre><p>的感觉持续存在, 一定是出了什么问题，明显的目标就是 <code>Go</code> 本身。</p><p>这是令人遗憾和误导性的，而且很容易纠正。事实可能正是<code>Go</code> 新程序员想问的：“如何处理错误？”，他们碰到这种模式，然后停在那里。在其他语言中，可以使用 <code>try-catch</code> 块或其他此类机制来处理错误。因此，程序员认为，当我使用旧语言的 <code>try-catch</code> 时，在 <code>Go</code> 中我只需输入 <code>if err != nil</code>。随着时间的推移，<code>Go</code> 代码汇集了许多这样的片段，结果显得很笨拙。</p><p>先不管这种解释是否合适，很明显这些 <code>Go</code> 程序员缺少关于错误的一个根本点： <code>Errors are values</code>。</p><p>值可以编程，既然错误是值，因此错误也可以编程。</p><p>当然，涉及错误值的常见语句是检测它是否为nil，但是还有无数其他可以用错误值做的事情，并且应用其中的一些东西可以使您的程序变得更好，从而消除大量如果机械的使用if语句检查每个错误会出现的样板。</p><p>以下是 <code>bufio</code> 包 <a href="https://golang.org/pkg/bufio/#Scanner" target="_blank" rel="noopener"><code>Scanner</code></a> 类型的一个简单示例。它的 <a href="https://golang.org/pkg/bufio/#Scanner.Scan" target="_blank" rel="noopener"><code>Scan</code></a> 方法执行底层 <code>I/O</code>，这当然会导致错误。然而，该 <code>Scan</code> 方法根本不暴露错误。相反，它返回一个布尔值和一个单独的方法，在扫描结束时运行，报告是否发生了错误。客户端代码如下所示：</p><pre><code class="hljs go">scanner := bufio.NewScanner(input)<span class="hljs-keyword">for</span> scanner.Scan() &#123;    token := scanner.Text()    <span class="hljs-comment">// process token</span>&#125;<span class="hljs-keyword">if</span> err := scanner.Err(); err != <span class="hljs-literal">nil</span> &#123;    <span class="hljs-comment">// process the error</span>&#125;</code></pre><p>当然，有出现错误的空值检查，但它只出现并执行一次。 可以将 <code>Scan</code> 方法定义为</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Scanner)</span> <span class="hljs-title">Scan</span><span class="hljs-params">()</span> <span class="hljs-params">(token []<span class="hljs-keyword">byte</span>, error)</span></span></code></pre><p>然后示例用户代码可能是（取决于如何取回 token），</p><pre><code class="hljs go">scanner := bufio.NewScanner(input)<span class="hljs-keyword">for</span> &#123;    token, err := scanner.Scan()    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> err <span class="hljs-comment">// or maybe break</span>    &#125;    <span class="hljs-comment">// process token</span>&#125;</code></pre><p>并没有太大的不同，但有一个重要的区别。 在此代码中，客户端必须在每次迭代时检查错误，但在真正的 <code>Scanner</code> API 中，错误处理从关键 API 元素抽象出来，而关键 API 元素正在迭代 token。 使用真正的 API，客户端的代码更自然：循环直到完成，最后进行错误处理。错误处理不会掩盖控制流。</p><p>当然，幕后是，只要 <code>Scan</code> 遇到 I/O 错误，它就会记录它并返回 false。 一个单独的 <a href="https://golang.org/pkg/bufio/#Scanner.Err" target="_blank" rel="noopener"><code>Err</code></a> 方法 在客户端调用时报告错误值。 虽然很微不足道，但它与到处敲</p><pre><code class="hljs go"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span></code></pre><p>或要求客户端在每个 token 之后检查错误不同。它正在用错误值编程。简洁的编程，对，仍还是编程。</p><p>值得强调的是，无论设计如何，程序检查错误都是至关重要的。这里的讨论不是关于如何避免检查错误，而是关于使用语言，优雅的处理错误。</p><p>当我参加2014年秋季东京的 GoCon 时，出现了重复性错误检查代码的主题。一位热心的Gopher，Twitter上称呼为 <a href="https://twitter.com/jxck_" target="_blank" rel="noopener"><em>@jxck_</em></a>，响应了我们熟悉的关于错误检查的失望。他有一些代码看起来像这样：</p><pre><code class="hljs go">_, err = fd.Write(p0[a:b])<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;    <span class="hljs-keyword">return</span> err&#125;_, err = fd.Write(p1[c:d])<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;    <span class="hljs-keyword">return</span> err&#125;_, err = fd.Write(p2[e:f])<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;    <span class="hljs-keyword">return</span> err&#125;<span class="hljs-comment">// and so on</span></code></pre><p>代码重复性很高。 在实际代码中，会更长，还有更多内容，因此使用 helper 函数重构它并不容易，但在如此理想化的情况下，封装错误变量的函数字面值会有用：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> err errorwrite := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(buf []<span class="hljs-keyword">byte</span>)</span></span> &#123;    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span>    &#125;    _, err = w.Write(buf)&#125;write(p0[a:b])write(p1[c:d])write(p2[e:f])<span class="hljs-comment">// and so on</span><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;    <span class="hljs-keyword">return</span> err&#125;</code></pre><p>该模式很有效，但每个执行写操作的函数都需要一个闭包; 单独的 helper 函数使用起来比较笨拙，因为 err 变量需要跨调用维护（试试看）。</p><p>通过借鉴上述 <code>Scan</code> 方法的想法，我们可以使代码更清洁，更通用和可重复使用 。我在讨论中提到过这种技术，但 <em>@jxck</em> 没有明白如何应用它。经过长时间的交流，受到语言障碍的阻碍，我问我是否可以借用他的笔记本电脑，通过写一些代码给他看。</p><p>我定义了一个名为 <code>errWriter</code> 的对象，如下所示：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> errWriter <span class="hljs-keyword">struct</span> &#123;    w   io.Writer    err error&#125;</code></pre><p>并给它一种方法，<code>write</code>。小写部分是为了突出区别, 它不需要有标准的 <code>Write</code> 签名。该 <code>write</code> 方法调用底层 <code>Writer</code> 的 <code>Write</code> 方法 并记录第一个错误以供将来引用：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ew *errWriter)</span> <span class="hljs-title">write</span><span class="hljs-params">(buf []<span class="hljs-keyword">byte</span>)</span></span> &#123;    <span class="hljs-keyword">if</span> ew.err != <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span>    &#125;    _, ew.err = ew.w.Write(buf)&#125;</code></pre><p>一旦发生错误，<code>write</code> 方法就会变为无操作，但会保存错误值。</p><p>有了 <code>errWriter</code> 类型及其 <code>write</code> 方法，可以重构上面的代码如下：</p><pre><code class="hljs go">ew := &amp;errWriter&#123;w: fd&#125;ew.write(p0[a:b])ew.write(p1[c:d])ew.write(p2[e:f])<span class="hljs-comment">// and so on</span><span class="hljs-keyword">if</span> ew.err != <span class="hljs-literal">nil</span> &#123;    <span class="hljs-keyword">return</span> ew.err&#125;</code></pre><p>现在甚至比之前使用闭包还要清晰，并且更容易看到纸上实际的写入顺序。 再没有杂乱。 使用错误值（和接口）进行编程使代码更好。</p><p>可能同一包中其他地方的代码也可以使用这种思想，甚至可以直接使用 <code>errWriter</code>。</p><p>此外，一旦 <code>errWriter</code> 存在，它可以做更多事情，尤其是在更实用的例子中。 它可以累积字节数。 它可以将写入合并到一个缓冲区中，然后可以原子的传输。 等等。</p><p>实际上，这种模式经常出现在标准库中。 <a href="https://golang.org/pkg/archive/zip/" target="_blank" rel="noopener"><code>archive/zip</code></a> 和 <a href="https://golang.org/pkg/net/http/" target="_blank" rel="noopener"><code>net/http</code></a> 包在使用。该讨论最显著的是， <a href="https://golang.org/pkg/bufio/" target="_blank" rel="noopener"><code>bufio</code> 包的 <code>Writer</code></a> 实际上是 <code>errWriter</code> 想法的实现。 尽管 <code>bufio.Writer.Write</code> 返回错误，但主要是在于实现 <a href="https://golang.org/pkg/io/#Writer" target="_blank" rel="noopener"><code>io.Writer</code></a> 接口。 <code>bufio.Writer</code> 的 <code>Write</code> 方法就像我们上面的 <code>errWriter.write</code> 方法一样， <code>Flush</code> 报告错误，因此我们的示例可以像这样编写：</p><pre><code class="hljs go">b := bufio.NewWriter(fd)b.Write(p0[a:b])b.Write(p1[c:d])b.Write(p2[e:f])<span class="hljs-comment">// and so on</span><span class="hljs-keyword">if</span> b.Flush() != <span class="hljs-literal">nil</span> &#123;    <span class="hljs-keyword">return</span> b.Flush()&#125;</code></pre><p>至少对于某些应用程序， 这种方法有一个明显的缺点：在错误发生之前无法知道完成了多少处理。 如果该信息很重要，则需要采用更细粒度的方法。 但是，通常，最后全有或全无检查就足够了。</p><p>我们只研究了一种避免重复错误处理代码的技术。 请记住，使用 <code>errWriter</code> 或 <code>bufio.Writer</code> 并不是简化错误处理的唯一方法，并且这种方法并不适合所有情况。 然而，关键的一课是 <code>errors are values</code>，并且Go编程语言的全部功能可用于处理它们。</p><p>使用语言简化错误处理。</p><p>但请记住：无论你怎么做，一定要检查自己的错误！</p><p>最后，关于我与 <em>@jxck</em> 互动的完整故事，包括他录制的一个小视频，请访问他的<a href="http://jxck.hatenablog.com/entry/golang-error-handling-lesson-by-rob-pike" target="_blank" rel="noopener">博客</a> 。</p><p><em>原文：<a href="https://blog.golang.org/errors-are-values" target="_blank" rel="noopener">Errors are values</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Go程序员，尤其是那些刚接触语言的人，常见的讨论点是如何处理错误。 谈话经常变成对以下代码段出现次数的失望&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err != &lt;span cl
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Error" scheme="https://www.cyningsun.com/tag/Error/"/>
    
  </entry>
  
  <entry>
    <title>译 | SOLID Go Design</title>
    <link href="https://www.cyningsun.com/08-03-2019/solid-go-design-cn.html"/>
    <id>https://www.cyningsun.com/08-03-2019/solid-go-design-cn.html</id>
    <published>2019-08-02T16:00:00.000Z</published>
    <updated>2020-02-03T06:53:29.641Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Code-review"><a href="#Code-review" class="headerlink" title="Code review"></a>Code review</h3><p>在座的各位有谁把 code review 作为日常工作的一部分？【整个房间举起了手，鼓舞人心】。好的，为什么要进行 code review ？【有人高呼“阻止不良代码”】</p><p>如果代码审查是为了捕捉糟糕的代码，那么你如何知道你正在审查的代码是好还是糟糕？</p><p>正如你可能会说“这幅画很漂亮”或“这个房间很漂亮”，现在你可以说“代码很难看”或“源代码很漂亮”，但这些都是主观的。我正在寻找以客观方式谈论代码好或坏的特征。</p><h3 id="Bad-code"><a href="#Bad-code" class="headerlink" title="Bad code"></a>Bad code</h3><p>你在 code review 中可能会遇到以下这些糟糕代码的特征：</p><ul><li><em>Rigid</em> - 代码死板吗？它是否有强类型或参数，以致难于修改？</li><li><em>Fragile</em> - 代码脆弱吗？细微的改变是否会在代码库中引起不可估量的破坏？</li><li><em>Immobile</em> - 代码难以重构吗？代码只需敲敲键盘就可以避免循环导入？</li><li><em>Complex</em> - 有没有代码是为了炫技，是否过度设计？</li><li><em>Verbose</em> - 代码使用费力吗？当阅读时，能看出来代码在做什么吗？</li></ul><p>这些词是正向吗？你是否乐于看到这些词用于审核您的代码？</p><p>想必不会。</p><h3 id="Good-design"><a href="#Good-design" class="headerlink" title="Good design"></a>Good design</h3><p>但这是一个进步，现在我们可以说“我不喜欢它，因为它太难修改”，或“我不喜欢它，因为我不知道代码试图做什么”，但如何正向引导呢？</p><p>如果有一些方法可以描述糟糕的设计，以及优秀设计的特征，并且能够以客观的方式做到这一点，那不是很好吗？</p><h4 id="SOLID"><a href="#SOLID" class="headerlink" title="SOLID"></a>SOLID</h4><p>2002年，Robert Martin 出版了他的书 <a href="https://www.amazon.co.uk/dp/0135974445/ref=pd_lpo_sbs_dp_ss_2/253-1946330-6751666?pf_rd_m=A3P5ROKL5A1OLE&pf_rd_s=lpo-top-stripe&pf_rd_r=23C4AHYV7EXGYHKD6G8Q&pf_rd_t=201&pf_rd_p=569136327&pf_rd_i=0132760584" target="_blank" rel="noopener"><em>Agile Software Development, Principles, Patterns, and Practices</em></a> 其中描述了可重用软件设计的五个原则，并称之为 <a href="https://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1)" target="_blank" rel="noopener"><code>SOLID</code></a>（英文首字母缩写）原则:</p><ul><li>单一职责原则（Single Responsibility Principle）</li><li>开放/封闭原则（Open / Closed Principle）</li><li>里氏替换原则（Liskov Substitution Principle）</li><li>接口隔离原则（Interface Segregation Principle）</li><li>依赖倒置原则（Dependency Inversion Principle）</li></ul><p>这本书有点过时了，它所讨论的语言是十多年前使用的语言。但是，也许 <code>SOLID</code> 原则的某些方面可以给我们提供些线索，关于怎样谈论一个精心设计的 Go 程序。</p><h5 id="单一职责原则（Single-Responsibility-Principle）"><a href="#单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="单一职责原则（Single Responsibility Principle）"></a>单一职责原则（Single Responsibility Principle）</h5><p>SOLID的第一个原则，S，是单一责任原则。</p><blockquote><p>A class should have one, and only one, reason to change. <code>– Robert C Martin</code></p></blockquote><p>现在 Go 显然没有 <code>classses</code> - 相反，我们有更强大的组合概念 - 但是如果你能回顾一下 <code>class</code> 这个词的用法，我认为此时会有一定价值。</p><p>为什么一段代码只有一个改变的原因很重要？嗯，就像你自己的代码可能会改变一样令人沮丧，发现您的代码所依赖的代码在您脚下发生变化更痛苦。当你的代码必须改变时，它应该响应直接刺激作出改变，而不应该成为附带损害的受害者。</p><p>因此，具有单一责任的代码修改的原因最少。</p><h6 id="Coupling-amp-Cohesion"><a href="#Coupling-amp-Cohesion" class="headerlink" title="Coupling &amp; Cohesion"></a>Coupling &amp; Cohesion</h6><p>描述改变一个软件是多么容易或困难的两个词是：耦合和内聚。</p><ul><li>耦合只是一个词，描述了两个一起变化的东西 —— 一个运动诱导另一个运动。</li><li>一个相关但独立的概念是内聚，一种相互吸引的力量。</li></ul><p>在软件上下文中，内聚是描述代码片段之间自然相互吸引的特性。</p><p>为了描述Go程序中耦合和内聚的单元，我们可能会将谈谈函数和方法，这在讨论 <code>SRP</code> 时很常见，但是我相信它始于 Go 的 package 模型。</p><blockquote><p>SRP: Single Responsibility Principle</p></blockquote><h6 id="Package-names"><a href="#Package-names" class="headerlink" title="Package names"></a>Package names</h6><p>在 Go 中，所有的代码都在某个 package 中，一个设计良好的 package 从其名称开始。包的名称既是其用途的描述，也是名称空间前缀。Go 标准库中的一些优秀 package 示例：</p><ul><li><code>net/http</code> - 提供 http 客户端和服务端</li><li><code>os/exec</code> - 执行外部命令</li><li><code>encoding/json</code> - 实现JSON文档的编码和解码</li></ul><p>当你在自己的内部使用另一个 pakcage 的 symbols 时，要使用 <code>import</code> 声明，它在两个 package 之间建立一个源代码级的耦合。 他们现在彼此知道对方的存在。</p><h6 id="Bad-package-names"><a href="#Bad-package-names" class="headerlink" title="Bad package names"></a>Bad package names</h6><p>这种对名字的关注可不是迂腐。命名不佳的 package 如果真的有用途，会失去罗列其用途的机会。</p><ul><li><code>server</code> package 提供什么？ …, 嗯，希望是服务端，但是它使用哪种协议？</li><li><code>private</code> package 提供什么？我不应该看到的东西？它应该有公共符号吗？</li><li><code>common</code> package，和它的伴儿 <code>utils</code> package 一样，经常被发现和其他’伙伴’一起发现</li></ul><p>我们看到所有像这样的包裹，就成了各种各样的垃圾场，因为它们有许多责任，所以经常毫无理由地改变。</p><h6 id="Go’s-UNIX-philosophy"><a href="#Go’s-UNIX-philosophy" class="headerlink" title="Go’s UNIX philosophy"></a>Go’s UNIX philosophy</h6><p>在我看来，如果不提及 Doug McIlroy 的 Unix 哲学，任何关于解耦设计的讨论都将是不完整的；小而锋利的工具结合起来，解决更大的任务，通常是原始作者无法想象的任务。</p><p>我认为 Go package 体现了 Unix 哲学的精神。实际上，每个 Go package 本身就是一个小的 Go 程序，一个单一的变更单元，具有单一的责任。</p><h5 id="开放-封闭原则（Open-Closed-Principle）"><a href="#开放-封闭原则（Open-Closed-Principle）" class="headerlink" title="开放/封闭原则（Open / Closed Principle）"></a>开放/封闭原则（Open / Closed Principle）</h5><p>第二个原则，即 O，是 <code>Bertrand Meyer</code> 的开放/封闭原则，他在1988年写道：</p><blockquote><p>Software entities should be open for extension, but closed for modification. <code>– Bertrand Meyer, Object-Oriented Software Construction</code></p></blockquote><p>该建议如何适用于21年后写的语言？</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">type</span> A <span class="hljs-keyword">struct</span> &#123;        year <span class="hljs-keyword">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a A)</span> <span class="hljs-title">Greet</span><span class="hljs-params">()</span></span> &#123; fmt.Println(<span class="hljs-string">"Hello GolangUK"</span>, a.year) &#125;<span class="hljs-keyword">type</span> B <span class="hljs-keyword">struct</span> &#123;        A&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b B)</span> <span class="hljs-title">Greet</span><span class="hljs-params">()</span></span> &#123; fmt.Println(<span class="hljs-string">"Welcome to GolangUK"</span>, b.year) &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">var</span> a A        a.year = <span class="hljs-number">2016</span>        <span class="hljs-keyword">var</span> b B        b.year = <span class="hljs-number">2016</span>        a.Greet() <span class="hljs-comment">// Hello GolangUK 2016</span>        b.Greet() <span class="hljs-comment">// Welcome to GolangUK 2016</span>&#125;</code></pre><p>我们有一个类型 A ，有一个字段 year 和一个方法 Greet。我们有第二种类型，B 它嵌入了一个 A，因为 A 嵌入，因此调用者看到 B 的方法覆盖了 A 的方法。因为A作为字段嵌入B ，B可以提供自己的 Greet 方法，掩盖了 A 的 Greet 方法。</p><p>但嵌入不仅适用于方法，还可以访问嵌入类型的字段。如您所见，因为A和B都在同一个包中定义，所以 B 可以访问 A 的私有 year 字段，就像在 B 中声明一样。</p><p>因此嵌入是一个强大的工具，允许 Go 的类型对扩展开放。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span> &#123;        Name <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Cat)</span> <span class="hljs-title">Legs</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">4</span> &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Cat)</span> <span class="hljs-title">PrintLegs</span><span class="hljs-params">()</span></span> &#123;        fmt.Printf(<span class="hljs-string">"I have %d legs\n"</span>, c.Legs())&#125;<span class="hljs-keyword">type</span> OctoCat <span class="hljs-keyword">struct</span> &#123;        Cat&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o OctoCat)</span> <span class="hljs-title">Legs</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">5</span> &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">var</span> octo OctoCat        fmt.Println(octo.Legs()) <span class="hljs-comment">// 5</span>        octo.PrintLegs()         <span class="hljs-comment">// I have 4 legs</span>&#125;</code></pre><p>在这个例子中，我们有一个 Cat 类型，可以用它的 Legs 方法计算它的腿数。我们将 Cat 类型嵌入到一个新类型 OctoCat 中，并声明 Octocats 有五条腿。但是，虽然 OctoCat 定义了自己的 Legs 方法，该方法返回5，但是当调用 PrintLegs 方法时，它返回4。</p><p>这是因为 PrintLegs 是在 Cat 类型上定义的。 它需要 Cat 作为它的接收器，因此它会发送到 Cat 的 Legs 方法。Cat 不知道它嵌入的类型，因此嵌入时不能改变其方法集。</p><p>因此，我们可以说 Go 的类型虽然对扩展开放，但对修改是封闭的。</p><p>事实上，Go 中的方法只不过是围绕在具有预先声明形式参数（即接收器）的函数的语法糖。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Cat)</span> <span class="hljs-title">PrintLegs</span><span class="hljs-params">()</span></span> &#123;        fmt.Printf(<span class="hljs-string">"I have %d legs\n"</span>, c.Legs())&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PrintLegs</span><span class="hljs-params">(c Cat)</span></span> &#123;        fmt.Printf(<span class="hljs-string">"I have %d legs\n"</span>, c.Legs())&#125;</code></pre><p>接收器正是你传入它的函数，函数的第一个参数，并且因为Go不支持函数重载，OctoCat不能替代普通的Cat 。 这让我想到了下一个原则。</p><h5 id="里氏替换原则（Liskov-Substitution-Principle）"><a href="#里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏替换原则（Liskov Substitution Principle）"></a>里氏替换原则（Liskov Substitution Principle）</h5><p>由Barbara Liskov 提出的里氏替换原则粗略地指出，如果两种类型表现出的行为使得调用者无法区分，则这两种类型是可替代的。</p><p>在基于类的语言中，里氏替换原则通常被解释为，具有各种具体子类型的抽象基类的规范。 但是Go没有类或继承，因此无法根据抽象类层次结构实现替换。</p><h6 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h6><p>相反，替换是Go接口的范围。在Go中，类型不需要指定它们实现特定接口，而是任何类型实现接口，只要它具有签名与接口声明匹配的方法。</p><p>我们说在Go中，接口是隐式地而不是显式地满足的，这对它们在语言中的使用方式产生了深远的影响。</p><p>设计良好的接口更可能是小型接口; 流行的做法是一个接口只包含一个方法。从逻辑上讲，小接口使实现变得简单，反之则很难。因此形成了由普通行为的简单实现组成的 package。</p><h6 id="io-Reader"><a href="#io-Reader" class="headerlink" title="io.Reader"></a>io.Reader</h6><pre><code class="hljs go"><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> &#123;        <span class="hljs-comment">// Read reads up to len(buf) bytes into buf.</span>        Read(buf []<span class="hljs-keyword">byte</span>) (n <span class="hljs-keyword">int</span>, err error)&#125;</code></pre><p>这令我很容易想到了我最喜欢的 Go 接口 <code>io.Reader</code>。</p><p> <code>io.Reader</code> 接口非常简单; <code>Read</code> 将数据读入提供的缓冲区，并将读取的字节数和读取期间遇到的任何错误返回给调用者。看起来很简单，但非常强大。</p><p>因为 <code>io.Reader</code> 可以处理任何表示为字节流的东西，所以我们几乎可以在任何东西上创建 <code>Reader</code>; 常量字符串，字节数组，标准输入，网络流，gzip的tar文件，通过ssh远程执行的命令的标准输出。</p><p>并且所有这些实现都可以互相替代，因为它们实现了相同的简单契约。</p><p>因此，适用于Go的里氏替换原则，可以通过已故 Jim Weirich 的格言来概括。</p><blockquote><p>Require no more, promise no less.<br><code>– Jim Weirich</code></p></blockquote><p>顺利转入”SOLID”第四个原则。</p><h5 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h5><p>第四个原则是接口隔离原则，其内容如下：</p><blockquote><p>Clients should not be forced to depend on methods they do not use.<br>–Robert C. Martin</p></blockquote><p>在Go中，接口隔离原则的应用可以指的是，隔离功能完成其工作所需的行为的过程。举一个具体的例子，假设我已经完成了‘编写一个将Document结构保存到磁盘的函数’的任务。</p><pre><code class="hljs go"><span class="hljs-comment">// Save writes the contents of doc to the file f.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Save</span><span class="hljs-params">(f *os.File, doc *Document)</span> <span class="hljs-title">error</span></span></code></pre><p>我可以定义此函数，让我们称之为 <code>Save</code>，它将给定的 Document 写入到 <code>*os.File</code>。 但是这样做会有一些问题。</p><p>Save的签名排除了将数据写入网络位置的选项。假设网络存储可能以后成为需求，此功能的签名必须改变，并影响其所有调用者。</p><p>由于 <code>Save</code> 直接操作磁盘上的文件，因此测试起来很不方便。要验证其操作，测试必须在写入后读取文件的内容。 此外，测试必须确保将 <code>f</code> 写入临时位置并随后将其删除。</p><p><code>*os.File</code> 还定义了许多与 <code>Save</code> 无关的方法，比如读取目录并检查路径是否是文件链接。 如果 <code>Save</code> 函数的签名能只描述 <code>*os.File</code> 相关的部分，将会很实用。</p><p>我们如何处理这些问题呢？</p><pre><code class="hljs go"><span class="hljs-comment">// Save writes the contents of doc to the supplied ReadWriterCloser.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Save</span><span class="hljs-params">(rwc io.ReadWriteCloser, doc *Document)</span> <span class="hljs-title">error</span></span></code></pre><p>使用 <code>io.ReadWriteCloser</code> 我们可以应用接口隔离原则，使用更通用的文件类型的接口来重新定义 <code>Save</code>。</p><p>通过此更改，任何实现了 <code>io.ReadWriteCloser</code> 接口的类型都可以代替之前的 <code>*os.File</code>。使得 <code>Save</code> 应用程序更广泛，并向 <code>Save</code> 调用者阐明，<code>*os.File</code> 类型的哪些方法与操作相关。</p><p>做为<code>Save</code>的编写者，我不再可以选择调用 <code>*os.File</code> 的那些不相关的方法，因为它隐藏在 <code>io.ReadWriteCloser</code> 接口背后。我们可以进一步采用接口隔离原理。</p><p>首先，如果 <code>Save</code> 遵循单一责任原则，它将不可能读取它刚刚编写的文件来验证其内容 - 这应该是另一段代码的责任。因此，我们可以将我们传递给 <code>Save</code> 的接口的规范缩小，仅写入和关闭。</p><pre><code class="hljs go"><span class="hljs-comment">// Save writes the contents of doc to the supplied WriteCloser.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Save</span><span class="hljs-params">(wc io.WriteCloser, doc *Document)</span> <span class="hljs-title">error</span></span></code></pre><p>其次，通过向 <code>Save</code> 提供一个关闭其流的机制，我们继续这种机制以使其看起来像文件类型的东西，这就产生一个问题，<code>wc</code> 会在什么情况下关闭。<code>Save</code> 可能会无条件地调用 <code>Close</code>，抑或在成功的情况下调用 <code>Close</code>。</p><p>这给 <code>Save</code> 的调用者带来了问题，因为它可能希望在写入文档之后将其他数据写入流。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> NopCloser <span class="hljs-keyword">struct</span> &#123;        io.Writer&#125;<span class="hljs-comment">// Close has no effect on the underlying writer.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *NopCloser)</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;</code></pre><p>一个粗略的解决方案是定义一个新类型，它嵌入一个 <code>io.Writer</code> 并覆盖 <code>Close</code> 方法，以阻止<code>Save</code>方法关闭底层数据流。</p><p>但这样可能会违反里氏替换原则，因为NopCloser实际上并没有关闭任何东西。</p><pre><code class="hljs go"><span class="hljs-comment">// Save writes the contents of doc to the supplied Writer.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Save</span><span class="hljs-params">(w io.Writer, doc *Document)</span> <span class="hljs-title">error</span></span></code></pre><p>一个更好的解决方案是重新定义 <code>Save</code> 只接收 <code>io.Writer</code>，完全剥离它除了将数据写入流之外做任何事情的责任。</p><p>通过应用接口隔离原则，我们的Save功能，同时得到了一个在需求方面最具体的函数 - 它只需要一个可写的参数 - 并且具有最通用的功能，现在我们可以使用 <code>Save</code> 保存我们的数据到任何一个实现 <code>io.Writer</code> 的地方。</p><blockquote><p>A great rule of thumb for Go is <strong>accept interfaces, return structs</strong>.<br><code>– Jack Lindamood</code></p></blockquote><p>退一步说，这句话是一个有趣的模因，在过去的几年里，它渗透入 Go 思潮。</p><p>这个推特大小的版本缺乏细节，这不是Jack的错，但我认为它代表了第一个正当有理的Go设计传统</p><h5 id="依赖倒置原则（Dependency-Inversion-Principle）"><a href="#依赖倒置原则（Dependency-Inversion-Principle）" class="headerlink" title="依赖倒置原则（Dependency Inversion Principle）"></a>依赖倒置原则（Dependency Inversion Principle）</h5><p>最后一个SOLID原则是依赖倒置原则，该原则指出：</p><blockquote><p>High-level modules should not depend on low-level modules. Both should depend on abstractions.<br>Abstractions should not depend on details. Details should depend on abstractions.<br><code>– Robert C. Martin</code></p></blockquote><p>但是，对于Go程序员来说，依赖倒置在实践中意味着什么呢？</p><p>如果您已经应用了我们之前谈到的所有原则，那么您的代码应该已经被分解为离散包，每个包都有一个明确定义的责任或目的。您的代码应该根据接口描述其依赖关系，并且应该考虑这些接口以仅描述这些函数所需的行为。 换句话说，除此之外没什么应该要做的。</p><p>所以我认为，在Go的上下文中，Martin所指的是 import graph 的结构。</p><p>在Go中，import graph 必须是非循环的。 不遵守这种非循环要求将导致编译失败，但更为严重地是它代表设计中存在严重错误。</p><p>在所有条件相同的情况下，精心设计的Go程序的 import graph 应该是宽的，相对平坦的，而不是高而窄的。 如果你有一个 package，其函数无法在不借助另一个 package 的情况下运行，那么这或许表明代码没有很好地沿 pakcage 边界分解。</p><p>依赖倒置原则鼓励您将特定的责任，沿着 import graph 尽可能的推向更高层级，推给 main package 或顶级处理程序，留下较低级别的代码来处理抽象接口。</p><h4 id="SOLID-Go-Design"><a href="#SOLID-Go-Design" class="headerlink" title="SOLID Go Design"></a>SOLID Go Design</h4><p>回顾一下，当应用于Go时，每个SOLID原则都是关于设计的强有力陈述，但综合起来它们具有中心主题。</p><ul><li>单一职责原则，鼓励您将功能，类型、方法结构化为具有自然内聚的包; 类型属于彼此，函数服务于单一目的。</li><li>开放/封闭原则，鼓励您使用嵌入将简单类型组合成更复杂的类型。</li><li>里氏替换原则，鼓励您根据接口而不是具体类型来表达包之间的依赖关系。通过定义小型接口，我们可以更加确信，实现将忠实地满足他们的契约。</li><li>接口隔离原则，进一步采用了这个想法，并鼓励您定义仅依赖于他们所需行为的函数和方法。如果您的函数仅需要具有单个接口类型的参数的方法，则该函数更可能只有一个责任。</li><li>依赖倒置原则，鼓励您按照从编译时间到运行时间的时序，转移 package 所依赖的知识。在Go中，我们可以通过特定 package 使用的import语句的数量减少看到了这一点。</li></ul><p>如果要总结一下本次演讲，那可能就是这样：<code>interfaces let you apply the SOLID principles to Go programs</code>。</p><p>因为接口让Go程序员描述他们的 package 提供了什么 - 而不是它怎么做的。换个说法就是“解耦”，这确实是目标，因为越松散耦合的软件越容易修改。</p><p>正如Sandi Metz所说：</p><blockquote><p>Design is the art of arranging code that needs to work <strong>today</strong>, and to be easy to change <strong>forever</strong>.<br><code>– Sandi Metz</code></p></blockquote><p>因为如果Go想要成为公司长期投资的语言，Go程序的可维护性，更容易变更，将是他们决策的关键因素。</p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>最后，让我们回到我打开本次演讲的问题; 世界上有多少Go程序员？这是我的猜测：</p><blockquote><p>By 2020, there will be 500,000 Go developers.<br><code>- me</code></p></blockquote><p>50万Go程序员会用他们的时间做些什么？好吧，显然，他们会写很多Go代码，实话实说，并不是所有的都是好的代码，有些会很糟糕。</p><p>请理解，我如此说并非残酷，但是，在这个房间里，每一个有着其他语言发展经验的人——你们来自的语言，来到Go——从你自己的经验中知道，这个预言有一点是真的。</p><blockquote><p>Within C++, there is a much smaller and cleaner language struggling to get out.<br><code>– Bjarne Stroustrup, The Design and Evolution of C++</code></p></blockquote><p>所有的程序员都有机会让我们的语言成功，依靠我们的集体能力，不要把人们开始谈论Go的事情弄得一团糟，就像他们今天对C++的笑话一样。</p><p>嘲弄其他语言的叙述过于冗长、冗长和过于复杂，总有一天会转向GO，我不想看到这种情况发生，所以我有一个请求。</p><p>Go程序员需要少谈框架，多谈设计。我们需要停止不惜一切代价关注性能，转而全力以赴地专注于重用。</p><p>我想看到的是人们在谈论如何使用我们今天使用的语言，无论其选择和限制，设计解决方案和解决实际问题。</p><p>我想听到的是人们在谈论如何以精心设计，解耦，重用，最重要的是响应变化的方式设计Go程序。</p><h3 id="…-one-more-thing"><a href="#…-one-more-thing" class="headerlink" title="… one more thing"></a>… one more thing</h3><p>今天在座的各位都能听到来自众多演讲者的演讲，这太好了，但事实是，无论这次会议规模有多大，与Go生命周期中使用Go的人数相比，我们只是一小部分。</p><p>因此，我们需要告诉世界上其他地方应该如何编写好软件。优秀的软件，可组合的软件，易于更改的软件，并向他们展示如何使用Go进行更改。从你开始。</p><p>我希望你开始谈论设计，也许使用我在这里提出的一些想法，希望你能做自己的研究，并将这些想法应用到你的项目中。那我想要你：</p><ul><li>写一篇关于设计的博客文章。</li><li>教一个关于设计的workshop。</li><li>写一本关于你学到的东西的书。</li><li>明年再回到这个会议，谈谈你取得的成就。</li></ul><p>因为通过做这些事情，我们可以建立一种Go开发人员的文化，他们关心设计用于持久的程序。</p><p>谢谢。</p><p><em>原文：<a href="https://dave.cheney.net/2016/08/20/solid-go-design" target="_blank" rel="noopener">SOLID Go Design</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Code-review&quot;&gt;&lt;a href=&quot;#Code-review&quot; class=&quot;headerlink&quot; title=&quot;Code review&quot;&gt;&lt;/a&gt;Code review&lt;/h3&gt;&lt;p&gt;在座的各位有谁把 code review 作为日常工作的一部分？【整
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="OOP" scheme="https://www.cyningsun.com/tag/OOP/"/>
    
  </entry>
  
  <entry>
    <title>译 | Prefer table driven tests</title>
    <link href="https://www.cyningsun.com/07-24-2019/prefer-table-driven-tests-cn.html"/>
    <id>https://www.cyningsun.com/07-24-2019/prefer-table-driven-tests-cn.html</id>
    <published>2019-07-23T16:00:00.000Z</published>
    <updated>2020-02-03T06:53:29.640Z</updated>
    
    <content type="html"><![CDATA[<p>我是测试的忠实粉丝，特别是<a href="https://dave.cheney.net/2019/04/03/absolute-unit-test" target="_blank" rel="noopener">单元测试</a>和TDD（当然前提是， <a href="https://www.youtube.com/watch?v=EZ05e7EMOLM" target="_blank" rel="noopener">恰当的做好</a> ）。 围绕Go项目的一种实践是 <code>table driven test</code> 方法。 这篇文章探讨了编写 <code>table driven test</code> 的方式和原因。</p><p>假设我们有一个分割字符串的函数：</p><pre><code class="hljs go"><span class="hljs-comment">// Split slices s into all substrings separated by sep and  </span><span class="hljs-comment">// returns a slice of the substrings between those separators.  </span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Split</span><span class="hljs-params">(s, sep <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">string</span></span> &#123;      <span class="hljs-keyword">var</span> result []<span class="hljs-keyword">string</span>      i := strings.Index(s, sep)      <span class="hljs-keyword">for</span> i &gt; <span class="hljs-number">-1</span> &#123;          result = <span class="hljs-built_in">append</span>(result, s[:i])          s = s[i+<span class="hljs-built_in">len</span>(sep):]          i = strings.Index(s, sep)      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-built_in">append</span>(result, s)  &#125;</code></pre><p>在Go中，单元测试只是常规的Go函数（有一些规则），所以我们在同一目录的文件中，使用相同的包名 <code>strings</code>，开始为这个函数编写一个单元测试。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> split  <span class="hljs-keyword">import</span> (      <span class="hljs-string">"reflect"</span>      <span class="hljs-string">"testing"</span>  )  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSplit</span><span class="hljs-params">(t *testing.T)</span></span> &#123;      got := Split(<span class="hljs-string">"a/b/c"</span>, <span class="hljs-string">"/"</span>)      want := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>&#125;      <span class="hljs-keyword">if</span> !reflect.DeepEqual(want, got) &#123;           t.Fatalf(<span class="hljs-string">"expected: %v, got: %v"</span>, want, got)      &#125;  &#125;</code></pre><p>测试只是常规的有一些规则的Go函数：</p><ol><li>测试函数的名称必须以Test开头。</li><li>测试函数必须采用*testing.T 类型的一个参数。 *testing.T 是测试包本身注入的类型，用于提供打印，跳过和失败测试的方法。</li></ol><p>在我们的测试中，我们使用一些输入调用 <code>Split</code>，然后将其与我们预期的结果进行比较。</p><h3 id="Code-coverage"><a href="#Code-coverage" class="headerlink" title="Code coverage"></a>Code coverage</h3><p>接下来的问题是，这个包的覆盖范围是什么？ 幸运的是，go tool 具有内置的分支覆盖。 我们可以像这样调用它：</p><pre><code class="hljs sh">% go <span class="hljs-built_in">test</span> -coverprofile=c.out PASS  coverage: 100.0% of statements  ok      split   0.010s</code></pre><p>结果表明，代码有100％的分支覆盖率，这并不奇怪，这段代码中只有一个分支。</p><p>如果我们想深入了解覆盖率报告，那么 go tool 有几个选项来打印覆盖率报告。 我们可以使用 <code>go tool cover -func</code> 来细分每个函数的覆盖率：</p><pre><code class="hljs sh">% **go tool cover -func=c.out**  split/split.go:8:       Split          100.0%  total:                  (statements)   100.0%</code></pre><p>如果在该软件包中只有一个功能，并不足令人兴奋，但我相信你会发现更多令人兴奋的软件包来测试。</p><h4 id="Spray-some-bashrc-on-that"><a href="#Spray-some-bashrc-on-that" class="headerlink" title="Spray some .bashrc on that"></a>Spray some .bashrc on that</h4><p>这两个命令对我来说非常有用，因此我有一个shell alias，它可以一个命令运行测试覆盖率并得到报告：</p><pre><code class="hljs sh"><span class="hljs-function"><span class="hljs-title">cover</span></span> () &#123;      <span class="hljs-built_in">local</span> t=$(mktemp -t cover)      go <span class="hljs-built_in">test</span> <span class="hljs-variable">$COVERFLAGS</span> -coverprofile=<span class="hljs-variable">$t</span> <span class="hljs-variable">$@</span> \          &amp;&amp; go tool cover -func=<span class="hljs-variable">$t</span> \          &amp;&amp; unlink <span class="hljs-variable">$t</span>  &#125;</code></pre><h3 id="Going-beyond-100-coverage"><a href="#Going-beyond-100-coverage" class="headerlink" title="Going beyond 100% coverage"></a>Going beyond 100% coverage</h3><p>我们编写了一个测试用例，获得了100％的覆盖率，但这并不是故事的结尾。 我们有很好的分支覆盖，但我们可能需要测试一些边界条件。 例如，如果我们尝试将使用逗号分割字符串会发生什么？</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSplitWrongSep</span><span class="hljs-params">(t *testing.T)</span></span> &#123;      got := Split(<span class="hljs-string">"a/b/c"</span>, <span class="hljs-string">","</span>)      want := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"a/b/c"</span>&#125;      <span class="hljs-keyword">if</span> !reflect.DeepEqual(want, got) &#123;          t.Fatalf(<span class="hljs-string">"expected: %v, got: %v"</span>, want, got)      &#125;  &#125;</code></pre><p>抑或，如果源字符串中没有分隔符会发生什么？</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSplitNoSep</span><span class="hljs-params">(t *testing.T)</span></span> &#123;      got := Split(<span class="hljs-string">"abc"</span>, <span class="hljs-string">"/"</span>)      want := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"abc"</span>&#125;      <span class="hljs-keyword">if</span> !reflect.DeepEqual(want, got) &#123;          t.Fatalf(<span class="hljs-string">"expected: %v, got: %v"</span>, want, got)      &#125;  &#125;</code></pre><p>我们开始构建一组运行边界条件的测试用例。 这相当不错。</p><h3 id="Introducing-table-driven-tests"><a href="#Introducing-table-driven-tests" class="headerlink" title="Introducing table driven tests"></a>Introducing table driven tests</h3><p>然而，我们的测试中有很多重复。 对于每个测试用例，只有输入，预期输出和测试用例的名称发生变化。 其他一切都是样板。 我们想要设置所有的输入和预期输出，感受它们在单个测试套件的效果。 这是引入 table driven test 的好时机。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSplit</span><span class="hljs-params">(t *testing.T)</span></span> &#123;      <span class="hljs-keyword">type</span> test <span class="hljs-keyword">struct</span> &#123;          input <span class="hljs-keyword">string</span>          sep   <span class="hljs-keyword">string</span>          want  []<span class="hljs-keyword">string</span>      &#125;      tests := []test&#123;          &#123;input: <span class="hljs-string">"a/b/c"</span>, sep: <span class="hljs-string">"/"</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>&#125;&#125;,          &#123;input: <span class="hljs-string">"a/b/c"</span>, sep: <span class="hljs-string">","</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"a/b/c"</span>&#125;&#125;,          &#123;input: <span class="hljs-string">"abc"</span>, sep: <span class="hljs-string">"/"</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"abc"</span>&#125;&#125;,      &#125;      <span class="hljs-keyword">for</span> _, tc := <span class="hljs-keyword">range</span> tests &#123;          got := Split(tc.input, tc.sep)          <span class="hljs-keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;              t.Fatalf(<span class="hljs-string">"expected: %v, got: %v"</span>, tc.want, got)          &#125;      &#125;  &#125;</code></pre><p>我们声明了一个结构来保存我们的测试输入和预期输出。 这是我们的表。<code>tests</code> 结构通常是局部声明，因为我们希望将此名称重用于此包中的其他测试。</p><p>实际上，我们甚至不需要给类型命名，我们可以使用匿名结构字面值来减少样板文件，如下所示：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSplit</span><span class="hljs-params">(t *testing.T)</span></span> &#123;      tests := []<span class="hljs-keyword">struct</span> &#123;          input <span class="hljs-keyword">string</span>          sep   <span class="hljs-keyword">string</span>          want  []<span class="hljs-keyword">string</span>      &#125;&#123;          &#123;input: <span class="hljs-string">"a/b/c"</span>, sep: <span class="hljs-string">"/"</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>&#125;&#125;,          &#123;input: <span class="hljs-string">"a/b/c"</span>, sep: <span class="hljs-string">","</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"a/b/c"</span>&#125;&#125;,          &#123;input: <span class="hljs-string">"abc"</span>, sep: <span class="hljs-string">"/"</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"abc"</span>&#125;&#125;,      &#125;       <span class="hljs-keyword">for</span> _, tc := <span class="hljs-keyword">range</span> tests &#123;          got := Split(tc.input, tc.sep)          <span class="hljs-keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;              t.Fatalf(<span class="hljs-string">"expected: %v, got: %v"</span>, tc.want, got)          &#125;      &#125;  &#125;</code></pre><p>现在，添加一个新的测试是直截了当的事情; 只需在 <code>tests</code> 结构中添加另一行。 例如，如果我们的输入字符串有一个尾随分隔符会发生什么？</p><pre><code class="hljs sh">&#123;input: <span class="hljs-string">"a/b/c"</span>, sep: <span class="hljs-string">"/"</span>, want: []string&#123;<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>&#125;&#125;,  &#123;input: <span class="hljs-string">"a/b/c"</span>, sep: <span class="hljs-string">","</span>, want: []string&#123;<span class="hljs-string">"a/b/c"</span>&#125;&#125;,  &#123;input: <span class="hljs-string">"abc"</span>, sep: <span class="hljs-string">"/"</span>, want: []string&#123;<span class="hljs-string">"abc"</span>&#125;&#125;,  **&#123;input: <span class="hljs-string">"a/b/c/"</span>, sep: <span class="hljs-string">"/"</span>, want: []string&#123;<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>&#125;&#125;, // trailing sep**</code></pre><p>但是，当我们运行 <code>go test</code>，我们得到了</p><pre><code class="hljs sh">% go <span class="hljs-built_in">test</span>--- FAIL: TestSplit (0.00s)      split_test.go:24: expected: [a b c], got: [a b c ]</code></pre><p>抛开测试失败，有一些问题需要讨论。</p><p>第一种，将每个测试从函数重写到表中的一行，我们已经丢失了失败测试的名称。 我们在测试文件中添加了一个注释来强调这种情况，但我们无法在 <code>go test</code> 输出中访问该注释。</p><p>有几种方法可以解决这个问题。 你会在Go代码库中看到混合风格的使用，因为table testing的习惯用法随着人们对该类型的不断试验而不断发展。</p><h3 id="Enumerating-test-cases"><a href="#Enumerating-test-cases" class="headerlink" title="Enumerating test cases"></a>Enumerating test cases</h3><p>由于测试存储在 slice 中，我们可以在失败消息中打印出测试用例的索引：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSplit</span><span class="hljs-params">(t *testing.T)</span></span> &#123;      tests := []<span class="hljs-keyword">struct</span> &#123;          input <span class="hljs-keyword">string</span>          sep . <span class="hljs-keyword">string</span>          want  []<span class="hljs-keyword">string</span>      &#125;&#123;          &#123;input: <span class="hljs-string">"a/b/c"</span>, sep: <span class="hljs-string">"/"</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>&#125;&#125;,          &#123;input: <span class="hljs-string">"a/b/c"</span>, sep: <span class="hljs-string">","</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"a/b/c"</span>&#125;&#125;,          &#123;input: <span class="hljs-string">"abc"</span>, sep: <span class="hljs-string">"/"</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"abc"</span>&#125;&#125;,          &#123;input: <span class="hljs-string">"a/b/c/"</span>, sep: <span class="hljs-string">"/"</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>&#125;&#125;,      &#125;      <span class="hljs-keyword">for</span> i, tc := <span class="hljs-keyword">range</span> tests &#123;          got := Split(tc.input, tc.sep)          <span class="hljs-keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;              t.Fatalf(<span class="hljs-string">"**test %d:** expected: %v, got: %v"</span>, **i+<span class="hljs-number">1</span>**, tc.want, got)          &#125;      &#125;  &#125;</code></pre><p>现在，当我们运行 <code>go test</code> 我们得到了这个：</p><pre><code class="hljs sh">% go <span class="hljs-built_in">test</span>  --- FAIL: TestSplit (0.00s)      split_test.go:24: **<span class="hljs-built_in">test</span> 4:** expected: [a b c], got: [a b c ]</code></pre><p>这样好了一些。 现在我们知道第四个测试失败了，尽管我们不得不做了一点点捏造，因为 slice 索引和范围迭代是从 0 开始的。 这要求您的测试用例保持一致; 如果有些人从 0 开始报告而其他人使用 1 开始报告，那将会令人困惑。 并且，如果测试用例列表很长，则可能很难数大括号以确切地确定第4个测试用例由哪些结构构成。</p><h3 id="Give-your-test-cases-names"><a href="#Give-your-test-cases-names" class="headerlink" title="Give your test cases names"></a>Give your test cases names</h3><p>另一种常见模式是在测试结构中包含名称字段。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSplit</span><span class="hljs-params">(t *testing.T)</span></span> &#123;      tests := []<span class="hljs-keyword">struct</span> &#123;          **name  <span class="hljs-keyword">string</span>**          input <span class="hljs-keyword">string</span>          sep   <span class="hljs-keyword">string</span>          want  []<span class="hljs-keyword">string</span>      &#125;&#123;          &#123;name: <span class="hljs-string">"simple"</span>, input: <span class="hljs-string">"a/b/c"</span>, sep: <span class="hljs-string">"/"</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>&#125;&#125;,          &#123;name: <span class="hljs-string">"wrong sep"</span>, input: <span class="hljs-string">"a/b/c"</span>, sep: <span class="hljs-string">","</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"a/b/c"</span>&#125;&#125;,          &#123;name: <span class="hljs-string">"no sep"</span>, input: <span class="hljs-string">"abc"</span>, sep: <span class="hljs-string">"/"</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"abc"</span>&#125;&#125;,          &#123;name: <span class="hljs-string">"trailing sep"</span>, input: <span class="hljs-string">"a/b/c/"</span>, sep: <span class="hljs-string">"/"</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>&#125;&#125;,      &#125;      <span class="hljs-keyword">for</span> _, tc := <span class="hljs-keyword">range</span> tests &#123;          got := Split(tc.input, tc.sep)          <span class="hljs-keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;              t.Fatalf(<span class="hljs-string">"**%s:** expected: %v, got: %v"</span>, **tc.name**, tc.want, got)          &#125;      &#125;  &#125;</code></pre><p>现在，当测试失败时，我们有一个描述性的名称，描述正在进行的测试。 我们不再需要尝试从输出中找出它 —— 现在还有一个字符串，我们可以搜索。</p><pre><code class="hljs sh">% go <span class="hljs-built_in">test</span> --- FAIL: TestSplit (0.00s)      split_test.go:25: **trailing sep**: expected: [a b c], got: [a b c ]</code></pre><p>我们可以使用 map 字面值语法来更详细地说明这一点：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSplit</span><span class="hljs-params">(t *testing.T)</span></span> &#123;      tests := **<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">struct</span> &#123;          input <span class="hljs-keyword">string</span>          sep   <span class="hljs-keyword">string</span>          want  []<span class="hljs-keyword">string</span>      &#125;**&#123;           <span class="hljs-string">"simple"</span>:       &#123;input: <span class="hljs-string">"a/b/c"</span>, sep: <span class="hljs-string">"/"</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>&#125;&#125;,           <span class="hljs-string">"wrong sep"</span>:    &#123;input: <span class="hljs-string">"a/b/c"</span>, sep: <span class="hljs-string">","</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"a/b/c"</span>&#125;&#125;,          <span class="hljs-string">"no sep"</span>:       &#123;input: <span class="hljs-string">"abc"</span>, sep: <span class="hljs-string">"/"</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"abc"</span>&#125;&#125;,          <span class="hljs-string">"trailing sep"</span>: &#123;input: <span class="hljs-string">"a/b/c/"</span>, sep: <span class="hljs-string">"/"</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>&#125;&#125;,      &#125;      <span class="hljs-keyword">for</span> name, tc := <span class="hljs-keyword">range</span> tests &#123;          got := Split(tc.input, tc.sep)          <span class="hljs-keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;              t.Fatalf(<span class="hljs-string">"**%s:** expected: %v, got: %v"</span>, **name**, tc.want, got)          &#125;      &#125;  &#125;</code></pre><p>使用 map 字面值语法，我们不再将测试用例定义为结构的 slice，而是作为测试名到测试结构的 map。 使用可能会提高测试效果的 map 还有一个好处。</p><p>map 迭代顺序是 <em>undefined</em> <a href="https://golang.org/ref/spec#For_statements" target="_blank" rel="noopener" title="请不要给我发电子邮件，认为地图迭代顺序是random. 事实并非如此."><sup>1</sup></a> 这意味着每次运行 <code>go test</code>，我们的测试都可能以不同的顺序运行。</p><p>这对于发现在按语句顺序运行时测试通过的条件非常有用，但不适用于其他情况。如果您发现这种情况发生了，您可能是有一些全局状态，被一次测试改变，而后续测试取决于该修改。</p><h3 id="Introducing-sub-tests"><a href="#Introducing-sub-tests" class="headerlink" title="Introducing sub tests"></a>Introducing sub tests</h3><p>在我们修复失败的测试之前，还有一些其他问题需要在我们的 table driven test 工具中解决。</p><p>第一，我们在其中一个测试用例失败时调用t.Fatalf。 这意味着在第一次失败的测试用例之后我们停止测试其他情况。 因为测试用例是以未定义的顺序运行的，所以如果测试失败，那么知道它是唯一的失败还是只是第一次失败会更好。</p><p>如果我们努力将每个测试用例写出来作为测试包的函数，测试包将为我们做到这一点，但是这很冗长。 好消息是，自从Go 1.7添加了一项新功能，让我们可以轻松地进行 table driven test。 它们被称为 <a href="https://blog.golang.org/subtests" target="_blank" rel="noopener">sub tests</a>。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSplit</span><span class="hljs-params">(t *testing.T)</span></span> &#123;      tests := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">struct</span> &#123;          input <span class="hljs-keyword">string</span>          sep   <span class="hljs-keyword">string</span>          want  []<span class="hljs-keyword">string</span>      &#125;&#123;          <span class="hljs-string">"simple"</span>:       &#123;input: <span class="hljs-string">"a/b/c"</span>, sep: <span class="hljs-string">"/"</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>&#125;&#125;,          <span class="hljs-string">"wrong sep"</span>:    &#123;input: <span class="hljs-string">"a/b/c"</span>, sep: <span class="hljs-string">","</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"a/b/c"</span>&#125;&#125;,          <span class="hljs-string">"no sep"</span>:       &#123;input: <span class="hljs-string">"abc"</span>, sep: <span class="hljs-string">"/"</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"abc"</span>&#125;&#125;,          <span class="hljs-string">"trailing sep"</span>: &#123;input: <span class="hljs-string">"a/b/c/"</span>, sep: <span class="hljs-string">"/"</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>&#125;&#125;,      &#125;      <span class="hljs-keyword">for</span> name, tc := <span class="hljs-keyword">range</span> tests &#123;  **t.Run(name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;              got := Split(tc.input, tc.sep)              <span class="hljs-keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;                  t.Fatalf(<span class="hljs-string">"expected: %v, got: %v"</span>, tc.want, got)              &#125;          &#125;)**      &#125;  &#125;</code></pre><p>由于每个 sub test 现在都有一个名称，我们可以在任何测试运行中自动打印出该名称。</p><pre><code class="hljs sh">% go <span class="hljs-built_in">test</span> --- FAIL: TestSplit (0.00s)      --- FAIL: **TestSplit/trailing_sep** (0.00s)          split_test.go:25: expected: [a b c], got: [a b c ]</code></pre><p>每个 subtest 都是它自己的匿名函数，因此我们可以使用 <code>t.Fatalf</code>，<code>t.Skipf</code> 和所有其他 <code>testing.T</code> helper，同时保留table driven test 的紧凑性。</p><h4 id="Individual-sub-test-cases-can-be-executed-directly"><a href="#Individual-sub-test-cases-can-be-executed-directly" class="headerlink" title="Individual sub test cases can be executed directly"></a>Individual sub test cases can be executed directly</h4><p>由于 sub tests 具有名称，因此您可以使用 <code>go test -run</code> flag 按名称运行一系列 sub tests。</p><pre><code class="hljs sh">% **go <span class="hljs-built_in">test</span> -run=.*/trailing -v**  === RUN   TestSplit  === RUN   TestSplit/trailing_sep  --- FAIL: TestSplit (0.00s)      --- FAIL: TestSplit/trailing_sep (0.00s)          split_test.go:25: expected: [a b c], got: [a b c ]</code></pre><h3 id="Comparing-what-we-got-with-what-we-wanted"><a href="#Comparing-what-we-got-with-what-we-wanted" class="headerlink" title="Comparing what we got with what we wanted"></a>Comparing what we got with what we wanted</h3><p>现在我们已准备好修复测试用例。 我们来看看错误。</p><pre><code class="hljs sh">--- FAIL: TestSplit (0.00s)      --- FAIL: TestSplit/trailing_sep (0.00s)          split_test.go:25: expected: [a b c], got: [a b c ]</code></pre><p>你能发现问题吗？ 很明显，切片是不同的，这就是 <code>reflect.DeepEqual</code> 令人烦恼的原因。 但是要找到实际的差异并不容易，你必须发现在 <code>c</code> 之后额外的空格。 在这个简单的例子中，这可能看起来很简单，但是当你比较两个复杂的深层嵌套的gRPC结构时，它是任何东西（不一定是空格）。</p><p>如果我们切换到 <code>%#v</code> 语法以将值视为Go（ish）声明，则可以改进输出：</p><pre><code class="hljs go">got := Split(tc.input, tc.sep)  <span class="hljs-keyword">if</span> !reflect.DeepEqual(tc.want, got) &#123;      t.Fatalf(<span class="hljs-string">"**expected: %#v, got: %#v**"</span>, tc.want, got)  &#125;</code></pre><p>现在，当我们运行测试时，很明显问题在于 slice 中有一个额外的空白元素。</p><pre><code class="hljs sh">% go <span class="hljs-built_in">test</span> --- FAIL: TestSplit (0.00s)      --- FAIL: TestSplit/trailing_sep (0.00s)          split_test.go:25: **expected: []string&#123;<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>&#125;, got: []string&#123;<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">""</span>&#125;**</code></pre><p>但是在我们开始修复测试失败之前，我想多谈一点关于选择正确的方法来呈现测试失败的问题。我们的 <code>Split</code> 函数很简单，它接受一个原始的字符串并返回一段字符串，但是如果它处理结构，或者更糟的，指向结构的指针呢？</p><p>下面是一个例子，其中 <code>%v</code> 不起作用：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      <span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;          I <span class="hljs-keyword">int</span>      &#125;      x := []*T&#123; &#123;<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>&#125; &#125;    y := []*T&#123; &#123;<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">4</span>&#125; &#125;    fmt.Printf(<span class="hljs-string">"%v %v\n"</span>, x, y)      fmt.Printf(<span class="hljs-string">"%#v %#v\n"</span>, x, y)  &#125;</code></pre><p>第一个 <code>fmt.Printf</code> 打印毫无帮助但符合预期的 addresses slice；<code>[0xc000096000 0xc000096008 0xc000096010] [0xc000096018 0xc000096020 0xc000096028]</code>。 但是，我们的 <code>%#v</code> 并没有做任何改进。打印一个 addresses slice 强制转换为 <code>*main.T</code>；<code>[]*main.T{(*main.T)(0xc000096000), (*main.T)(0xc000096008), (*main.T)(0xc000096010)} []*main.T{(*main.T)(0xc000096018), (*main.T)(0xc000096020), (*main.T)(0xc000096028)}</code></p><p>由于使用任何 <code>fmt.Printf</code> verb 的局限性，我想从Google引入 <a href="https://github.com/google/go-cmp" target="_blank" rel="noopener">go-cmp</a> 库。</p><p>cmp 库的目标是专门比较两个值。这类似于 <code>reflect.DeepEqual</code>，但它有更多的功能。所以，使用cmp pacakge，你可以编写如下：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      <span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;          I <span class="hljs-keyword">int</span>      &#125;      x := []*T&#123; &#123;<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>&#125; &#125;    y := []*T&#123; &#123;<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">4</span>&#125; &#125;    fmt.Println(cmp.Equal(x, y)) **<span class="hljs-comment">// false**  </span>&#125;</code></pre><p>但是对于我们的测试函数来说，更有用的是 <code>cmp.Diff</code> 函数，它将产生一个文本描述，递归地描述两个值之间的区别。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;      <span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;          I <span class="hljs-keyword">int</span>      &#125;      x := []*T&#123; &#123;<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>&#125; &#125;    y := []*T&#123; &#123;<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">4</span>&#125; &#125;    diff := cmp.Diff(x, y)      fmt.Printf(diff)  &#125;</code></pre><p>取而代之输出：</p><pre><code class="hljs sh">% go run  &#123;[]*main.T&#125;[2].I:           -: 3           +: 4</code></pre><p>以上表明，在类型 <code>T</code> 的 slice 第二个元素，<code>I</code> 字段应该是3，但实际上是4。</p><p>综上所述，我们进行了 table driven go-cmp test</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSplit</span><span class="hljs-params">(t *testing.T)</span></span> &#123;      tests := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">struct</span> &#123;          input <span class="hljs-keyword">string</span>          sep   <span class="hljs-keyword">string</span>          want  []<span class="hljs-keyword">string</span>      &#125;&#123;          <span class="hljs-string">"simple"</span>:       &#123;input: <span class="hljs-string">"a/b/c"</span>, sep: <span class="hljs-string">"/"</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>&#125;&#125;,          <span class="hljs-string">"wrong sep"</span>:    &#123;input: <span class="hljs-string">"a/b/c"</span>, sep: <span class="hljs-string">","</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"a/b/c"</span>&#125;&#125;,          <span class="hljs-string">"no sep"</span>:       &#123;input: <span class="hljs-string">"abc"</span>, sep: <span class="hljs-string">"/"</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"abc"</span>&#125;&#125;,          <span class="hljs-string">"trailing sep"</span>: &#123;input: <span class="hljs-string">"a/b/c/"</span>, sep: <span class="hljs-string">"/"</span>, want: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>&#125;&#125;,      &#125;      <span class="hljs-keyword">for</span> name, tc := <span class="hljs-keyword">range</span> tests &#123;          t.Run(name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;              got := Split(tc.input, tc.sep)  **diff := cmp.Diff(tc.want, got)              <span class="hljs-keyword">if</span> diff != <span class="hljs-string">""</span> &#123;                  t.Fatalf(diff)              &#125;**          &#125;)      &#125;  &#125;</code></pre><p>运行，我们得到</p><pre><code class="hljs sh">% go <span class="hljs-built_in">test</span>  --- FAIL: TestSplit (0.00s)      --- FAIL: TestSplit/trailing_sep (0.00s)          split_test.go:27: &#123;[]string&#125;[?-&gt;3]:                  -: &lt;non-existent&gt;                  +: <span class="hljs-string">""</span>  FAIL  <span class="hljs-built_in">exit</span> status 1  FAIL    split   0.006s</code></pre><p>使用 <code>cmp.Diff</code> 我们的测试工具不仅仅是告诉我们，我们得到的和想要的是不同的。我们的测试告诉我们，字符串的长度是不同的，结构中的第三个索引不应该存在，但是实际输出得到一个空字符串，“”。从此开始，修复测试失败是直接了当的。</p><p><em>原文：<a href="https://dave.cheney.net/2019/05/07/prefer-table-driven-tests" target="_blank" rel="noopener">https://dave.cheney.net/2019/05/07/prefer-table-driven-tests</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我是测试的忠实粉丝，特别是&lt;a href=&quot;https://dave.cheney.net/2019/04/03/absolute-unit-test&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;单元测试&lt;/a&gt;和TDD（当然前提是， &lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Test" scheme="https://www.cyningsun.com/tag/Test/"/>
    
  </entry>
  
  <entry>
    <title>译 | Diagnostics</title>
    <link href="https://www.cyningsun.com/07-21-2019/go-diagnostics-cn.html"/>
    <id>https://www.cyningsun.com/07-21-2019/go-diagnostics-cn.html</id>
    <published>2019-07-20T16:00:00.000Z</published>
    <updated>2020-02-03T06:53:29.639Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Go生态系统提供了大量API和工具来诊断Go程序中的逻辑和性能问题。 此页面总结了可用的工具，并帮助Go用户针对他们的特定问题选择正确的工具。</p><p>诊断解决方案可分为以下几组：</p><ul><li><strong>Profiling</strong>：Profiling 工具分析Go程序的复杂性和成本，例如其内存使用情况和频繁调用的函数，以识别Go程序的昂贵部分。</li><li><strong>Tracing</strong>：Tracing 是一种检测代码的方法，用于分析调用或用户请求的整个生命周期中的延迟。 Traces 提供了每个组件对系统总体延迟影响的概览。 Traces 可以跨越多个Go进程。</li><li><strong>Debugging</strong>: Debugging 允许我们暂停Go程序并检查其执行。可以通过 debugging 验证程序状态和流程。</li><li><strong>Runtime statistics and events</strong>： 对运行时统计信息、事件的收集和分析提供了Go程序运行状况的高层次概览。 指标的尖峰/下降有助于我们识别吞吐量，利用率和性能的变化。</li></ul><blockquote><p>注意：某些诊断工具可能会相互干扰。 例如，精确的 memory profiling 会扭曲 CPU profiles，而goroutine blocking profiling 会影响 scheduler trace。 隔离使用工具可获得更精确的信息。</p></blockquote><h3 id="Profiling"><a href="#Profiling" class="headerlink" title="Profiling"></a>Profiling</h3><p>Profiling 对于识别昂贵或经常调用的代码段很有用。 Go runtime 以 <a href="https://github.com/google/pprof/blob/master/doc/README.md" target="_blank" rel="noopener">pprof 可视化工具</a>所期望的格式提供 <a href="https://golang.org/pkg/runtime/pprof/" target="_blank" rel="noopener">profiling data</a>。 在测试期间可以通过 <code>go test</code> 或 <a href="https://golang.org/pkg/net/http/pprof/" target="_blank" rel="noopener">net/http/pprof</a> 包提供的 endpoints 收集 profiling data。 用户需要收集 profiling data 并使用 pprof 工具来过滤和可视化顶部代码路径。</p><p><a href="https://golang.org/pkg/runtime/pprof" target="_blank" rel="noopener">runtime/pprof</a> 包提供的预定义 profiles：</p><ul><li><strong>cpu</strong>: CPU profile 确定程序在活跃的消耗CPU周期（而不是在睡眠或等待I/O时）花费时间的位置。</li><li><strong>heap</strong>: Heap profile  报告内存分配样本; 用于监视当前和历史内存使用情况，并检查内存泄漏。</li><li><strong>threadcreate</strong>: Thread creation profile 报告程序中导致创建新OS线程的部分。</li><li><strong>goroutine</strong>: Goroutine profile 报告所有当前 goroutines 的 stack traces。</li><li><strong>block</strong>: Block profile 显示goroutine阻止等待同步原语（包括 timer channels）的位置。 Block profile 默认情况下未开启; 使用 <code>runtime.SetBlockProfileRate</code> 启用。</li><li><strong>mutex</strong>: Mutex profile 报告锁竞争。 如果您认为由于互斥竞争而未充分利用您的CPU，请使用此 profile。 Mutex profile 默认情况下未开启，请参阅 <code>runtime.SetMutexProfileFraction</code> 启用。</li></ul><p><strong>我可以使用其他哪些 profilers 来介绍Go程序？</strong></p><p>在Linux上，<a href="https://perf.wiki.kernel.org/index.php/Tutorial" target="_blank" rel="noopener">perf tools</a> 可用于分析Go程序。 Perf 可以 profile 和展开 cgo/SWIG 代码和内核，因此深入了解native/内核性能瓶颈非常有用。 在macOS上， <a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/" target="_blank" rel="noopener">Instruments</a> 套件可以用来 profile Go 程序。</p><p><strong>我可以 profile 我的生产环境的服务吗？</strong></p><p>是的。 在生产环境中对程序进行 profile 是安全的，但启用某些 profiles（例如：CPU profile）会增加消耗。 您应该会看到性能降级。 在生产中打开探测器之前，可以通过测量 profiler 的开销来估计性能损失。</p><p>您可能希望定期分析您的生产服务。 特别是在具有单进程多副本的系统中，定期选择随机副本是安全的选择。 选择一个生产服务，  每隔Y秒 profile X秒并保存结果以进行可视化和分析; 然后定期重复。 可以 手动/自动 检查结果以发现问题。 profiles 收集可能会相互干扰，因此建议一次只收集一个 profile。</p><p><strong>可视化分析数据的最佳方法是什么？</strong></p><p>Go tools使用 <a href="https://github.com/google/pprof/blob/master/doc/README.md" target="_blank" rel="noopener"><code>go tool pprof</code></a> 提供文本，图形和 <a href="http://valgrind.org/docs/manual/cl-manual.html" target="_blank" rel="noopener">callgrind</a> 可视化的 profile data。 阅读 <a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="noopener">Profiling Go programs</a> 以查看它们的实际使用。</p><p><img src="https://storage.googleapis.com/golangorg-assets/pprof-text.png" alt="738fb1d54bd36c74ac3c98052ed7db24.png"></p><blockquote><p>文本方式查看最大的消耗的调用</p></blockquote><p><img src="https://storage.googleapis.com/golangorg-assets/pprof-dot.png" alt="9271bb2658eb3b3fb8bf034d2675f4d2.png"></p><blockquote><p>图片方式可视化最大的消耗的调用</p></blockquote><p>Weblist视图在HTML页面中逐行显示源代码最大消耗的部分。 在以下示例中，530ms用于 <code>runtime.concatstrings</code>，每行的消耗显示在列表中。</p><p><img src="https://storage.googleapis.com/golangorg-assets/pprof-weblist.png" alt="18b069d57a4f697cc580ea69478dea77.png"></p><blockquote><p>weblist方式可视化最大的消耗的调用</p></blockquote><p>另一种可视化轮廓数据的方法是<a href="http://www.brendangregg.com/flamegraphs.html" target="_blank" rel="noopener">火焰图</a>。 火焰图允许您在特定的祖先路径中移动，因此您可以放大/缩小特定的代码段。<a href="https://github.com/google/pprof" target="_blank" rel="noopener">upstream pprof</a>支持火焰图。</p><p><img src="https://storage.googleapis.com/golangorg-assets/flame.png" alt="77471e15e5c54e282982377b454320c5.png"></p><blockquote><p>火焰图方式可视化以发现最昂贵的代码路径</p></blockquote><p><strong>我是否仅限于内置profiles？</strong></p><p>除了 runtime 提供的工具之外，Go用户还可以通过 <a href="https://golang.org/pkg/runtime/pprof/#Profile" target="_blank" rel="noopener">pprof.Profile</a> 创建自定义 profiles，并使用现有工具对其进行检查。</p><p><strong>我可以在不同的路径和端口上提供 profiler handlers(/debug/pprof/…) 吗？</strong></p><p>是的。 默认情况下， <code>net/http/pprof</code> 包将其 handlers 注册到默认的mux，但您也可以使用从包中导出的handler net/http/pprof注册它们。</p><p>例如，以下示例将在7777端口/custom_debug_path/profile上提供 pprof.Profile handler：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">"log"</span><span class="hljs-string">"net/http"</span><span class="hljs-string">"net/http/pprof"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;mux := http.NewServeMux()mux.HandleFunc(<span class="hljs-string">"/custom_debug_path/profile"</span>, pprof.Profile)log.Fatal(http.ListenAndServe(<span class="hljs-string">":7777"</span>, mux))&#125;</code></pre><h3 id="Tracing"><a href="#Tracing" class="headerlink" title="Tracing"></a>Tracing</h3><p>Tracing 是一种检测代码的方法，用于分析一系列调用的生命周期中的延迟。 Go提供 <a href="https://godoc.org/golang.org/x/net/trace" target="_blank" rel="noopener">golang.org/x/net/trace</a> 包作为每个Go节点的最小 tracing backend，并提供一个带有简单仪表板的最小检测库。 Go还提供了一个执行跟踪器来跟踪时间间隔内的 runtime events。</p><p>Tracing 使我们能够：</p><ul><li>检测和分析Go进程中应用程序延迟。</li><li>衡量一长串调用中特定调用的耗时。</li><li>弄清楚使用情况和性能改进点。 没有tracing数据，瓶颈并不总是显而易见。</li></ul><p>在单机系统中，从程序的构成模块收集诊断数据相对容易。 所有模块都位于一个进程中，并共享公共资源以报告日志，错误和其他诊断信息。一旦您的系统超出单个进程并开始变为分布式，跟踪从前端Web服务器到其所有后端的调用，直到将响应返回给用户，将变得更加困难。这就是分布式 tracing 在检测和分析生产系统方面发挥重要作用的地方。</p><p>分布式 tracing 是一种检测代码的方法，用于分析用户请求在整个生命周期中的延迟。 当系统分布式化，并且传统的分析和调试工具无法scale时，您可能希望使用分布式 tracing 工具来分析用户请求和RPC的性能。</p><p>分布式 tracing 使我们能够：</p><ul><li>检测和分析在大系统中的应用延迟。</li><li>跟踪用户请求生命周期内的所有RPC，并发现仅在生产中可见的集成问题。</li><li>找出可应用于我们系统的性能改进点。 在收集 tracing 数据之前，许多瓶颈并不明显。</li></ul><p>GO生态系统为每个跟踪系统提供了不同的分布式跟踪库和后端无关的跟踪库。</p><p><strong>有没有办法自动拦截每个函数调用并创建 tracing ？</strong></p><p>Go没有提供自动拦截每个函数调用和创建trace spans的方法。 您需要手动检测代码以创建，结束和注释 spans。</p><p><strong>我应该如何在Go库中传播 trace headers ？</strong></p><p>您可以在 <a href="https://golang.org/pkg/context#Context" target="_blank" rel="noopener"><code>context.Context</code></a> 传播trace标识符和标记。 目前行业中还没有 trace key 的规范和 trace headers 的通用表示。 每个tracing提供程序都负责在其Go库中提供传播工具。</p><p><strong>标准库或 runtime 中的其他低级事件可以包含在 trace 中吗？</strong></p><p>标准库和 runtime 试图公开几个额外的API来通知低级内部事件。 例如， <a href="https://golang.org/pkg/net/http/httptrace#ClientTrace" target="_blank" rel="noopener"><code>httptrace.ClientTrace</code></a> 提供API以跟踪传出请求生命周期中的低级事件。 目前正在努力从 runtime execution tracer 中检索低级运行时事件，并允许用户定义和记录其用户事件。</p><h3 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h3><p>Debugging 是识别程序错误行为的过程。调试器允许我们理解程序的执行流程和当前状态。有几种调试方式；本节只关注将调试器 attach 到程序和 core dump 调试。</p><p>GO用户主要使用以下调试器：</p><ul><li><a href="https://github.com/derekparker/delve" target="_blank" rel="noopener">Delve</a> ：Delve是Go编程语言的调试器。 它支持Go的 runtime 概念和内置类型。 Delve正试图成为Go程序的全功能可靠调试器。</li><li><a href="https://golang.org/doc/gdb" target="_blank" rel="noopener">GDB</a> ：Go通过标准Go编译器和 Gccgo 提供 GDB 支持。 堆栈管理、线程和运行时包含的方面与 GDB 执行模型有足够的不同，因此可能会使调试器难以理解。即使程序是使用 gccgo 编译的。 尽管GDB可用于调试Go程序，但它并不理想，可能会造成混乱。</li></ul><p><strong>调试器与 Go 程序的兼容性如何？</strong></p><p><code>gc</code> 编译器执行优化，例如函数内联和变量注册。 这些优化有时会使调试器调试更困难。 目前正在努力提高优化后的二进制文件的DWARF 信息的质量。 在这些改进可用之前，我们建议在构建正在调试的代码时禁用优化。 以下命令构建一个没有编译器优化的包：</p><pre><code class="hljs sh">$ go build -gcflags=all=<span class="hljs-string">"-N -l"</span></code></pre><p>作为改进工作的一部分，Go 1.10引入了一个新的编译器flag  <code>-dwarflocationlists</code>。 该标志使编译器添加位置列表，以帮助调试器使用优化后的二进制文件。 以下命令构建使用优化但包含 DWARF 位置列表的包：</p><pre><code class="hljs sh">$ go build -gcflags=<span class="hljs-string">"-dwarflocationlists=true"</span></code></pre><p><strong>推荐的用户界面调试器是什么？</strong></p><p>尽管 delve 和 gdb 都提供了 CLI，但大多数集成编辑器和IDE都提供了特定于调试的用户界面。</p><p><strong>是否可以使用Go程序进行事后调试？</strong></p><p>core dump 文件是包含正在运行的进程及其进程状态的 memory dump 文件。 它主要用于程序的事后调试，并了解它仍在程序运行时的状态。 这两种情况使 core dump 的调试成为一种良好的诊断工具，可用于事后分析和分析生产服务。 可以从Go程序获取core文件，并使用delve或gdb进行调试，请参阅 <a href="https://golang.org/wiki/CoreDumpDebugging" target="_blank" rel="noopener">core dump debugging</a> 页面以获取分步指南。</p><h3 id="Runtime-statistics-and-events"><a href="#Runtime-statistics-and-events" class="headerlink" title="Runtime statistics and events"></a>Runtime statistics and events</h3><p>runtime 为用户提供内部事件的统计信息和报告，以便在 runtime 级别诊断性能和利用率问题。</p><p>用户可以监控这些统计数据，以更好地了解Go程序的整体运行状况和性能。 一些经常监控的统计数据和状态：</p><ul><li><code>[runtime.ReadMemStats](https://golang.org/pkg/runtime/#ReadMemStats)</code> 报告与堆分配和垃圾回收相关的metrics。 内存统计信息对于监视进程正在消耗多少内存资源，进程是否可以很好地利用内存以及捕获内存泄漏非常有用。</li><li><code>[debug.ReadGCStats](https://golang.org/pkg/runtime/debug/#ReadGCStats)</code> 读取有关垃圾收集的统计信息。 查看有多少资源用于GC暂停非常有用。 它还报告垃圾收集器暂停和暂停时间百分比的 timeline。</li><li><code>[debug.Stack](https://golang.org/pkg/runtime/debug/#Stack)</code> 返回当前 stack trace。stack trace 有助于查看当前正在运行的 goroutine 数量，它们正在执行的操作，以及它们是否被阻塞。</li><li><code>[debug.WriteHeapDump](https://golang.org/pkg/runtime/debug/#WriteHeapDump)</code> 挂起所有 goroutine 的执行，并允许您将堆 dump 到文件中。 heap dump 是给定时间Go进程的内存快照。 它包含所有已分配的对象以及 goroutine，finalizers 等。</li><li><code>[runtime.NumGoroutine](https://golang.org/pkg/runtime#NumGoroutine)</code> 返回当前 goroutine 的数量。 可以监视该值以查看是否使用了足够的goroutine，或检测goroutine泄漏。</li></ul><h4 id="Execution-tracer"><a href="#Execution-tracer" class="headerlink" title="Execution tracer"></a>Execution tracer</h4><p>Go附带了一个runtime execution tracer，用于捕获各种运行时事件。 调度，系统调用，垃圾收集，堆大小和其他由 runtime 收集的事件，并可通过 go tool trace 进行可视化。 Execution tracer 是一种检测延迟和利用率问题的工具。 您可以检查CPU的使用情况，以及当网络或系统调用成为goroutines抢占的原因。</p><p>Tracer 使我们能够：</p><ul><li>了解你的 goroutines 如何执行。</li><li>了解一些核心 runtime 事件，例如GC运行。</li><li>识别并行化不足的执行。</li></ul><p>但是，识别热点（如分析内存过多或CPU使用率的原因）并不是很好用。 首先使用 profiling tools 来解决它们。</p><p><img src="https://storage.googleapis.com/golangorg-assets/tracer-lock.png" alt="229748672006e67fead3212695e267cc.png"></p><p>以上，go tool trace 可视化显示执行开始正常，然后它变得顺序化。 它表明可能存在共享资源的锁竞争导致的瓶颈。</p><p>请参阅 <a href="https://golang.org/cmd/trace/" target="_blank" rel="noopener"><code>go tool trace</code></a> 以收集和分析 runtime traces。</p><h4 id="GODEBUG"><a href="#GODEBUG" class="headerlink" title="GODEBUG"></a>GODEBUG</h4><p>如果相应地设置了 <a href="https://golang.org/pkg/runtime/#hdr-Environment_Variables" target="_blank" rel="noopener">GODEBUG</a> 环境变量，Runtime 也会发出事件和信息。</p><ul><li>GODEBUG=gctrace=1 在每个集合中打印垃圾收集器事件，总结收集的内存量和暂停的长度。</li><li>GODEBUG=schedtrace=X 每X毫秒打印一次调度事件。</li></ul><p>GODEBUG 环境变量可用于禁用标准库和 runtime 中 instruction set extensions 的使用。</p><ul><li>GODEBUG=cpu.all=off 禁用所有可选指令集扩展的使用。</li><li>GODEBUG=cpu.<em>extension</em>=off 禁止使用指定指令集扩展中的指令。 <blockquote><p>extension 是指令集扩展名的小写名称，例如 sse41 或 avx 。</p></blockquote></li></ul><p><em>原文：<a href="https://golang.org/doc/diagnostics.html" target="_blank" rel="noopener">https://golang.org/doc/diagnostics.html</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;Go生态系统提供了大量API和工具来诊断Go程序中的逻辑和性
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Profile" scheme="https://www.cyningsun.com/tag/Profile/"/>
    
  </entry>
  
  <entry>
    <title>译 | Profiling Go Programs</title>
    <link href="https://www.cyningsun.com/07-20-2019/profiling-go-programs-cn.html"/>
    <id>https://www.cyningsun.com/07-20-2019/profiling-go-programs-cn.html</id>
    <published>2019-07-19T16:00:00.000Z</published>
    <updated>2020-02-03T06:53:29.639Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在Scala Days 2011，Robert Hundt 发表了一篇名为 <a href="http://research.google.com/pubs/pub37122.html" target="_blank" rel="noopener">Loop Recognition in C++/Java/Go/Scala</a> 的论文。 该论文实现了一种特定的循环查找算法，例如您可以在C++，Go，Java，Scala编译器的流分析传递中使用，然后使用这些程序得到这些语言中典型性能问题的结论。该论文中的Go程序运行速度非常慢，使它成为演示的绝佳机会：如何使用Go的分析工具来实现慢速程序并使其更快。</p><p><em>通过使用Go的分析工具来识别和纠正特定的瓶颈，可以使Go loop finding程序运行速度提高一个数量级，并减少6倍的内存。</em></p><blockquote><p>更新：由于最近gcc中libstdc++优化，现在内存减少是3.7倍。</p></blockquote><p>Hundt的论文没有说明他使用的C++，Go，Java和Scala工具的版本。 在这篇博文中，我们将使用6g Go编译器的最新每周快照以及Ubuntu Natty发行版附带的g++版本。（我们不会使用Java或Scala，因为我们不擅长用这两种语言编写高效的程序，所以这种比较是不公平的。因为C++是论文中最快的语言，所以这里与C++的比较应该足够了。）</p><blockquote><p>更新：在这篇更新的帖子中，我们将使用amd64上Go编译器的最新开发快照以及2013年3月发布的最新版g++ - 4.8.0。</p></blockquote><pre><code class="hljs sh">$ go versiongo version devel +08d20469cc20 Tue Mar 26 08:27:18 2013 +0100 linux/amd64$ g++ --versiong++ (GCC) 4.8.0Copyright (C) 2013 Free Software Foundation, Inc....$</code></pre><p>程序运行在配备3.4GHz Core i7-2600 CPU 16 GB RAM的Gentoo Linux’s 3.8.4-gentoo内核的计算机上。 通过以下代码禁用了机器的CPU频率调整：</p><pre><code class="hljs sh">$ sudo bash<span class="hljs-comment"># for i in /sys/devices/system/cpu/cpu[0-7]</span><span class="hljs-keyword">do</span>    <span class="hljs-built_in">echo</span> performance &gt; <span class="hljs-variable">$i</span>/cpufreq/scaling_governor<span class="hljs-keyword">done</span><span class="hljs-comment">#</span></code></pre><p>我们采用 <a href="https://github.com/hundt98847/multi-language-bench" target="_blank" rel="noopener">Hundt’s benchmark programs</a> 的C++和Go部分，将每个程序组合成一个单独的源文件，并删掉了除一行输出之外的所有内容。我们将使用Linux的time工具为程序计时 ，其格式显示为 user time, system time, real time, and maximum memory usage:</p><blockquote><p>Mac OS 需要 <code>brew install gnu-time</code>，使用 gtime 命令替代</p></blockquote><pre><code class="hljs sh">$ cat xtime<span class="hljs-meta">#!/bin/sh</span>/usr/bin/time -f <span class="hljs-string">'%Uu %Ss %er %MkB %C'</span> <span class="hljs-string">"<span class="hljs-variable">$@</span>"</span>$$ make havlak1ccg++ -O3 -o havlak1cc havlak1.cc$ ./xtime ./havlak1cc<span class="hljs-comment"># of loops: 76002 (total 3800100)</span>loop-0, nest: 0, depth: 017.70u 0.05s 17.80r 715472kB ./havlak1cc$$ make havlak1go build havlak1.go$ ./xtime ./havlak1<span class="hljs-comment"># of loops: 76000 (including 1 artificial root node)</span>25.05u 0.11s 25.20r 1334032kB ./havlak1$</code></pre><p>C++程序运行使用17.80秒 700 MB内存。 Go程序运行使用25.20秒 1302 MB的内存。（该结果很难与论文中的统一，但本文的重点是探索如何使用 <code>go tool pprof</code>，而不是重现论文的结果。）</p><h3 id="CPU-Profile"><a href="#CPU-Profile" class="headerlink" title="CPU Profile"></a>CPU Profile</h3><p>要调优Go程序，我们必须启用profiling。 如果代码使用<a href="https://golang.org/pkg/testing/" target="_blank" rel="noopener">Go testing package</a>的benchmarking分析，可以使用gotest标准的 <code>-cpuprofile</code> 和 <code>-memprofile flags</code> 。 我们必须在程序中导入 <code>runtime/pprof</code> 并添加几行代码：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> cpuprofile = flag.String(<span class="hljs-string">"cpuprofile"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"write cpu profile to file"</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    flag.Parse()    <span class="hljs-keyword">if</span> *cpuprofile != <span class="hljs-string">""</span> &#123;        f, err := os.Create(*cpuprofile)        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;            log.Fatal(err)        &#125;        pprof.StartCPUProfile(f)        <span class="hljs-keyword">defer</span> pprof.StopCPUProfile()    &#125;    ...</code></pre><p>新代码定义了一个名为 <code>cpuprofile</code> 的flag，调用 <a href="https://golang.org/pkg/flag/" target="_blank" rel="noopener">Go flag library</a> 来解析命令行flags，如果在命令行上设置了 <code>cpuprofile</code> flag，则 <a href="https://golang.org/pkg/runtime/pprof/#StartCPUProfile" target="_blank" rel="noopener">starts CPU profiling</a> 重定向到该文件。 在程序退出之前，profiler 需要最后调用 <a href="https://golang.org/pkg/runtime/pprof/#StopCPUProfile" target="_blank" rel="noopener"><code>StopCPUProfile</code></a> 来flush未写入文件的数据; 我们使用 <code>defer</code> 来确保在 <code>main</code> 返回前执行该调用。</p><p>添加该代码后，我们可以使用新的 <code>-cpuprofile</code> flag 运行程序，然后运行 <code>go tool pprof</code> 来解释 profile。</p><pre><code class="hljs sh">$ make havlak1.prof./havlak1 -cpuprofile=havlak1.prof<span class="hljs-comment"># of loops: 76000 (including 1 artificial root node)</span>$ go tool pprof havlak1 havlak1.profWelcome to pprof!  For <span class="hljs-built_in">help</span>, <span class="hljs-built_in">type</span> <span class="hljs-string">'help'</span>.(pprof)</code></pre><p><code>go tool pprof</code> 程序是 <a href="https://github.com/gperftools/gperftools" target="_blank" rel="noopener">Google’s <code>pprof</code> C++ profiler</a> 的细微变体。最重要的命令是 <code>topN</code> ，显示profile中 top <code>N</code> 的样本：</p><pre><code class="hljs sh">(pprof) top10Total: 2525 samples     298  11.8%  11.8%      345  13.7% runtime.mapaccess1_fast64     268  10.6%  22.4%     2124  84.1% main.FindLoops     251   9.9%  32.4%      451  17.9% scanblock     178   7.0%  39.4%      351  13.9% hash_insert     131   5.2%  44.6%      158   6.3% sweepspan     119   4.7%  49.3%      350  13.9% main.DFS      96   3.8%  53.1%       98   3.9% flushptrbuf      95   3.8%  56.9%       95   3.8% runtime.aeshash64      95   3.8%  60.6%      101   4.0% runtime.settype_flush      88   3.5%  64.1%      988  39.1% runtime.mallocgc</code></pre><p>CPU profiling 启用时，Go程序每秒大约停止100次，并在当前正在执行的goroutine堆栈上记录由程序计数器组成的样本。 该 profile 有2525个样本，因此运行时间超过25秒。 在 <code>go tool pprof</code> 输出中，样本中出现的每个函数都有一行。 </p><ul><li>前两列显示函数运行的样本数（而不是等待被调用函数返回），展示为原始计数和总样本的百分比。 <code>runtime.mapaccess1_fast64</code> 函数在298个样本期间运行(11.8％)。 <code>top10</code> 输出按样本计数排序。 </li><li>第三列显示了清单期间的运行总数：前三行占样本的32.4％。 </li><li>第四和第五列显示函数出现的样本数（运行或等待被调用的函数返回）。 <code>main.FindLoops</code>函数在10.6％的样本中运行，但是它在84.1％的样本中位于调用堆栈（它或它的调用正在运行）上。</li></ul><p>要按第四和第五列排序，要使用 <code>-cum</code>（for cumulative）flag：</p><pre><code class="hljs sh">(pprof) top5 -cumTotal: 2525 samples       0   0.0%   0.0%     2144  84.9% gosched0       0   0.0%   0.0%     2144  84.9% main.main       0   0.0%   0.0%     2144  84.9% runtime.main       0   0.0%   0.0%     2124  84.1% main.FindHavlakLoops     268  10.6%  10.6%     2124  84.1% main.FindLoops(pprof) top5 -cum</code></pre><p>事实上， <code>main.FindLoops</code> 和 <code>main.main</code> 的总数应该是100％，但每个堆栈样本只包含底部的100个堆栈帧; 在大约四分之一的样本中，递归 <code>main.DFS</code> 函数比 <code>main.main</code> 深100多帧，因此完整的trace被截断。</p><p>stack trace样本包含有关函数调用关系，不是文本列表可以显示的有趣数据。 <code>web</code> 命令以SVG格式输出profile数据为图像，并在Web浏览器中打开它。 （还有一个 <code>gv</code> 命令可以编写PostScript并在Ghostview中打开它。两个命令都需要安装 <a href="http://www.graphviz.org/" target="_blank" rel="noopener">graphviz</a> 。）</p><pre><code class="hljs sh">(pprof) web</code></pre><p><a href="https://rawgit.com/rsc/benchgraffiti/master/havlak/havlak1.svg" target="_blank" rel="noopener">完整图形</a>的一小部分如下：</p><p><img src="https://blog.golang.org/profiling-go-programs_havlak1a-75.png" alt="51e0591fac0ac7e287fccce13aedcf00.png"></p><p>图中的每个框对应于一个函数，并且框根据函数运行的样本数来确定大小。 从方框X到方框Y的线表示X调用Y; 沿线的数字是调用在样本中出现的次数。 如果在单个样本中多次出现呼叫，例如在递归函数调用期间，则每次出现都会计入线权重。 解释了从 <code>main.DFS</code> 到自身的线的上的权重：21342。</p><p>我们可以一目了然看到该程序将大部分时间花在哈希操作上，这与使用Go的 <code>map</code> 值相对应。 我们让 <code>web</code> 只使用包含特定函数的样本，例如 <code>runtime.mapaccess1_fast64</code> ，可以清除图中的一些噪音：</p><pre><code class="hljs sh">(pprof) web mapaccess1</code></pre><p><img src="https://blog.golang.org/profiling-go-programs_havlak1-hash_lookup-75.png" alt="493783d8971606f7fb0eef78f95565cc.png"></p><p>如果斜视，我们可以看到 <code>main.FindLoops</code> 和 <code>main.DFS</code> 对 <code>runtime.mapaccess1_fast64</code> 的调用。</p><p>现在我们已经大致了解了大局，现在是时候放大一个特定的函数了。 让我们先看看 <code>main.DFS</code>  ，因为它是一个较短的函数：</p><pre><code class="hljs sh">(pprof) list DFSTotal: 2525 samplesROUTINE ====================== main.DFS <span class="hljs-keyword">in</span> /home/rsc/g/benchgraffiti/havlak/havlak1.go   119    697 Total samples (flat / cumulative)     3      3  240: func DFS(currentNode *BasicBlock, nodes []*UnionFindNode, number map[*BasicBlock]int, last []int, current int) int &#123;     1      1  241:     nodes[current].Init(currentNode, current)     1     37  242:     number[currentNode] = current     .      .  243:     1      1  244:     lastid := current    89     89  245:     <span class="hljs-keyword">for</span> _, target := range currentNode.OutEdges &#123;     9    152  246:             <span class="hljs-keyword">if</span> number[target] == unvisited &#123;     7    354  247:                     lastid = DFS(target, nodes, number, last, lastid+1)     .      .  248:             &#125;     .      .  249:     &#125;     7     59  250:     last[number[currentNode]] = lastid     1      1  251:     <span class="hljs-built_in">return</span> lastid(pprof)</code></pre><p>该清单显示了 <code>DFS</code> 函数的源代码（实际上，显示了与正则表达式 <code>DFS</code> 匹配的每个函数）。 前三列是运行该行时的样本数，运行该行或该行调用的代码的样本数，以及文件中的行号。 相关命令 <code>disasm</code> 可以显示函数的反汇编而不是源代码清单; 当有足够的样本时，可以帮助您查看哪些指令很昂贵。 <code>weblist</code> 命令混合了两种模式：<a href="https://rawgit.com/rsc/benchgraffiti/master/havlak/havlak1.html" target="_blank" rel="noopener">它显示了一个源列表，单击一行显示反汇编</a>。</p><p>由于我们已经知道时间花费在哈希运行时函数实现的映射查找，因此我们最关注的是第二列。 在递归调用 <code>DFS</code> （第247行）中花费了很大一部分时间，符合递归遍历的期望。 排除递归，看起来时间是花费在第242,246和250行的 <code>number</code> map的访问。对于特定查找，map 不是最有效的选择。 正如它们在编译器中一样，basic block 结构具有分配给它们的唯一序列号。 我们可以使用 <code>[]int</code> 替代 <code>map[*BasicBlock]int</code>，这是一个由block number索引的slice。 当数组或slice可以使用时，没有理由使用map。</p><p>将 <code>number</code> 从map更改为slice需要在程序中编辑七行，并将其运行时间减少近1/2：</p><pre><code class="hljs sh">$ make havlak2go build havlak2.go$ ./xtime ./havlak2<span class="hljs-comment"># of loops: 76000 (including 1 artificial root node)</span>16.55u 0.11s 16.69r 1321008kB ./havlak2$</code></pre><blockquote><p>见: <a href="https://github.com/rsc/benchgraffiti/commit/58ac27bcac3ffb553c29d0b3fb64745c91c95948" target="_blank" rel="noopener"><code>havlak1</code> vs <code>havlak2</code> diff</a></p></blockquote><h3 id="GC-Memory-Profile"><a href="#GC-Memory-Profile" class="headerlink" title="GC Memory Profile"></a>GC Memory Profile</h3><p>我们可以再次运行 profiler 来确认 <code>main.DFS</code> 不再是运行时间中重要的组成部分：</p><pre><code class="hljs sh">$ make havlak2.prof./havlak2 -cpuprofile=havlak2.prof<span class="hljs-comment"># of loops: 76000 (including 1 artificial root node)</span>$ go tool pprof havlak2 havlak2.profWelcome to pprof!  For <span class="hljs-built_in">help</span>, <span class="hljs-built_in">type</span> <span class="hljs-string">'help'</span>.(pprof)(pprof) top5Total: 1652 samples     197  11.9%  11.9%      382  23.1% scanblock     189  11.4%  23.4%     1549  93.8% main.FindLoops     130   7.9%  31.2%      152   9.2% sweepspan     104   6.3%  37.5%      896  54.2% runtime.mallocgc      98   5.9%  43.5%      100   6.1% flushptrbuf(pprof)</code></pre><p>条目 <code>main.DFS</code> 不再出现在 profile 中，程序 runtime 的其余部分也已消失。 现在该程序花费大部分时间来分配内存和垃圾收集（ <code>runtime.mallocgc</code>，分配和运行定期垃圾收集，占54.2％的时间）。 为了找出垃圾收集器运行如此多的原因，我们必须找出分配内存的原因。 一种方法是向程序添加 memory profiling。 我们改写程序，如果提供 <code>-memprofile</code> flag，程序在循环查找一次迭代后停止，写入 memory profile，并退出：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> memprofile = flag.String(<span class="hljs-string">"memprofile"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"write memory profile to this file"</span>)...    FindHavlakLoops(cfgraph, lsgraph)    <span class="hljs-keyword">if</span> *memprofile != <span class="hljs-string">""</span> &#123;        f, err := os.Create(*memprofile)        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;            log.Fatal(err)        &#125;        pprof.WriteHeapProfile(f)        f.Close()        <span class="hljs-keyword">return</span>    &#125;</code></pre><p>我们使用  <code>-memprofile</code> flag 调用程序写入 profile：</p><pre><code class="hljs sh">$ make havlak3.mprofgo build havlak3.go./havlak3 -memprofile=havlak3.mprof$</code></pre><blockquote><p>见: <a href="https://github.com/rsc/benchgraffiti/commit/b78dac106bea1eb3be6bb3ca5dba57c130268232" target="_blank" rel="noopener">diff from havlak2</a></p></blockquote><p>我们以完全相同的方式使用 <code>go tool pprof</code>。 现在我们正在检查的样本是内存分配，而不是时钟周期。</p><pre><code class="hljs sh">$ go tool pprof havlak3 havlak3.mprofAdjusting heap profiles <span class="hljs-keyword">for</span> 1-in-524288 sampling rateWelcome to pprof!  For <span class="hljs-built_in">help</span>, <span class="hljs-built_in">type</span> <span class="hljs-string">'help'</span>.(pprof) top5Total: 82.4 MB    56.3  68.4%  68.4%     56.3  68.4% main.FindLoops    17.6  21.3%  89.7%     17.6  21.3% main.(*CFG).CreateNode     8.0   9.7%  99.4%     25.6  31.0% main.NewBasicBlockEdge     0.5   0.6% 100.0%      0.5   0.6% itab     0.0   0.0% 100.0%      0.5   0.6% fmt.init(pprof)</code></pre><p>命令 <code>go tool pprof</code> 显示 <code>FindLoops</code> 分配了正在使用的大约56.3个82.4 MB; <code>CreateNode</code> 占另外的17.6 MB。 为了减少开销，内存分析器分配每半兆字节大约只记录一个块的信息。（“1-in-524288采样率”），因此这些是实际计数的近似值。</p><p>要查找内存分配，我们可以列出这些函数。</p><pre><code class="hljs sh">(pprof) list FindLoopsTotal: 82.4 MBROUTINE ====================== main.FindLoops <span class="hljs-keyword">in</span> /home/rsc/g/benchgraffiti/havlak/havlak3.go  56.3   56.3 Total MB (flat / cumulative)...   1.9    1.9  268:     nonBackPreds := make([]map[int]bool, size)   5.8    5.8  269:     backPreds := make([][]int, size)     .      .  270:   1.9    1.9  271:     number := make([]int, size)   1.9    1.9  272:     header := make([]int, size, size)   1.9    1.9  273:     types := make([]int, size, size)   1.9    1.9  274:     last := make([]int, size, size)   1.9    1.9  275:     nodes := make([]*UnionFindNode, size, size)     .      .  276:     .      .  277:     <span class="hljs-keyword">for</span> i := 0; i &lt; size; i++ &#123;   9.5    9.5  278:             nodes[i] = new(UnionFindNode)     .      .  279:     &#125;...     .      .  286:     <span class="hljs-keyword">for</span> i, bb := range cfgraph.Blocks &#123;     .      .  287:             number[bb.Name] = unvisited  29.5   29.5  288:             nonBackPreds[i] = make(map[int]bool)     .      .  289:     &#125;...</code></pre><p>看起来当前的瓶颈与上一个瓶颈相同：在原本使用更简单的数据结构就足够时使用 map。 <code>FindLoops</code> 正在分配大约29.5 MB的 maps。</p><p>顺便说一句，如果我们使用<code>--inuse_objects</code> flag 运行 <code>go tool pprof</code> ，它将报告分配计数而不是大小：</p><pre><code class="hljs sh">$ go tool pprof --inuse_objects havlak3 havlak3.mprofAdjusting heap profiles <span class="hljs-keyword">for</span> 1-in-524288 sampling rateWelcome to pprof!  For <span class="hljs-built_in">help</span>, <span class="hljs-built_in">type</span> <span class="hljs-string">'help'</span>.(pprof) list FindLoopsTotal: 1763108 objectsROUTINE ====================== main.FindLoops <span class="hljs-keyword">in</span> /home/rsc/g/benchgraffiti/havlak/havlak3.go720903 720903 Total objects (flat / cumulative)...     .      .  277:     <span class="hljs-keyword">for</span> i := 0; i &lt; size; i++ &#123;311296 311296  278:             nodes[i] = new(UnionFindNode)     .      .  279:     &#125;     .      .  280:     .      .  281:     // Step a:     .      .  282:     //   - initialize all nodes as unvisited.     .      .  283:     //   - depth-first traversal and numbering.     .      .  284:     //   - unreached BB<span class="hljs-string">'s are marked as dead.     .      .  285:     //     .      .  286:     for i, bb := range cfgraph.Blocks &#123;     .      .  287:             number[bb.Name] = unvisited409600 409600  288:             nonBackPreds[i] = make(map[int]bool)     .      .  289:     &#125;...(pprof)</span></code></pre><p>由于~200,000个 maps 占29.5 MB，因此初始 map 分配大约需要150个字节。 map 用于保存键值对是合理的，但是在此处map被用作简单集合的替代是不合理的。</p><p>我们可以使用简单的slice来列出元素，而不是使用map。 在使用 map 的所有情况中，一种情况要除外，map不可能插入重复的元素。在下面的的一个例子中，我们可以编写一个简单的“append”内置函数变体：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">appendUnique</span><span class="hljs-params">(a []<span class="hljs-keyword">int</span>, x <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;    <span class="hljs-keyword">for</span> _, y := <span class="hljs-keyword">range</span> a &#123;        <span class="hljs-keyword">if</span> x == y &#123;            <span class="hljs-keyword">return</span> a        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">append</span>(a, x)&#125;</code></pre><p>除了编写该函数之外，将Go程序更改为使用slices而不是maps需要更改几行代码。</p><pre><code class="hljs sh">$ make havlak4go build havlak4.go$ ./xtime ./havlak4<span class="hljs-comment"># of loops: 76000 (including 1 artificial root node)</span>11.84u 0.08s 11.94r 810416kB ./havlak4$</code></pre><blockquote><p>见： <a href="https://github.com/rsc/benchgraffiti/commit/245d899f7b1a33b0c8148a4cd147cb3de5228c8a" target="_blank" rel="noopener">diff from havlak3</a></p></blockquote><p>现在的速度比开始时快2.11倍。 让我们再看一下CPU profile。</p><h3 id="GC-CPU-Profile"><a href="#GC-CPU-Profile" class="headerlink" title="GC CPU Profile"></a>GC CPU Profile</h3><pre><code class="hljs sh">$ make havlak4.prof./havlak4 -cpuprofile=havlak4.prof<span class="hljs-comment"># of loops: 76000 (including 1 artificial root node)</span>$ go tool pprof havlak4 havlak4.profWelcome to pprof!  For <span class="hljs-built_in">help</span>, <span class="hljs-built_in">type</span> <span class="hljs-string">'help'</span>.(pprof) top10Total: 1173 samples     205  17.5%  17.5%     1083  92.3% main.FindLoops     138  11.8%  29.2%      215  18.3% scanblock      88   7.5%  36.7%       96   8.2% sweepspan      76   6.5%  43.2%      597  50.9% runtime.mallocgc      75   6.4%  49.6%       78   6.6% runtime.settype_flush      74   6.3%  55.9%       75   6.4% flushptrbuf      64   5.5%  61.4%       64   5.5% runtime.memmove      63   5.4%  66.8%      524  44.7% runtime.growslice      51   4.3%  71.1%       51   4.3% main.DFS      50   4.3%  75.4%      146  12.4% runtime.MCache_Alloc(pprof)</code></pre><p>现在内存分配和随后的垃圾收集（<code>run time.mallocgc</code>）占我们运行时间的50.9%。</p><p>另一种查看系统为什么进行垃圾收集的方法是查看导致收集的分配，即查看在 <code>mallocgc</code>中花费大部分时间的地方：</p><pre><code class="hljs sh">(pprof) web mallocgc</code></pre><p><img src="https://blog.golang.org/profiling-go-programs_havlak4a-mallocgc.png" alt="35ac62c841354eb45e656849967ee81a.png"></p><p>很难看清楚图中发生了什么，因为有许多节点的样本数量很少，这些节点模糊了大样本的。我们可以让 <code>go tool pprof</code> 忽略少于10%占比的样本节点：</p><pre><code class="hljs sh">$ go tool pprof --nodefraction=0.1 havlak4 havlak4.profWelcome to pprof!  For <span class="hljs-built_in">help</span>, <span class="hljs-built_in">type</span> <span class="hljs-string">'help'</span>.(pprof) web mallocgc</code></pre><p><img src="https://blog.golang.org/profiling-go-programs_havlak4a-mallocgc-trim.png" alt="a9b324420bfda40b3c3a274bf4652f78.png"></p><p>我们现在可以轻松地遵循粗箭头，看看 <code>FindLoops</code> 是否触发了大部分垃圾收集。 如果我们列出 <code>FindLoops</code> 们可以看到，大部分在开始时是正确的：</p><pre><code class="hljs sh">(pprof) list FindLoops...     .      .  270: func FindLoops(cfgraph *CFG, lsgraph *LSG) &#123;     .      .  271:     <span class="hljs-keyword">if</span> cfgraph.Start == nil &#123;     .      .  272:             <span class="hljs-built_in">return</span>     .      .  273:     &#125;     .      .  274:     .      .  275:     size := cfgraph.NumNodes()     .      .  276:     .    145  277:     nonBackPreds := make([][]int, size)     .      9  278:     backPreds := make([][]int, size)     .      .  279:     .      1  280:     number := make([]int, size)     .     17  281:     header := make([]int, size, size)     .      .  282:     types := make([]int, size, size)     .      .  283:     last := make([]int, size, size)     .      .  284:     nodes := make([]*UnionFindNode, size, size)     .      .  285:     .      .  286:     <span class="hljs-keyword">for</span> i := 0; i &lt; size; i++ &#123;     2     79  287:             nodes[i] = new(UnionFindNode)     .      .  288:     &#125;...(pprof)</code></pre><p>每次调用 <code>FindLoops</code> ，它都会分配一些相当大的 bookkeeping structures。 由于benchmark调用 <code>FindLoops</code> 50次，因此这些增加了大量的垃圾，所以垃圾收集器的工作量很大。</p><p>使用垃圾收集语言并不意味着您可以忽略内存分配问题。 在这种情况下，一个简单的解决方案是引入一个缓存，以便每次调用 <code>FindLoops</code> 时尽可能重用前一个调用的存储。</p><blockquote><p>事实上，在Hundt的论文中，他解释说Java程序只需要进行这种改变就可以得到合理的性能，但是他没有在其他垃圾收集的实现中做出相同的改变。</p></blockquote><p>我们将添加一个全局cache结构：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> cache <span class="hljs-keyword">struct</span> &#123;    size <span class="hljs-keyword">int</span>    nonBackPreds [][]<span class="hljs-keyword">int</span>    backPreds [][]<span class="hljs-keyword">int</span>    number []<span class="hljs-keyword">int</span>    header []<span class="hljs-keyword">int</span>    types []<span class="hljs-keyword">int</span>    last []<span class="hljs-keyword">int</span>    nodes []*UnionFindNode&#125;</code></pre><p>然后把它当作 <code>FindLoops</code> 内存分配的替代品：</p><pre><code class="hljs go"><span class="hljs-keyword">if</span> cache.size &lt; size &#123;    cache.size = size    cache.nonBackPreds = <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, size)    cache.backPreds = <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, size)    cache.number = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, size)    cache.header = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, size)    cache.types = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, size)    cache.last = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, size)    cache.nodes = <span class="hljs-built_in">make</span>([]*UnionFindNode, size)    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> cache.nodes &#123;        cache.nodes[i] = <span class="hljs-built_in">new</span>(UnionFindNode)    &#125;&#125;nonBackPreds := cache.nonBackPreds[:size]<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> nonBackPreds &#123;    nonBackPreds[i] = nonBackPreds[i][:<span class="hljs-number">0</span>]&#125;backPreds := cache.backPreds[:size]<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> nonBackPreds &#123;    backPreds[i] = backPreds[i][:<span class="hljs-number">0</span>]&#125;number := cache.number[:size]header := cache.header[:size]types := cache.types[:size]last := cache.last[:size]nodes := cache.nodes[:size]</code></pre><p>当然，这样的全局变量是糟糕的工程实践：它意味着对 <code>FindLoops</code> 并发调用现在是不安全的。 目前，我们正在进行尽可能少的更改，以便了解对我们的程序的性能有什么重要意义; 这种变化很简单，并且反映了Java实现中的代码。 Go程序的最终版本将使用单独的 <code>LoopFinder</code> 实例来跟踪此内存，从而恢复并发使用的可能性。</p><pre><code class="hljs sh">$ make havlak5go build havlak5.go$ ./xtime ./havlak5<span class="hljs-comment"># of loops: 76000 (including 1 artificial root node)</span>8.03u 0.06s 8.11r 770352kB ./havlak5$</code></pre><blockquote><p>见 <a href="https://github.com/rsc/benchgraffiti/commit/2d41d6d16286b8146a3f697dd4074deac60d12a4" target="_blank" rel="noopener">diff from havlak4</a></p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们可以做更多的事情来清理程序并使其更快，但是它们都不需要我们尚未展示的分析技术。 内部循环中使用的工作列表可以跨迭代和跨调用进行重用。 FindLoops，它可以与在该过程中生成的单独的“节点池”相结合。 类似地，循环图存储可以在每次迭代时重用，而不是重新分配。 除了这些性能变化之外， <a href="https://github.com/rsc/benchgraffiti/blob/master/havlak/havlak6.go" target="_blank" rel="noopener">最终版本</a>是使用惯用的Go样式编写的，使用数据结构和方法。 风格变化对运行时间的影响很小：算法和约束不变。</p><p>最终版本运行2.29秒，使用351 MB内存：</p><pre><code class="hljs sh">$ make havlak6go build havlak6.go$ ./xtime ./havlak6<span class="hljs-comment"># of loops: 76000 (including 1 artificial root node)</span>2.26u 0.02s 2.29r 360224kB ./havlak6$</code></pre><p>这比我们开始的程序快11倍。 即使我们禁用对生成的循环图的重用，以便唯一的缓存内存是循环查找bookeeping，程序仍然比原始运行速度快6.7倍，并且使用的内存减少1.5倍。</p><pre><code class="hljs sh">$ ./xtime ./havlak6 -reuseloopgraph=<span class="hljs-literal">false</span><span class="hljs-comment"># of loops: 76000 (including 1 artificial root node)</span>3.69u 0.06s 3.76r 797120kB ./havlak6 -reuseloopgraph=<span class="hljs-literal">false</span>$</code></pre><p>当然，将这个Go程序与原始的C++程序进行比较是不公平的，因为它使用了低效的数据结构，例如 <code>set</code>s 其中 <code>vector</code>s 更合适。 作为完整性检查，我们将最终的Go程序翻译成<a href="https://github.com/rsc/benchgraffiti/blob/master/havlak/havlak6.cc" target="_blank" rel="noopener">等效的C++代码</a>。 它的执行时间类似于Go程序：</p><pre><code class="hljs sh">$ make havlak6ccg++ -O3 -o havlak6cc havlak6.cc$ ./xtime ./havlak6cc<span class="hljs-comment"># of loops: 76000 (including 1 artificial root node)</span>1.99u 0.19s 2.19r 387936kB ./havlak6cc</code></pre><p>Go程序的运行速度几乎和C++程序一样快。 由于C++程序使用自动删除和分配而不是显式缓存，因此C++程序更短更容易编写，但不是那么明显：</p><pre><code class="hljs sh">$ wc havlak6.cc; wc havlak6.go 401 1220 9040 havlak6.cc 461 1441 9467 havlak6.go$</code></pre><blockquote><p>见 <a href="https://github.com/rsc/benchgraffiti/blob/master/havlak/havlak6.cc" target="_blank" rel="noopener">havlak6.cc</a> 和 <a href="https://github.com/rsc/benchgraffiti/blob/master/havlak/havlak6.go" target="_blank" rel="noopener">havlak6.go</a></p></blockquote><p>Benchmarks与他们测量的程序一样好。 我们使用 <code>go tool pprof</code> 来研究低效的Go程序，然后将其性能提高一个数量级，并将其内存使用量减少3.7倍。 随后与等效优化的C++程序进行比较表明，当程序员小心内循环生成多少垃圾时，Go可以与C++竞争。</p><p>用于编写这篇文章的程序源代码，Linux x86-64二进制文件和配置文件可以在GitHub上的<a href="https://github.com/rsc/benchgraffiti/" target="_blank" rel="noopener">benchgraffiti</a>项目中找到 。</p><p>如上所述， <a href="https://golang.org/cmd/go/#Test_packages" target="_blank" rel="noopener"><code>go test</code></a> 已经包含了这些 profiling flags：<a href="https://golang.org/pkg/testing/" target="_blank" rel="noopener">benchmark function</a> ，你就完成了。 还有一个用于 profiling 数据的标准HTTP接口。 在HTTP服务器中，添加</p><pre><code class="hljs go"><span class="hljs-keyword">import</span> _ <span class="hljs-string">"net/http/pprof"</span></code></pre><p>将安装几个URL的处理程序 <code>/debug/pprof/</code>. 然后，您可以用一个参数运行 <code>go tool pprof</code>——指向服务器profiling数据的URL，它将下载并检查实时Profile文件。</p><pre><code class="hljs sh">go tool pprof http://localhost:6060/debug/pprof/profile   <span class="hljs-comment"># 30-second CPU profile</span>go tool pprof http://localhost:6060/debug/pprof/heap      <span class="hljs-comment"># heap profile</span>go tool pprof http://localhost:6060/debug/pprof/block     <span class="hljs-comment"># goroutine blocking profile</span></code></pre><p>goroutine blocking profile 将在以后的文章中解释。 敬请关注。</p><p>作者：Russ Cox，2011年7月; 由Shenghou Ma更新，2013年5月</p><p><em>原文：<a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="noopener">https://blog.golang.org/profiling-go-programs</a></em><br/><br><em>源代码：<a href="https://github.com/cyningsun/go-test" target="_blank" rel="noopener">https://github.com/cyningsun/go-test</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;在Scala Days 2011，Robert Hundt 发表了一篇名为 &lt;a href=&quot;http://research.google.
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Profile" scheme="https://www.cyningsun.com/tag/Profile/"/>
    
  </entry>
  
  <entry>
    <title>中文网页重设与排版：Typo.css</title>
    <link href="https://www.cyningsun.com/07-06-2019/chinese-kramdown-typeset.html"/>
    <id>https://www.cyningsun.com/07-06-2019/chinese-kramdown-typeset.html</id>
    <published>2019-07-05T16:00:00.000Z</published>
    <updated>2020-02-03T06:53:29.638Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、关于-Typo-css"><a href="#一、关于-Typo-css" class="headerlink" title="一、关于 Typo.css"></a>一、关于 <em>Typo.css</em></h3><p><em>Typo.css</em> 的目的是，在一致化浏览器排版效果的同时，构建最适合中文阅读的网页排版。</p><h4 id="现状和如何去做："><a href="#现状和如何去做：" class="headerlink" title="现状和如何去做："></a>现状和如何去做：</h4><p>排版是一个麻烦的问题 <sup><a href="https://typo.sofi.sh/#appendix1" target="_blank" rel="noopener"># 附录一</a></sup>，需要精心设计，而这个设计却是常被视觉设计师所忽略的。前端工程师更常看到这样的问题，但不便变更。因为在多个 OS 中的不同浏览器渲染不同，改动需要多的时间做回归测试，所以改变变得更困难。而像我们一般使用的<br>Yahoo、Eric Meyer 和 Alice base.css 中采用的 Reset 都没有很好地考虑中文排版。<em>Typo.css</em> 要做的就是解决中文排版的问题。</p><p><strong><em>Typo.css</em> 测试于如下平台：</strong></p><table><thead><tr><th>OS/浏览器</th><th>Firefox</th><th>Chrome</th><th>Safari</th><th>Opera</th><th>IE9</th><th>IE8</th><th>IE7</th><th>IE6</th></tr></thead><tbody><tr><td>OS X</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>Win 7</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td><td>-</td></tr><tr><td>Win XP</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td><td>-</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>Ubuntu</td><td>✔</td><td>✔</td><td>-</td><td>✔</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h4 id="中文排版的重点和难点"><a href="#中文排版的重点和难点" class="headerlink" title="中文排版的重点和难点"></a>中文排版的重点和难点</h4><p>在中文排版中，HTML4 的很多标准在语义在都有照顾到。但从视觉效果上，却很难利用单独的 CSS 来实现，像<br><abbr title="在文字下多加一个点">着重号</abbr>（例：这里<em class="typo-em">强调一下</em>）。在 HTML4 中，专名号标签（ <em>&lt;u&gt;</em> ）已经被放弃，而<br>HTML5 被<a href="http://html5doctor.com/u-element/" target="_blank" rel="noopener">重新提起</a>。<em>Typo.css</em> 也根据实际情况提供相应的方案。我们重要要注意的两点是：</p><ol><li>语义：语义对应的用法和样式是否与中文排版一致</li><li>表现：在各浏览器中的字体、大小和缩放是否如排版预期</li></ol><p>对于这些，<em>Typo.css</em> 排版项目的中文偏重注意点，都添加在附录中，详见：</p><blockquote><p><strong>附录一</strong>：<a href="https://typo.sofi.sh/#appendix1" target="_blank" rel="noopener"><em>Typo.css</em> 排版偏重点</a></p></blockquote><p>目前已有像百姓网等全面使用 <em>Typo.css</em> 的项目，测试平台的覆盖，特别是在<br><abbr title="手机、平板电脑等移动平台">移动端</abbr>上还没有覆盖完主流平台，希望有能力的同学能加入测试行列，或者加入到 <em>Typo.css</em><br>的开发。加入方法：<a href="https://github.com/sofish/Typo.css" target="_blank" rel="noopener">参与 <em>Typo.css</em> 开发</a>。如有批评、建议和意见，也随时欢迎给在 Github 直接提 <a href="https://github.com/sofish/Typo.css/issues" target="_blank" rel="noopener">issues</a>，或给<br><abbr title="Sofish Lin, author of Typo.css" role="author">我</abbr>发<a href="mailto:sofish@icloud.com">邮件</a>。</p><h3 id="二、排版实例："><a href="#二、排版实例：" class="headerlink" title="二、排版实例："></a>二、排版实例：</h3><p>提供2个排版实例，第一个中文实例来自于来自于<br><cite class="typo-unique">张燕婴</cite>的《论语》，由于古文排版涉及到的元素比较多，所以采用《论语》中《学而》的第一篇作为排版实例介绍；第2个来自到经典的<br>Lorem Ipsum，并加入了一些代码和列表等比较具有代表性的排版元素。</p><h4 id="例1：论语学而篇第一"><a href="#例1：论语学而篇第一" class="headerlink" title="例1：论语学而篇第一"></a>例1：论语学而篇第一</h4><p><small><b>作者：</b><abbr title="名丘，字仲尼">孔子</abbr>（<time>前551年9月28日－前479年4月11日</time>）<br></small></p><h5 id="本篇引语"><a href="#本篇引语" class="headerlink" title="本篇引语"></a>本篇引语</h5><p>《学而》是《论语》第一篇的篇名。《论语》中各篇一般都是以第一章的前二三个字作为该篇的篇名。《学而》一篇包括16章，内容涉及诸多方面。其中重点是「吾日三省吾身」；「节用而爱人，使民以时」；「礼之用，和为贵」以及仁、孝、信等道德范畴。 </p><h5 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h5><p>子曰：「学而时习之，不亦说乎？有朋自远方来，不亦乐乎？人不知，而不愠，不亦君子乎？」 </p><h5 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h5><p>孔子说：「学了又时常温习和练习，不是很愉快吗？有志同道合的人从远方来，不是很令人高兴的吗？人家不了解我，我也不怨恨、恼怒，不也是一个有德的君子吗？」 </p><h5 id="评析"><a href="#评析" class="headerlink" title="评析"></a>评析</h5><p>宋代著名学者<u class="typo-u">朱熹</u>对此章评价极高，说它是「入道之门，积德之基」。本章这三句话是人们非常熟悉的。历来的解释都是：学了以后，又时常温习和练习，不也高兴吗等等。三句话，一句一个意思，前后句子也没有什么连贯性。但也有人认为这样解释不符合原义，指出这里的「学」不是指学习，而是指学说或主张；「时」不能解为时常，而是时代或社会的意思，「习」不是温习，而是使用，引申为采用。而且，这三句话不是孤立的，而是前后相互连贯的。这三句的意思是：自己的学说，要是被社会采用了，那就太高兴了；退一步说，要是没有被社会所采用，可是很多朋友赞同<br><abbr title="张燕婴">我</abbr>的学说，纷纷到我这里来讨论问题，我也感到快乐；再退一步说，即使社会不采用，人们也不理解我，我也不怨恨，这样做，不也就是君子吗？（见《齐鲁学刊》1986年第6期文）这种解释可以自圆其说，而且也有一定的道理，供读者在理解本章内容时参考。</p><p>此外，在对「人不知，而不愠」一句的解释中，也有人认为，「人不知」的后面没有宾语，人家不知道什么呢？当时因为孔子有说话的特定环境，他不需要说出知道什么，别人就可以理解了，却给后人留下一个谜。有人说，这一句是接上一句说的，从远方来的朋友向我求教，我告诉他，他还不懂，我却不怨恨。这样，「人不知」就是「人家不知道我所讲述的」了。这样的解释似乎有些牵强。</p><p>总之，本章提出以学习为乐事，做到人不知而不愠，反映出孔子学而不厌、诲人不倦、注重修养、严格要求自己的主张。这些思想主张在《论语》书中多处可见，有助于对第一章内容的深入了解。</p><h4 id="例2：英文排版"><a href="#例2：英文排版" class="headerlink" title="例2：英文排版"></a>例2：英文排版</h4><p>Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry’s<br>standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a<br>type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining<br>essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum<br>passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem<br>Ipsum.</p><blockquote><p>  Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna<br>  aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p></blockquote><h5 id="The-standard-Lorem-Ipsum-passage-used-since-the-1500s"><a href="#The-standard-Lorem-Ipsum-passage-used-since-the-1500s" class="headerlink" title="The standard Lorem Ipsum passage, used since the 1500s"></a>The standard Lorem Ipsum passage, used since the 1500s</h5><p>“Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna<br>aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.<br>Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint<br>occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.”</p><h5 id="Section-1-10-32-of-“de-Finibus-Bonorum-et-Malorum”-written-by-Cicero-in-45-BC"><a href="#Section-1-10-32-of-“de-Finibus-Bonorum-et-Malorum”-written-by-Cicero-in-45-BC" class="headerlink" title="Section 1.10.32 of “de Finibus Bonorum et Malorum”, written by Cicero in 45 BC"></a>Section 1.10.32 of “de Finibus Bonorum et Malorum”, written by Cicero in 45 BC</h5><p>“Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam,<br>eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam<br>voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione<br>voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci<br>velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim<br>ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi<br>consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur,<br>vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?”</p><h5 id="List-style-in-action"><a href="#List-style-in-action" class="headerlink" title="List style in action"></a>List style in action</h5><ul><li><p>If you wish to succeed, you should use persistence as your good friend, experience as your reference, prudence as</p><pre><code>your brother and hope as your sentry.</code></pre><p>  如果你希望成功，当以恒心为良友，以经验为参谋，以谨慎为兄弟，以希望为哨兵。</p></li><li><p>Sometimes one pays most for the things one gets for nothing.</p><p>  有时候一个人为不花钱得到的东西付出的代价最高。</p></li><li><p>Only those who have the patience to do simple things perfectly ever acquire the skill to do difficult things</p><pre><code>easily.</code></pre><p>  只有有耐心圆满完成简单工作的人，才能够轻而易举的完成困难的事。</p></li></ul><h5 id="You-may-want-to-create-a-perfect-lt-hr-gt-line-despite-the-fact-that-there-will-never-have-one"><a href="#You-may-want-to-create-a-perfect-lt-hr-gt-line-despite-the-fact-that-there-will-never-have-one" class="headerlink" title="You may want to create a perfect &lt;hr /&gt; line, despite the fact that there will never have one"></a>You may want to create a perfect <em>&lt;hr /&gt;</em> line, despite the fact that there will never have one</h5><hr><p><abbr title="法国作家罗切福考尔德">La Racheforcauld</abbr> said:<mark>“Few things are impossible in themselves; and it is often for want of will, rather than of means, that man fails<br>to succeed”.<br></mark><br>You just need to follow the browser’s behavior, and set a right <em>margin</em> to it。it will works nice as the<br>demo you’re watching now. The following code is the best way to render typo in Chinese:</p><pre>/* 标题应该更贴紧内容，并与其他块区分，margin 值要相应做优化 */h1,h2,h3,h4,h5,h6 {    line-height:1;font-family:Arial,sans-serif;margin:1.4em 0 0.8em;}h1{font-size:1.8em;}h2{font-size:1.6em;}h3{font-size:1.4em;}h4{font-size:1.2em;}h5,h6{font-size:1em;}/* 现代排版：保证块/段落之间的空白隔行 */.typo p, .typo pre, .typo ul, .typo ol, .typo dl, .typo form, .typo hr {    margin:1em 0 0.6em;}</pre><h3 id="三、附录"><a href="#三、附录" class="headerlink" title="三、附录"></a>三、附录</h3><h5 id="1、Typo-css-排版偏重点"><a href="#1、Typo-css-排版偏重点" class="headerlink" title="1、Typo.css 排版偏重点"></a>1、<em>Typo.css</em> 排版偏重点</h5><table><thead><tr><th>类型</th><th>语义</th><th>标签</th><th>注意点</th></tr></thead><tbody><tr><td>基础标签</td><td>标题</td><td><em>h1</em> ～ <em>h6</em></td><td>全局不强制大小，<em>.typo</em> 中标题与其对应的内容应紧贴，并且有相应的大小设置</td></tr><tr><td>上、下标</td><td><em>sup</em>/<em>sub</em></td><td>保持与 MicroSoft Office Word 等程序的日常排版一致</td><td></td></tr><tr><td>引用</td><td><em>blockquote</em></td><td>显示/嵌套样式</td><td></td></tr><tr><td>缩写</td><td><em>abbr</em></td><td>是否都有下划线，鼠标 <em>hover</em> 是否为帮助手势</td><td></td></tr><tr><td>分割线</td><td><em>hr</em></td><td>显示的 <em>padding</em> 和 _margin_正确</td><td></td></tr><tr><td>列表</td><td><em>ul</em>/<em>ol</em>/<em>dl</em></td><td>在全局没有 <em>list-style_，在 ._typo</em> 中对齐正确</td><td></td></tr><tr><td>定义列表</td><td><em>dl</em></td><td>全局 <em>padding</em> 和 <em>margin_为0， ._typo</em> 中对齐正确</td><td></td></tr><tr><td>选项</td><td><em>input[type=radio[, checkbox]]</em></td><td>与其他 <em>form</em> 元素排版时是否居中</td><td></td></tr><tr><td>斜体</td><td><em>i</em></td><td>只设置一种斜体，让 <em>em</em> 和 <em>cite</em> 显示为正体</td><td></td></tr><tr><td>强调</td><td><em>em</em></td><td>在全局显示正体，在 <em>.typo</em> 中显示与 <em>b</em> 和 <em>strong</em> 的样式一致，为粗体</td><td></td></tr><tr><td>加强</td><td><em>strong/b</em></td><td>显示为粗体</td><td></td></tr><tr><td>标记</td><td><em>mark</em></td><td>类似荧光笔</td><td></td></tr><tr><td>印刷</td><td><em>small</em></td><td>保持为正确字体的 80% 大小，颜色设置为浅灰色</td><td></td></tr><tr><td>表格</td><td><em>table</em></td><td>全局不显示线条，在 <em>table</em> 中显示表格外框，并且表头有浅灰背景</td><td></td></tr><tr><td>代码</td><td><em>pre</em>/<em>code</em></td><td>字体使用 <em>courier</em> 系字体，保持与 <em>serif</em> 有比较一致的显示效果</td><td></td></tr><tr><td>特殊符号</td><td>着重号</td><td><em>在文字下加点</em></td><td>在支持 <em>:after</em> 和 <em>:before</em> 的浏览器可以做渐进增强实现</td></tr><tr><td>专名号</td><td><u>林建锋</u></td><td>专名号，有下划线，使用 <em>u</em> 或都 <em>.typo-u</em> 类</td><td></td></tr><tr><td>破折号</td><td>——</td><td>保持一划，而非两划</td><td></td></tr><tr><td>人民币</td><td>¥</td><td>使用两平等线的符号，或者 HTML 实体符号 <em>&yen;</em></td><td></td></tr><tr><td>删除符</td><td><del>已删除（deleted）</del></td><td>一致化各浏览器显示，中英混排正确</td><td></td></tr><tr><td>加强类</td><td>专名号</td><td><em>.typo-u</em></td><td>由于 <em>u</em> 被 HTML4 放弃，在向后兼容上推荐使用 <em>.typo-u</em></td></tr><tr><td>着重符</td><td><em>.typo-em</em></td><td>利用 <em>:after</em> 和 <em>:before</em> 实现着重符</td><td></td></tr><tr><td>清除浮动</td><td><em>.clearfix</em></td><td>与一般 CSS Reset 保持一对致 API</td><td></td></tr></tbody></table><p>注意点:<br/><br>（1）中英文混排行高/行距<br/><br>（2）上下标在 IE 中显示效果<br/><br>（3）块/段落分割空白是否符合设计原则<br/><br>（4）input 多余空间问题<br/><br>（5）默认字体色彩，目前采用 <em>#333</em> 在各种浏览显示比较好<br/></p><h5 id="2、开源许可"><a href="#2、开源许可" class="headerlink" title="2、开源许可"></a>2、开源许可</h5><p><em>Typo.css</em> 基于 <a href="http://zh.wikipedia.org/wiki/MIT_License" target="_blank" rel="noopener">MIT License</a> 开源，使用代码只需说明来源，或者引用 <a href="http://typo.sofi.sh/license.txt" target="_blank" rel="noopener">license.txt</a> 即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、关于-Typo-css&quot;&gt;&lt;a href=&quot;#一、关于-Typo-css&quot; class=&quot;headerlink&quot; title=&quot;一、关于 Typo.css&quot;&gt;&lt;/a&gt;一、关于 &lt;em&gt;Typo.css&lt;/em&gt;&lt;/h3&gt;&lt;p&gt;&lt;em&gt;Typo.css&lt;/em&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>译 | Stack Traces In Go</title>
    <link href="https://www.cyningsun.com/07-05-2019/live-stack-traces-in-go-cn.html"/>
    <id>https://www.cyningsun.com/07-05-2019/live-stack-traces-in-go-cn.html</id>
    <published>2019-07-04T16:00:00.000Z</published>
    <updated>2020-02-03T06:53:29.638Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在调试Go程序方面有一些基本技能可以为程序员节省大量时间来识别问题。我信奉log尽可能多的信息，但有时panic发生，而log的信息并不够。有时理解stack trace中的信息可能意味着立刻发现错误，抑或需要添加更多日志记录并等待它再次发生。</p><p>自从我开始写Go以来，我一直在看stack trace。在某些时候，我们都做了一些愚蠢的事情，导致运行时杀死我们的程序并抛出stack trace。我将向您展示stack trace提供的信息，包括如何识别传递到函数的每个参数的值。</p><h4 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h4><p>让我们从一小段代码开始，它将产生一个stack trace:</p><pre><code class="hljs go"><span class="hljs-number">01</span> <span class="hljs-keyword">package</span> main<span class="hljs-number">02</span><span class="hljs-number">03</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-number">04</span>     slice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)<span class="hljs-number">05</span>     Example(slice, <span class="hljs-string">"hello"</span>, <span class="hljs-number">10</span>)<span class="hljs-number">06</span> &#125;<span class="hljs-number">07</span><span class="hljs-number">08</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Example</span><span class="hljs-params">(slice []<span class="hljs-keyword">string</span>, str <span class="hljs-keyword">string</span>, i <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-number">09</span>     <span class="hljs-built_in">panic</span>(<span class="hljs-string">"Want stack trace"</span>)<span class="hljs-number">10</span> &#125;</code></pre><p>上述代码展示了一个程序，第05行其main函数调用Example函数。Example函数被声明在第08行，接受三个参数，string slices，字符串和一个整数。Example执行的唯一代码是在第09行调用内置panic函数，它立即生成stack trace：</p><pre><code class="hljs go">Panic: Want stack tracegoroutine <span class="hljs-number">1</span> [running]:main.Example(<span class="hljs-number">0x2080c3f50</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x4</span>, <span class="hljs-number">0x425c0</span>, <span class="hljs-number">0x5</span>, <span class="hljs-number">0xa</span>)        /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/        temp/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">9</span> +<span class="hljs-number">0x64</span>main.main()        /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/        temp/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span> +<span class="hljs-number">0x85</span></code></pre><p>上述stack trace显示了panic时的所有goroutine，每个协程的状态以及相应goroutine下的调用堆栈。导致stack trace的运行中goroutine位于顶部。首先我们把重点放在导致panic的goroutine。</p><pre><code class="hljs go"><span class="hljs-number">01</span> goroutine <span class="hljs-number">1</span> [running]:<span class="hljs-number">02</span> main.Example(<span class="hljs-number">0x2080c3f50</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x4</span>, <span class="hljs-number">0x425c0</span>, <span class="hljs-number">0x5</span>, <span class="hljs-number">0xa</span>)           /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/           temp/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">9</span> +<span class="hljs-number">0x64</span><span class="hljs-number">03</span> main.main()           /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/           temp/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">5</span> +<span class="hljs-number">0x85</span></code></pre><p>代码第01行的stack trace 显示在panic之前goroutine 1正在运行中。第02行，我们看到panic的代码位于main包的Example函数中。缩进的行显示了此函数所在的代码文件和路径，以及正在执行的代码行。当时，第09行的代码正在运行，是一个导致panic的调用。</p><p>第03行显示调用Example的函数的名称，main包中的main函数。在函数名称下面，缩进的行显示了对Example进行调用的代码文件，路径和代码行。</p><p>stack trace显示直到panic发生时，该goroutine范围内的函数调用链。现在，我们把重点放在传递给Example函数的每个参数的值：</p><pre><code class="hljs go"><span class="hljs-comment">// Declaration</span>main.Example(slice []<span class="hljs-keyword">string</span>, str <span class="hljs-keyword">string</span>, i <span class="hljs-keyword">int</span>)<span class="hljs-comment">// Call to Example by main.</span>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)Example(slice, <span class="hljs-string">"hello"</span>, <span class="hljs-number">10</span>)<span class="hljs-comment">// Stack trace</span>main.Example(<span class="hljs-number">0x2080c3f50</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x4</span>, <span class="hljs-number">0x425c0</span>, <span class="hljs-number">0x5</span>, <span class="hljs-number">0xa</span>)</code></pre><p>上述来自stack trace显示了当main调用时传递给Example函数的值和该函数的声明。将stack trace中的值与函数声明进行比较，似乎不匹配。Example函数的声明接受三个参数，但stack trace显示六个十六进制值。<strong>理解值如何与参数匹配的关键在于需要知道每个参数类型的实现。</strong></p><p>让我们从第一个参数开始，这是一个string slice。<strong>slice</strong>在Go中是引用类型。意味着slice的值是<strong>header value</strong>，带有指向某些基础数据的指针。对于slice，<strong>header value</strong>是三个word大小的结构，其包含指向底层数组的指针，slice的长度和容量。与slice header相关的值由stack trace中的前三个值表示：</p><pre><code class="hljs go"><span class="hljs-comment">// Slice parameter value</span>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)<span class="hljs-comment">// Slice header values</span>Pointer:  <span class="hljs-number">0x2080c3f50</span>Length:   <span class="hljs-number">0x2</span>Capacity: <span class="hljs-number">0x4</span><span class="hljs-comment">// Declaration</span>main.Example(<span class="hljs-string">`slice []string`</span>, str <span class="hljs-keyword">string</span>, i <span class="hljs-keyword">int</span>)<span class="hljs-comment">// Stack trace</span>main.Example(<span class="hljs-string">`0x2080c3f50, 0x2, 0x4`</span>, <span class="hljs-number">0x425c0</span>, <span class="hljs-number">0x5</span>, <span class="hljs-number">0xa</span>)</code></pre><p>上述显示了堆栈跟踪中的前三个值如何与slice参数匹配。第一个值表示指向基础字符串数组的指针。用于初始化切片的长度和容量数与第二个和第三个值匹配。这三个值表示切片标头的每个值，即第一个参数。<br><img src="http://ww1.sinaimg.cn/large/bcaaa65bgy1g4p1x90wb3j20ex07ugmh.jpg" alt=""></p><p>现在让我们看看第二个参数，它是一个字符串。字符串也是引用类型，但此它的<strong>header value</strong>是不可变的。字符串的<strong>header value</strong>声明为三个word大小的结构，包含指向底层字节数组的指针和字符串的长度：</p><pre><code class="hljs go"><span class="hljs-comment">// String parameter value</span><span class="hljs-string">"hello"</span><span class="hljs-comment">// String header values</span>Pointer: <span class="hljs-number">0x425c0</span>Length:  <span class="hljs-number">0x5</span><span class="hljs-comment">// Declaration</span>main.Example(slice []<span class="hljs-keyword">string</span>, <span class="hljs-string">`str string`</span>, i <span class="hljs-keyword">int</span>)<span class="hljs-comment">// Stack trace</span>main.Example(<span class="hljs-number">0x2080c3f50</span>, <span class="hljs-number">0x2</span>, <span class="hljs-string">`0x4, 0x425c0`</span>, <span class="hljs-number">0x5</span>, <span class="hljs-number">0xa</span>)</code></pre><p>上述显示了stack trace中的第四、五个值如何匹配string参数。第四个值表示指向底层字节数组的指针，第五个值表示字符串的长度为5.字符串“hello”需要5个字节。这两个值表示字符串（即，第二个参数）header的每个值。<br><img src="http://ww1.sinaimg.cn/large/bcaaa65bgy1g4p1yddm5cj20ey060gmc.jpg" alt=""></p><p>第三个参数是一个整数，它是一个word的值：</p><pre><code class="hljs go"><span class="hljs-comment">// Integer parameter value</span><span class="hljs-number">10</span><span class="hljs-comment">// Integer value</span>Base <span class="hljs-number">16</span>: <span class="hljs-number">0xa</span><span class="hljs-comment">// Declaration</span>main.Example(slice []<span class="hljs-keyword">string</span>, str <span class="hljs-keyword">string</span>, <span class="hljs-string">`i int`</span>)<span class="hljs-comment">// Stack trace</span>main.Example(<span class="hljs-number">0x2080c3f50</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x4</span>, <span class="hljs-number">0x425c0</span>, <span class="hljs-number">0x5</span>, <span class="hljs-string">`0xa`</span>)</code></pre><p>上述显示了stack trace中的最后一个值如何匹配整数参数。trace中的最后一个值是十六进制数0xa，它是值10.与该参数传递的值相同。该值代表第三个参数。<br><img src="http://ww1.sinaimg.cn/large/bcaaa65bgy1g4p1yrg3q9j20fi03wq38.jpg" alt=""></p><h4 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h4><p>我们更改程序，将Example函数改为一个成员函数：</p><pre><code class="hljs go"><span class="hljs-number">01</span> <span class="hljs-keyword">package</span> main<span class="hljs-number">02</span><span class="hljs-number">03</span> <span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span><span class="hljs-number">04</span><span class="hljs-number">05</span> <span class="hljs-keyword">type</span> trace <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-number">06</span><span class="hljs-number">07</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-number">08</span>     slice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)<span class="hljs-number">09</span><span class="hljs-number">10</span>     <span class="hljs-keyword">var</span> t trace<span class="hljs-number">11</span>     t.Example(slice, <span class="hljs-string">"hello"</span>, <span class="hljs-number">10</span>)<span class="hljs-number">12</span> &#125;<span class="hljs-number">13</span><span class="hljs-number">14</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *trace)</span> <span class="hljs-title">Example</span><span class="hljs-params">(slice []<span class="hljs-keyword">string</span>, str <span class="hljs-keyword">string</span>, i <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-number">15</span>     fmt.Printf(<span class="hljs-string">"Receiver Address: %p\n"</span>, t)<span class="hljs-number">16</span>     <span class="hljs-built_in">panic</span>(<span class="hljs-string">"Want stack trace"</span>)<span class="hljs-number">17</span> &#125;</code></pre><p>第5行通过声明一个新类型trace，改变原始程序，转换Example函数为的第14行的成员函数。转换是通过重新声明函数包含一个trace类型的指针接收器来实现。然后在第10行，声明一个trace类型的t变量，并在第11行使用该变量进行方法调用。</p><p>由于该方法是使用指针接收器声明的，因此Go将获取t变量的地址以支持接收器类型，即使方法调用使用的是值。这次运行程序时，stack trace略有不同</p><pre><code class="hljs go">Receiver Address: <span class="hljs-string">`0x1553a8`</span><span class="hljs-built_in">panic</span>: Want stack trace<span class="hljs-number">01</span> goroutine <span class="hljs-number">1</span> [running]:<span class="hljs-number">02</span> main.(<span class="hljs-string">`*trace`</span>).Example(<span class="hljs-string">`0x1553a8`</span>, <span class="hljs-number">0x2081b7f50</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x4</span>, <span class="hljs-number">0xdc1d0</span>, <span class="hljs-number">0x5</span>, <span class="hljs-number">0xa</span>)           /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/           temp/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">16</span> +<span class="hljs-number">0x116</span><span class="hljs-number">03</span> main.main()           /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/           temp/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">11</span> +<span class="hljs-number">0xae</span></code></pre><p>首先，应该注意的是第02行的stack trace清楚表明这是一个使用指针接收器的方法调用。现在，包含（* trace）的成员函数的名称显示在包名称和方法名称之间。其次，要注意的是值列表现在如何第一个显示接收器的值。成员函数调用实际上是第一个参数是接收器值的函数调用。我们从stack trace中看到了这个实现细节。</p><p>由于声明或调用Example方法没有其他任何更改，因此所有其他值保持不变。调用Example的行号和发生panic的位置发生了变化，并反映了新代码。</p><h4 id="Packing"><a href="#Packing" class="headerlink" title="Packing"></a>Packing</h4><p>如果有多个参数适合放入单个word，那么stack trace中参数的值将打包在一起：</p><pre><code class="hljs go"><span class="hljs-number">01</span> <span class="hljs-keyword">package</span> main<span class="hljs-number">02</span><span class="hljs-number">03</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-number">04</span>     Example(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">25</span>)<span class="hljs-number">05</span> &#125;<span class="hljs-number">06</span><span class="hljs-number">07</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Example</span><span class="hljs-params">(b1, b2, b3 <span class="hljs-keyword">bool</span>, i <span class="hljs-keyword">uint8</span>)</span></span> &#123;<span class="hljs-number">08</span>     <span class="hljs-built_in">panic</span>(<span class="hljs-string">"Want stack trace"</span>)<span class="hljs-number">09</span> &#125;</code></pre><p>上述显示了一个新的示例程序，将Example函数更改为接受四个参数。前三个是布尔值，最后一个是八位无符号整数。布尔值也是一个8位值，因此所有四个参数都适合放入32位和64位架构上的单个word。当程序运行时，它会产生一个有趣的stack trace：</p><pre><code class="hljs go"><span class="hljs-number">01</span> goroutine <span class="hljs-number">1</span> [running]:<span class="hljs-number">02</span> main.Example(<span class="hljs-string">`0x19010001`</span>)           /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/           temp/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">8</span> +<span class="hljs-number">0x64</span><span class="hljs-number">03</span> main.main()           /Users/bill/Spaces/Go/Projects/src/github.com/goinaction/code/           temp/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">4</span> +<span class="hljs-number">0x32</span></code></pre><p>对Example的调用，stack trace中没有四个值，取而代之只有一个值。所有四个独立的8位值都拼凑成一个word：</p><pre><code class="hljs go"><span class="hljs-comment">// Parameter values</span><span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">25</span><span class="hljs-comment">// Word value</span>Bits    Binary      Hex   Value<span class="hljs-number">00</span><span class="hljs-number">-07</span>   <span class="hljs-number">0000</span> <span class="hljs-number">0001</span>   <span class="hljs-string">`01`</span>    <span class="hljs-literal">true</span><span class="hljs-number">08</span><span class="hljs-number">-15</span>   <span class="hljs-number">0000</span> <span class="hljs-number">0000</span>   <span class="hljs-string">`00`</span>    <span class="hljs-literal">false</span><span class="hljs-number">16</span><span class="hljs-number">-23</span>   <span class="hljs-number">0000</span> <span class="hljs-number">0001</span>   <span class="hljs-string">`01`</span>    <span class="hljs-literal">true</span><span class="hljs-number">24</span><span class="hljs-number">-31</span>   <span class="hljs-number">0001</span> <span class="hljs-number">1001</span>   <span class="hljs-string">`19`</span>    <span class="hljs-number">25</span><span class="hljs-comment">// Declaration</span>main.Example(<span class="hljs-string">`b1, b2, b3 bool, i uint8`</span>)<span class="hljs-comment">// Stack trace</span>main.Example(<span class="hljs-string">`0x19010001`</span>)</code></pre><p>上述显示出了在stack trace的值如何匹配传入的四个参数值。true的8位值对应于1的值，false的值对应0值。二进制25的值是11001，十六进制转换为19。现在，当我们查看堆stack trace中表示的十六进制值时，我们会看到它如何表示传入的值。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Go runtime提供了大量信息来帮助我们调试程序。在这篇文章中，我们专注于stack trace。解码在整个调用堆栈中传递给每个函数的值的能力是巨大的。它不止一次帮助我快速识别我的bug。既然您已经知道如何读取stack trace，那么希望您可以在下次发生stack trace时可以利用这些知识。</p><p><em>原文：<a href="https://www.ardanlabs.com/blog/2015/01/stack-traces-in-go.html" target="_blank" rel="noopener">stack-traces-in-go</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;在调试Go程序方面有一些基本技能可以为程序员节省大量时间来识别问题。我信奉log尽可能多的信息，但有时panic发生，而log的信息并不够。
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Profile" scheme="https://www.cyningsun.com/tag/Profile/"/>
    
  </entry>
  
  <entry>
    <title>弹幕系统设计实践</title>
    <link href="https://www.cyningsun.com/03-31-2019/live-streaming-danmaku.html"/>
    <id>https://www.cyningsun.com/03-31-2019/live-streaming-danmaku.html</id>
    <published>2019-03-30T16:00:00.000Z</published>
    <updated>2020-02-03T06:53:29.637Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>为了更好的支持东南亚直播业务，产品设计为直播业务增加了弹幕。第一期弹幕使用腾讯云支持，效果并不理想，经常出现卡顿、弹幕偏少等问题。最终促使我们开发自己的弹幕系统。性能要求是需要支持，单房间百万用户同时在线。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>按照背景来分析，系统将主要面临以下问题：</p><ol><li>带宽压力<blockquote><p>假如说每3秒促达用户一次，那么每次内容至少需要有15条才能做到视觉无卡顿。15条弹幕+http包头的大小将超过3k，那么每秒的数据大小约为8Gbps，而运维同学通知我们所有服务的可用带宽仅为10Gbps。</p></blockquote></li><li>弱网导致的弹幕卡顿、丢失<blockquote><p>该问题已在线上环境</p></blockquote></li><li>性能与可靠性<blockquote><p>百万用户同时在线，按照上文的推算，具体QPS将超过30w QPS。如何保证在双十一等重要活动中不出问题，至关重要。性能也是另外一个需要着重考虑的点。</p></blockquote></li></ol><h3 id="带宽优化"><a href="#带宽优化" class="headerlink" title="带宽优化"></a>带宽优化</h3><p>为了降低带宽压力，我们主要采用了以下方案：</p><ol><li>启用Http压缩<blockquote><p>通过查阅资料，http gzip压缩比率可以达到40%以上（gzip比deflate要高出4%~5%）。</p></blockquote></li><li>Response结构简化<br><img src="/images/live-streaming-danmaku/resp.jpg" alt=""></li><li>内容排列顺序优化<blockquote><p>根据gzip的压缩的压缩原理可以知道，重复度越高，压缩比越高，因此可以将字符串和数字内容放在一起摆放</p></blockquote></li><li>频率控制<blockquote><ul><li>带宽控制：通过添加请求间隔参数（下次请求时间），保证客户端的请求频率服务端可控。以应对突发的流量增长问题，提供有损的服务。</li><li>稀疏控制：在弹幕稀疏和空洞的时间段，通过控制下次请求时间，避免客户端的无效请求。</li></ul></blockquote></li></ol><h3 id="弹幕卡顿、丢失分析"><a href="#弹幕卡顿、丢失分析" class="headerlink" title="弹幕卡顿、丢失分析"></a>弹幕卡顿、丢失分析</h3><p>在开发弹幕系统的的时候，最常见的问题是该怎么选择促达机制，推送 vs 拉取 ？</p><h4 id="Long-Polling-via-AJAX"><a href="#Long-Polling-via-AJAX" class="headerlink" title="Long Polling via AJAX"></a>Long Polling via AJAX</h4><p>客户端打开一个到服务器端的 AJAX 请求，然后等待响应，服务器端需要一些特定的功能来允许请求被挂起，只要一有事件发生，服务器端就会在挂起的请求中送回响应。如果打开Http的Keepalived开关，还可以节约握手的时间。</p><p><img src="/images/live-streaming-danmaku/polling-ajax.jpg" alt=""></p><p>优点：减少轮询次数，低延迟，浏览器兼容性较好。<br>缺点：服务器需要保持大量连接。</p><h4 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h4><p>长轮询虽然省去了大量无效请求，减少了服务器压力和一定的网络带宽的占用，但是还是需要保持大量的连接。那么人们就在考虑了，有没有这样一个完美的方案，即能双向通信，又可以节约请求的 header 网络开销，并且有更强的扩展性，最好还可以支持二进制帧，压缩等特性呢？于是人们就发明了这样一个目前看似“完美”的解决方案 —— WebSocket。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话。</p><p><img src="/images/live-streaming-danmaku/websockets.jpg" alt=""></p><p>优点：<br>较少的控制开销，在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于 HTTP 请求每次都要携带完整的头部，此项开销显著减少了。<br>更强的实时性，由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。<br>长连接，保持连接状态。</p><h4 id="Long-Polling-vs-Websockets"><a href="#Long-Polling-vs-Websockets" class="headerlink" title="Long Polling vs Websockets"></a>Long Polling vs Websockets</h4><p>无论是以上哪种方式，都使用到TCP长连接，那么TCP的长连接是如何发现连接已经断开了呢？</p><p>TCP Keepalived会进行连接状态探测，探测间隔主要由三个配置控制。</p><blockquote><p>keepalive_probes：探测次数（默认：7次）<br/><br>keepalive_time   探测的超时（默认：2小时）<br/><br>keepalive_intvl 探测间隔(默认：75s)<br/></p></blockquote><p>但是由于在东南亚的弱网情况下，TCP长连接会经常性的断开:</p><blockquote><p>Long Polling 能发现连接异常的最短间隔为：min(keepalive_intvl, polling_interval)<br/><br>Websockets能发现连接异常的最短间隔为：Websockets: min(keepalive_intvl, client_sending_interval)<br/></p></blockquote><p>如果下次发送数据包的时候可能连接已经断开了，所以使用TCP长连接对于两者均意义不大。并且弱网情况下Websockets其实已经不能作为一个候选项了</p><ul><li>即使Websockets服务端已经发现连接断开，仍然没有办法推送数据，只能被动等待客户端重新建立好连接才能推送，在此之前数据将可能会被采取丢弃的措施处理掉。</li><li>在每次断开后均需要再次发送应用层的协议进行连接建立。</li></ul><p>根据了解腾讯云的弹幕系统，在300人以下使用的是推送模式，300人以上则是采用的轮训模式。但是考虑到资源消耗情况，他们可能使用的是Websocket来实现的弹幕系统，所以才会出现弹幕卡顿、丢失的情况。综上所述，Long Polling和Websockets都不适用我们面临的环境，所以我们最终采取了<strong>短轮训</strong>的方案来实现弹幕促达<br><img src="/images/live-streaming-danmaku/polling.jpg" alt=""></p><h3 id="可靠与性能"><a href="#可靠与性能" class="headerlink" title="可靠与性能"></a>可靠与性能</h3><p>为了保证服务的稳定性我们对服务进行了拆分，将复杂的逻辑收拢到发送弹幕的一端。同时，将逻辑较为复杂、调用较少的发送弹幕业务与逻辑简单、调用量高的弹幕拉取服务拆分开来。服务拆分主要考虑因素是为了不让服务间相互影响，对于这种系统服务，不同服务的QPS往往是不对等的，例如像拉取弹幕的服务的请求频率和负载通常会比发送弹幕服务高1到2个数量级，在这种情况下不能让拉弹幕服务把发弹幕服务搞垮，反之亦然，最⼤度地保证系统的可用性，同时也更更加方便对各个服务做Scale-Up和Scale-Out。服务拆分也划清了业务边界，方便协同开发。</p><p><strong>在拉取弹幕服务的一端</strong>，引入了本地缓存。数据更新的策略是服务会定期发起RPC调⽤从弹幕服务拉取数据，拉取到的弹幕缓存到内存中，这样后续的请求过来时便能直接⾛走本地内存的读取，⼤大幅降低了调用时延。这样做还有另外一个好处就是缩短调⽤链路，把数据放到离⽤户最近的地⽅，同时还能降低外部依赖的服务故障对业务的影响，</p><p><img src="/images/live-streaming-danmaku/buffer-ring.jpg" alt=""></p><p>为了数据拉取方便，我们将数据按照时间进行分片，将时间作为数据切割的单位，按照时间存储、拉取、缓存数据（RingBuffer），简化了数据处理流程。与传统的Ring Buffer不一样的是，我们只保留了尾指针，它随着时间向前移动，每⼀秒向前移动一格，把时间戳和对应弹幕列表并写到一个区块当中，因此最多保留60秒的数据。同时，如果此时来了一个读请求，那么缓冲环会根据客户端传入的时间戳计算出指针的索引位置，并从尾指针的副本区域往回遍历直至跟索引重叠，收集到一定数量的弹幕列表返回，这种机制保证了缓冲区的区块是整体有序的，因此在读取的时候只需要简单地遍历一遍即可，加上使用的是数组作为存储结构，带来的读效率是相当高的。</p><p>再来考虑可能出现数据竞争的情况。先来说写操作，由于在这个场景下，写操作是单线程的，因此⼤可不必关心并发写带来的数据一致性问题。再来说读操作，由图可知写的方向是从尾指针以顺时针⽅向移动，⽽读⽅向是从尾指针以逆时针方向移动，⽽决定读和写的位置是否出现重叠取决于index的位置，由于我们保证了读操作最多只能读到30秒内的数据，因此缓冲环完全可以做到无锁读写</p><p><strong>在发送弹幕的一端</strong>，因为用户一定时间能看得过来弹幕总量是有限的，所以可以对弹幕进行限流，有选择的丢弃多余的弹幕。同时，采用柔性的处理方式，拉取用户头像、敏感词过滤等分支在调用失败的情况下，仍然能保证服务的核心流程不受影响，即弹幕能够正常发送和接收，提供有损的服务。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/live-streaming-danmaku/architecture.jpg" alt=""></p><p>最终该服务在双十二活动中，在Redis出现短暂故障的背景下，高效且稳定的支撑了70w用户在线，成功完成了既定的目标</p><p>参考链接：</p><ul><li><a href="https://halfrost.com/websocket/" target="_blank" rel="noopener">https://halfrost.com/websocket/</a></li><li><a href="https://shopee-sz.github.io/2019/02/27/livechat/" target="_blank" rel="noopener">https://shopee-sz.github.io/2019/02/27/livechat/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;为了更好的支持东南亚直播业务，产品设计为直播业务增加了弹幕。第一期弹幕使用腾讯云支持，效果并不理想，经常出现卡顿、弹幕偏少等问题。最终促使我
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
