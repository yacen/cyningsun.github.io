<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>有疑者说</title>
  
  
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://www.cyningsun.com/"/>
  <updated>2020-07-27T14:04:39.826Z</updated>
  <id>https://www.cyningsun.com/</id>
  
  <author>
    <name>cyningsun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何设计 RPC 接口</title>
    <link href="https://www.cyningsun.com/07-27-2020/how-to-write-rpc-interface.html"/>
    <id>https://www.cyningsun.com/07-27-2020/how-to-write-rpc-interface.html</id>
    <published>2020-07-26T16:00:00.000Z</published>
    <updated>2020-07-27T14:04:39.826Z</updated>
    
    <content type="html"><![CDATA[<p>如果说之前清晰知道如何 <a href="https://www.cyningsun.com/06-29-2020/how-to-write-restful-api.html">设计HTTP API</a>  就可以了，那么随着微服务走热，服务越来越多，每个服务都要对外暴漏接口，对如何设计RPC接口有个清晰的认识，变得比以前任何时候都重要。</p><p>虽然设计 RPC 接口很重要，但是却并不容易，经历过多少折腾，才能理解接口那些痛：</p><ul><li><p>莫“名”其妙</p><blockquote><p>读取数据可能会因为数据不一样，分别称为：<code>GetXxx</code>  vs <code>GetXxxLite</code> ，所以 lite 不 lite 有啥不一样？类似的太多太多，关于如何取一个好名字，可以看这里：<a href="https://www.cyningsun.com/07-04-2020/how-to-naming-things.html">《如何代码命名》</a></p></blockquote></li><li><p>接口过多</p><blockquote><p>由于页面需要各式各样的数据，导致查询条件差异很大，很容易出现：</p><ul><li>一个查询条件，一个接口的尴尬</li><li>直接新增接口，但实际上该接口可能已经出现过，只是被隐藏在众多接口里</li></ul></blockquote></li><li><p>难以扩展</p><blockquote><p>面向需求设计接口，不进行任何抽象，导致接口难以扩展</p></blockquote></li></ul><p>三者就像追命绳索，一环套一环，环环相扣，最终将服务带入墓地。</p><h3 id="认识复杂性"><a href="#认识复杂性" class="headerlink" title="认识复杂性"></a>认识复杂性</h3><p>举个例子，当从DB表读取表数据时，可以按照以下三种维度读取数据：</p><ol><li><p>DB的维度，允许表之间 join，即操作复合数据</p></li><li><p>表的维度，允许且只允许全部操作一条数据的所有字段</p></li><li><p>字段的维度，允许接口操作表的部分字段。</p></li></ol><p>假设数据库 <code>d</code> 有 <code>t</code>  张表，平均每个表有 <code>f</code> 个字段，每种数据有 <code>n</code> 种操作。则:</p><ul><li>第一种方案，有 <code>n * t!</code> 个接口；</li><li>第二种方案，有 <code>n * t</code> 个接口；</li><li>第三种方案，有 <code>n * t * f!</code> 个接口</li><li>没有方案，则有 <code>n * t! * f! * n</code> 个接口</li></ul><p>聪明的你会选择哪一种方案，你的依据又是什么？想弄清楚这些，就需要继续往下看</p><h3 id="认识数据"><a href="#认识数据" class="headerlink" title="认识数据"></a>认识数据</h3><p>看接口先看数据，所有的接口都是为了操作数据。对数据了解多深刻，也就大概限制了对接口认识多深刻。</p><p>数据在用户侧以  <a href="https://www.cyningsun.com/06-29-2020/how-to-write-restful-api.html">hyper media</a>  存在；数据流到服务中以对象来组织；数据落到存储里就变成了<code>id</code> + <code>content</code>。索引 <code>content</code> 的 id，一般又以 <code>单个</code> 和 <code>集合</code> 的形态存在，具体到数据库中，id 以 聚簇索引存在，content 以聚簇索引叶节点存在</p><p><img src="/images/Data=ID+Content.png" alt=""></p><p>越来越多的产品按照先获取 <code>id</code> 再读取 <code>content</code> 来访问数据，之前是搜索引擎，现在是各式各样的内容推荐</p><h3 id="认识操作"><a href="#认识操作" class="headerlink" title="认识操作"></a>认识操作</h3><p>有了对数据的基本认识，对数据的操作无非是：增、删、改、查（包括：ID / 内容列表查询、根据 ID 批量查询内容）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有了以上这些认知，那么如何为服务设计收敛的接口，也就不再是个问题。</p><br/><h4 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h4><p>请为以下需求设计一套查询的API接口</p><p><strong>主播侧需求</strong></p><p>当主播点开直播直播入口时</p><ul><li>如果有未开始的直播，则进行直播设置；</li><li>如果有进行中的直播，则直接进入该场直播；</li><li>如果没有进行中的直播<ul><li>第一次直播，则创建一场新的直播</li><li>第一场之外的直播，则使用上一场直播的设置，创建一场新的未开始的直播。</li></ul></li></ul><p><strong>用户侧</strong></p><p>当用户点开直播间时</p><ul><li>获取该直播的所有信息，包括：<ul><li>主播信息</li><li>直播信息</li><li>是否关注该主播</li><li>在线人数</li><li>点赞数</li><li>…</li></ul></li></ul><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/07-27-2020/how-to-write-rpc-interface.html">https://www.cyningsun.com/07-27-2020/how-to-write-rpc-interface.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果说之前清晰知道如何 &lt;a href=&quot;https://www.cyningsun.com/06-29-2020/how-to-write-restful-api.html&quot;&gt;设计HTTP API&lt;/a&gt;  就可以了，那么随着微服务走热，服务越来越多，每个服务都要对外暴漏
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>你不了解的软件开发过程</title>
    <link href="https://www.cyningsun.com/07-22-2020/software-development-methodology.html"/>
    <id>https://www.cyningsun.com/07-22-2020/software-development-methodology.html</id>
    <published>2020-07-21T16:00:00.000Z</published>
    <updated>2020-07-21T16:28:07.678Z</updated>
    
    <content type="html"><![CDATA[<p>中国 IT 从业人员中对软件研发过程有系统认识的少之又少，甚至在工作中遇到的科班出身的研发同学同样不例外。相反，大家对于追求热点概念（例如：DDD，领域驱动设计）倒是不遗余力，满怀热情。</p><p>软件开发刚开始的时候，并没有很好的经验或思想来指导项目研发。从研发的各种名词中可以看出来，软件行业从建筑行业借鉴了许多经验。</p><ul><li><p>建筑行业涉及到不同角色协作：设计师、开发商（工人、电工和水暖工）、质量监理、等等。</p><blockquote><p>软件工程类似的角色：产品经理、研发（后端、前端、客户端）、测试、QA</p></blockquote></li><li><p>建筑行业遵循的流程：把端到端的项目分成不同的阶段，每个流程阶段由不同角色负责</p></li></ul><p>每个阶段赋予角色的做法，有利于充分利用成本高昂的人力资源。在借鉴的基础的产生了第一个标准的软件开发流程</p><p><img src="/images/software-development-methodology/Waterfall.jpeg" alt="img"></p><p>事实上，如同力学三大定律为物理学奠基一样，瀑布模型在软件行业的地位同样不可动摇。虽然随着历史的车轮滚滚向前，软件研发方法论的研究重点从瀑布模型的 “流程”，过渡到以交付速度和成功率为目标的敏捷开发、持续集成、持续交付、持续部署。但研发过程的核心步骤从未改变：分析、设计、开发</p><p><img src="/images/software-development-methodology/Evolution-of-Software-Delivery.png" alt="img"></p><p>然而，不幸的是，因为追求交付速度、成功率，国内研发不仅丢掉了瀑布模型，也丢掉了核心过程。太多的研发以敏捷为理论核武，把设计完全抛掉，更遑论分析。如果系统确实太过复杂，抑或领导要求，那就装模作样加入一个设计阶段，设计一个看起来能够跑的通的架构。一旦软件进入实现阶段，所有的设计文档就被雪藏起来吃灰。</p><p>重视开发多于设计，不知分析为何物。架构凭经验和感觉，就像无根之水，即使再美也经不起业务变化和迭代的侵蚀，最终走向腐朽。最后不得不亮出终极武器：重构（其实，是“重做”）。</p><p>意识到需要做分析、设计，到知道如何做分析设计，中间有着不小的鸿沟。软件开发不是玄学，有着系统的方法论，以及完善的表达工具。需求分析从业务开始，层层剥开，直至实现。如果把软件想象成建筑，那么各种图就是从某一个特定的视角（viewpoint）表达软件的设计图纸，因此RUP C4+1 称之为 <code>View model</code> 也大抵表达该含义吧。选择合适的图表述，把软件表述清楚也能体现出工程人员的软件设计能力。</p><p><strong>各个层级的分析对象</strong><br><img src="/images/software-development-methodology/business-analyze.png" alt=""></p><p><strong>各分析阶段用于表达的图</strong><br><img src="/images/software-development-methodology/RUP.jpg" alt=""></p><p>具体使用细节，不再使用例子详细描述，可以参考：</p><ul><li>Microsoft: <a href="https://docs.microsoft.com/en-gb/visualstudio/modeling/analyze-and-model-your-architecture?view=vs-2015" target="_blank" rel="noopener">Analyze and model your architecture</a></li><li>IBM:<a href="https://www.ibm.com/developerworks/cn/rational/define-application-architecture-rational-software-architect-1/index.html" target="_blank" rel="noopener">利用Rational Software Architect 定义应用程序架构 第一部分</a>、<a href="https://www.ibm.com/developerworks/cn/rational/define-application-architecture-rational-software-architect-2/index.html" target="_blank" rel="noopener">利用Rational Software Architect 定义应用程序架构 第二部分</a></li></ul><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/07-22-2020/software-development-methodology.html">https://www.cyningsun.com/07-22-2020/software-development-methodology.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;中国 IT 从业人员中对软件研发过程有系统认识的少之又少，甚至在工作中遇到的科班出身的研发同学同样不例外。相反，大家对于追求热点概念（例如：DDD，领域驱动设计）倒是不遗余力，满怀热情。&lt;/p&gt;
&lt;p&gt;软件开发刚开始的时候，并没有很好的经验或思想来指导项目研发。从研发的各种
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>如何代码命名</title>
    <link href="https://www.cyningsun.com/07-04-2020/how-to-naming-things.html"/>
    <id>https://www.cyningsun.com/07-04-2020/how-to-naming-things.html</id>
    <published>2020-07-03T16:00:00.000Z</published>
    <updated>2020-07-21T13:25:57.006Z</updated>
    
    <content type="html"><![CDATA[<br/><p>There are only two hard things in Computer Science: cache invalidation and naming things.         —— Phil Karlton</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>开发人员习惯性的对设计、架构、微服务夸夸其谈，却很少关注设计、架构如何完完整整的落地到代码本身。架构和设计固然重要，代码并非不重要。正如 <code>Robert C.Martin</code> 所言：“<strong>代码即设计</strong>”。透过好的代码，就能看到其背后精美的设计。</p><p>好的代码，第一步是为每一个类、函数、变量起一个好的名字。可惜的是，大多数人对于如何起一个好名字不得其法。毕竟严格上来说，命名并非计算机科学的范畴。好的命名一个词就可以简单、形象、直观表明其功用甚至原理，例如：</p><ul><li><p>SYN <strong>flood</strong>：洪水一样的SYN请求</p></li><li><p><strong>Pipeline</strong>：管道一样传输数据、依次且单向</p></li></ul><p><img src="/images/design-thinking-process.png" alt="查看源图像"></p><p>以上还只是问题解决域，还不是最难的。最难的是，在实际研发中，还要面对问题分析域。如果你的思路结构、层次不清晰，抽象出的各种状态不正交，相互重叠，交差，此时再想起出比较好的名字，则回天乏术；如果你不知道一个事物应该叫什么，你就不可能知道它是什么（<a href="https://www.oreilly.com/library/view/97-things-every/9780596800611/ch76.html" target="_blank" rel="noopener">A Rose by Any Other Name Will End Up As a Cabbage</a>），所以命名的过程也是整理思路的过程。</p><p>根据过往的经验总结，可以将命名分为三个Level，前两个 Level 覆盖 Solution Space 的困境，最后一个 Level 覆盖 Problem Space 的困境</p><ul><li>Level 1：坏味道，嗅出坏味道才能意识到需要改变</li><li>Level 2：命名技巧，一些简单的命名技巧，明白有哪些渠道可以改进</li><li>Level 3：领域语言，命名的道，命名是可以系统化的从业务过渡到研发。</li></ul><h3 id="Level-1-坏味道"><a href="#Level-1-坏味道" class="headerlink" title="Level 1: 坏味道"></a>Level 1: 坏味道</h3><ul><li><p>无意义的命名</p><blockquote><p> i.e. <code>data</code>、<code>info</code>、<code>record</code></p></blockquote></li><li><p>抽象的命名</p><blockquote><p>i.e. <code>data</code> 、<code>object</code>、<code>helper</code>、<code>tool</code>、<code>manager</code>、 <code>processor</code>、<code>handler</code>、<code>maker</code>、<code>util</code>、<code>conf</code>、<code>thing</code>、<code>info</code>、<code>amount</code>、<code>details</code>、<code>do</code>、<code>execute</code>、<code>perform</code>、<code>operate</code>、<code>manage</code>、<code>handle</code></p><p>不够精确，毫无疑问，你确实命名了数据和对象，但即使没有此模糊的名称你也早知道的。将 <code>data</code> 重命名为更具描述性的名称，以标识数据</p></blockquote></li><li><p>简称</p><blockquote><p>i.e. <code>mod</code></p><p><code>mod</code> 像是某个单词的简称，你可能无法确认到底是 <code>mode</code> 或 <code>module</code> </p></blockquote></li><li><p>含糊</p><blockquote><p>i.e. <code>Manager</code> </p><p>命名模糊，谁知道经理到底是干什么的？可以更有意义的替代方案，如：牧民（<strong>Herder</strong>）、主管（<strong>Supervisor</strong>）、策划人（<strong>Planner</strong>）、建筑商（<strong>builder</strong>）</p></blockquote></li><li><p>多个单词</p><blockquote><p>i.e. <code>company_person</code> 代表公司人员</p><p>重命名 <code>company_person</code> 为 <code>staff</code> 更为合适，或者更新一步 <code>employee</code>  或  <code>director</code></p></blockquote></li><li><p>被动语态</p><blockquote><p>i.e. <code>PlanEvents</code> </p><p>重命名 <code>PlanEvents</code> 为主动语 <code>EventPlanner</code> 更好，或者更进一步 <code>Scheduler</code></p></blockquote></li></ul><h3 id="Level-2-命名技巧"><a href="#Level-2-命名技巧" class="headerlink" title="Level 2: 命名技巧"></a>Level 2: 命名技巧</h3><h4 id="增加词汇量"><a href="#增加词汇量" class="headerlink" title="增加词汇量"></a>增加词汇量</h4><blockquote><p>命名只是写作的一部分，主要是词汇。你可能还记得学习外语的一部分就是学习词汇。不用学外语是利弊并存之事。</p></blockquote><ul><li>阅读开源、基础库代码<ul><li>例如：Linux 内核、C++ STL 库 等等</li></ul></li><li>查找业务关联概念<ul><li>例如，库存单位：<code>sku</code> ( Stock Keeping Unit )；搜索简称：<code>qv</code> (Query View Count)</li></ul></li></ul><h4 id="更好的命名方法"><a href="#更好的命名方法" class="headerlink" title="更好的命名方法"></a>更好的命名方法</h4><ul><li><p>遵从惯例、标准</p><blockquote><p>不要使用<code>identifier</code>，而是使用业界惯例 <code>id</code>  作为唯一标识命名。类似的：</p><ul><li><code>ptr</code> 为<code>pointer</code>的缩写；</li><li><code>i</code>、<code>j</code>、<code>k</code> 常常是完美的循环计数变量命名。</li><li><code>size</code>、 <code>capacity</code>、<code>resize</code>、<code>reserve</code>、<code>push</code>、<code>pop</code>、<code>top</code>、<code>back</code>，作为容器的接口，久经考验。要自定义容器不应该使用 <code>GetSize</code> 等命名。</li></ul></blockquote></li><li><p>遵从约束</p><ul><li>语言约束：例如，Go 语言 使用 <code>驼峰</code> 风格，代码中就不要使用C语言的 <code>大写下划线连词</code> 风格</li><li>团队约束：对同一个概念，团队内已经有对应的称呼，应该遵从，而是不是任性夹带私货，例如：直播中（<code>ongoing</code> vs <code>living</code>），已经命名为 <code>ongoing</code> ，要么替换为 <code>living</code>；就全部替换掉，要么继续使用 <code>ongoing</code>，虽然后者更确切。</li><li>框架约束：使用 <a href="https://github.com/Shopify/sarama" target="_blank" rel="noopener">Shopify/sarama</a> 作为 kafka 的 客户端就应该使用<code>Consumer</code>、<code>ConsumerGroup</code>、<code>ConsumerGroupHandler</code>，命名三个层级，而不是自撰 三个层级：<code>Dao</code>、<code>Consumer</code>、<code>Processor</code> </li></ul></li><li><p>对齐、对称</p><blockquote><p>对齐: Golang 标准库包名，httptest、httputil、httptrace</p><p>对称：典型的对称，<code>producer</code>/<code>consumer</code>、<code>begin</code>/<code>end</code>、<code>create</code>/<code>destory</code>、<code>destination</code>/<code>source</code>、<code>get</code>/<code>release</code>、<code>increment</code>/<code>decrement</code>、<code>insert</code>/<code>delete</code>、<code>next</code>/<code>previous</code>、<code>old</code>/<code>new</code>、<code>old</code>/<code>new</code>、<code>open</code>/<code>close</code>、<code>put</code>/<code>get</code>、<code>show</code>/<code>hide</code>、<code>start</code>/<code>stop</code>、<code>target</code>/<code>source</code>、</p></blockquote></li></ul><h3 id="Level-3-领域语言（Domain-language）"><a href="#Level-3-领域语言（Domain-language）" class="headerlink" title="Level 3: 领域语言（Domain language）"></a>Level 3: 领域语言（Domain language）</h3><p>人对名字的反应是潜意识的…所以如果对一个名字有疑惑，可能很难确切地表达原因。我们的设计系统命名应该符合预期。… 但是谁的期望？所有利益相关者，系统的利益相关者，包括但不限于：</p><ul><li>产品经理</li><li>开发（前端、后端、客户端）</li><li>测试</li><li>用户</li></ul><p>代码应该自动使用与业务或领取模型相同的名称。例如，如果一个旅游企业使用 “<strong>venue</strong>” 作为咖啡馆、酒店和旅游景点的通用名称，那么在代码中使用 “<strong>place</strong>” 是一个坏主意</p><blockquote><ul><li>其一，因为使用两种不同的语言，使得沟通变得更复杂</li><li>其二，如果一个词汇，产品经理和用户等不理解软件开发同学的都能直观的理解，那么此命名将是一个好的名字</li><li>其三，将代码命名与领域模型关联起来，所有命名跟业务是契合的</li><li>其四，随着需求迭代，打磨领域模型的同时，可以保证命名随之重构符合语义，保持<strong>常新</strong></li></ul></blockquote><p>使用领域语言统一开发流程，可以从根本上解释命名来源以及合理性。相比一般的技巧，是系统的有理论支撑的。如果技巧是工程派的产出，那么领域语言指导命名就像是学院派的产出。</p><p>具体如何在项目中实施DDD，后续详解。</p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/07-04-2020/how-to-naming-things.html">https://www.cyningsun.com/07-04-2020/how-to-naming-things.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;br/&gt;

&lt;p&gt;There are only two hard things in Computer Science: cache invalidation and naming things.         —— Phil Karlton&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>REST API 设计规范</title>
    <link href="https://www.cyningsun.com/06-29-2020/how-to-write-restful-api.html"/>
    <id>https://www.cyningsun.com/06-29-2020/how-to-write-restful-api.html</id>
    <published>2020-06-28T16:00:00.000Z</published>
    <updated>2020-07-21T13:27:15.852Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中往往会需要确定一个好的API风格，到底有哪些风格可以参考，API Style 的细节要点有哪些呢？</p><h3 id="Http-API-Style-有哪些？"><a href="#Http-API-Style-有哪些？" class="headerlink" title="Http API Style 有哪些？"></a>Http API Style 有哪些？</h3><ul><li>SOAP：tend to be centered around operations that are usually use-case specific and specialized. </li><li>REST：centered around business (data) entities exposed as resources that are identified via URIs and can be manipulated via standardized CRUD-like methods using different representations, and hypermedia</li><li>GraphQL：a query language for APIs and a runtime for fulfilling those queries with your existing data</li></ul><p>SOAP 风格（严格来说，算不上风格）最早于1998年由微软提出；REST 风格于2000年 由 Roy Thomas Fielding 论文中提出；GraphQL 于2015年由 Facebook 提出；</p><ul><li>SOAP vs REST</li></ul><blockquote><p> 如果要轻松、快速地完成API设计，SOAP 风格的API就足够了。毕竟REST有时很难做到，尤其是在一开始。但随着时间的推移，使用RESET 风格的API，服务器端的演进变得更容易，客户机对变化的适应能力也更强。</p></blockquote><ul><li><p>REST vs GraphQL</p><blockquote><p>REST 限于其历史背景，对于 <code>查询</code> 操作一些细节并没有太多描述，随着互联网的发展，查询的复杂度越来越高，而 GraphQL 是一个很好的补充。</p></blockquote></li></ul><p>在业界有将近70%的API是REST-like的风格，其中当然就包括谷歌、微软等行业巨头，REST 差不多已经成为了事实上的标准，了解、用好 REST 十分必要。</p><h3 id="REST-是什么？"><a href="#REST-是什么？" class="headerlink" title="REST 是什么？"></a>REST 是什么？</h3><p>REST，全称是 Resource Representational State Transfer：通俗来讲就是：资源在网络中以某种表现形式进行状态转移。分解开来：</p><ul><li>Resource：资源，即数据（前面说过网络的核心）。比如 newsfeed，friends等；</li><li>Representational：某种表现形式，比如用JSON，XML，JPEG等；</li><li>State Transfer：状态变化。通过HTTP动词实现。</li></ul><h4 id="资源模型"><a href="#资源模型" class="headerlink" title="资源模型"></a>资源模型</h4><p>资源是具有类型、数据、与其他资源关系、以及一组对其进行操作的方法的对象。</p><p><img src="/images/restful-concepts.png" alt="_images/concepts.png"></p><h4 id="Richardson成熟度模型"><a href="#Richardson成熟度模型" class="headerlink" title="Richardson成熟度模型"></a>Richardson成熟度模型</h4><h5 id="Level-0"><a href="#Level-0" class="headerlink" title="Level 0"></a>Level 0</h5><p>不使用任何URI，HTTP方法和HATEOAS功能。</p><p>该模型的出发点是使用HTTP作为远程交互的传输系统，但不使用Web的任何机制。基本上就是使用HTTP作为你远程交互机中的隧道机制，通常基于“远程过程调用“（RPC，<a href="http://www.eaipatterns.com/EncapsulatedSynchronousIntegration.html" target="_blank" rel="noopener">Remote Procedure Invocation</a> ）。</p><h5 id="Level-1-Resources"><a href="#Level-1-Resources" class="headerlink" title="Level 1 - Resources"></a>Level 1 - Resources</h5><p><strong>使用</strong> URI、HTTP方法、HATEOAS中的<strong>URI</strong>。</p><p>迈向REST的第一步就是引入资源的概念。接下来，我们所要讨论的是各个资源，而不是将所有请求发送到单一的服务端点。每个资源都由唯一的URI单独标识</p><h5 id="Level-2-HTTP-Verbs"><a href="#Level-2-HTTP-Verbs" class="headerlink" title="Level 2 - HTTP Verbs"></a>Level 2 - HTTP Verbs</h5><p><strong>使用</strong> URI、HTTP方法、HATEOAS中<strong>的URI和HTTP</strong>。</p><p>支持每个公开资源上的几个HTTP谓词 - 创建，读取，更新和删除（CRUD）服务。通常代表业务实体的资源状态可以通过网络进行操作。</p><h5 id="Level-3-Hypermedia-Controls"><a href="#Level-3-Hypermedia-Controls" class="headerlink" title="Level 3 - Hypermedia Controls"></a>Level 3 - Hypermedia Controls</h5><p><strong>使用所有三个，即URI，HTTP和HATEOAS</strong>。</p><p>超媒体控制的关键在于它告诉我们下一步我们可以做什么，以及操作所需资源的URI。与我们必须提前知道在哪里创建预约请求不同（Level2中），在响应中的 HATEOAS 告诉了我们下一步该如何做，以完成应用程序状态转换。</p><h3 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h3><p>REST 本身不是标准，只是一种风格。因此只要遵从该风格，都是OK的。然而，除此之外我们逃不开使用中遇到的很多问题，最典型的问题，如下：</p><ul><li>Error Handling</li><li>Sorting</li><li>Pagination</li><li>versioning</li><li>filtering</li><li>Long running</li><li>Sub-collection</li><li>Action(i.e. Batch Operation)</li></ul><h4 id="Error-handling"><a href="#Error-handling" class="headerlink" title="Error handling"></a>Error handling</h4><p>详见：<a href="https://www.cyningsun.com/06-07-2020/unified-error-handling.html">跨服务错误处理</a></p><h4 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h4><p>如果 API 方法允许客户端指定列表结果的排序顺序，则请求消息<strong>应该</strong>包含一个字段：</p><pre><code class="hljs go"><span class="hljs-keyword">string</span> order_by = ...;</code></pre><blockquote><p><strong>说明</strong>：语法中的冗余空格字符是无关紧要的。<code>&quot;foo,bar desc&quot;</code> 和 <code>&quot; foo , bar desc &quot;</code> 是等效的。</p></blockquote><p>字符串值<strong>应该</strong>遵循 SQL 语法：逗号分隔的字段列表。例如：<code>&quot;foo,bar&quot;</code>。默认排序顺序为升序。要将字段指定为降序，<strong>应该</strong>将后缀 <code>&quot; desc&quot;</code> 附加到字段名称中。例如：<code>&quot;foo desc,bar&quot;</code>。</p><h4 id="Pagination"><a href="#Pagination" class="headerlink" title="Pagination"></a>Pagination</h4><ul><li>可列表集合<strong>应该</strong>支持分页，即使结果通常很小。</li></ul><blockquote><p><strong>说明</strong>：如果某个 API 从一开始就不支持分页，稍后再支持它就比较麻烦，因为添加分页会破坏 API 的行为。 不知道 API 正在使用分页的客户端可能会错误地认为他们收到了完整的结果，而实际上只收到了第一页。</p></blockquote><ul><li><p>翻页方式</p><table><thead><tr><th>后台存储</th><th>Request</th><th>Response</th></tr></thead><tbody><tr><td>搜索引擎</td><td>{    <br />“page_num”: 1,   // 页码从 1 开始<br/><br/>     “page_size”: 10<br/><br/>}</td><td>{  <br/>“code”: 0,  <br/>“msg”: “”,  <br/>“data”: {<br/><br/>“total_cnt”: 100,<br/><br/>“items”: []<br/><br/>}  <br/>}</td></tr><tr><td>数据库</td><td>{<br/><br/>     “last_id”: 1,   //  第一页，默认传0<br/><br/>     “page_size”: 10<br/><br/>}</td><td>{<br/>“code”: 0,<br/>“msg”: “”,<br/>“data”: {<br/><br/>     “items”: [],<br/><br/>     “next_id”: 10   // 下一页放到last_id的值<br/><br/>}<br/>}</td></tr><tr><td></td><td></td><td></td></tr></tbody></table></li></ul><h4 id="Versioning"><a href="#Versioning" class="headerlink" title="Versioning"></a>Versioning</h4><h5 id="业界方案"><a href="#业界方案" class="headerlink" title="业界方案"></a>业界方案</h5><ul><li><p>无版本控制<br>这是最简单的方法，它对于一些内部 API 来说可能是可以接受的。 重大变化可以表示为新资源或新链接。 向现有资源添加内容可能不会带来重大更改，因为不希望看到此内容的客户端应用程序将忽略它。</p><pre><code class="hljs http"><span class="hljs-attribute">https://adventure-works.com/customers/3</span></code></pre></li><li><p>URI 版本控制<br>每次修改 Web API 或更改资源的架构时，向每个资源的 URI 添加版本号。 以前存在的 URI 应像以前一样继续运行，并返回符合原始架构的资源。</p><pre><code class="hljs http"><span class="hljs-attribute">https://adventure-works.com/v2/customers/3</span></code></pre></li><li><p>查询字符串版本控制<br>不是提供多个 URI，而是可以通过在追加到 HTTP 请求后面的查询字符串中使用参数来指定资源的版本，例如</p><pre><code class="hljs http">https://adventure-works.com/customers/3?version=2</code></pre><blockquote><p><strong>注意：</strong>某些较旧的 Web 浏览器和 Web 代理不会缓存在 URI 中包含查询字符串的请求的响应。 这可能会降低使用 Web API 并在此类 Web 浏览器中运行的 Web 应用程序的性能。 </p></blockquote></li><li><p>标头版本控制<br>  不是追加版本号作为查询字符串参数，而是可以实现指示资源的版本的自定义标头。 此方法需要客户端应用程序将相应标头添加到所有请求，虽然如果省略了版本标头，处理客户端请求的代码可以使用默认值（版本 1）。 下面的示例使用了名为 Custom-Header 的自定义标头**。 此标头的值指示 Web API 的版本。</p><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">https://adventure-works.com/customers/3</span> HTTP/1.1<span class="hljs-attribute">Custom-Header</span>: api-version=1</code></pre></li><li><p>无版本控制：在更改RESTful API时，请以兼容的方式进行更改，并避免生成其他API版本。</p><blockquote><p><strong>说明</strong>：多个版本会使理解、测试、维护、发展、操作和发布我们的系统变得非常复杂。</p></blockquote></li></ul><p>在更改RESTful api时，请以兼容的方式进行更改，并避免生成其他API版本。多个版本可能会显著地复杂化查看、测试、维护、发展、运营和发布系统（<a href="http://martinfowler.com/articles/enterpriseREST.html" target="_blank" rel="noopener">补充阅读</a>)。如果无法以兼容的方式更改API，请使用这三种方式：</p><ul><li>在旧资源变体的基础上创建新资源（变量）</li><li>创建一个新的服务端点-即一个具有新API的新应用程序（使用新域名）</li><li>在微服务中创建一个新的API版本，该版本支持与旧API同时支持</li></ul><h5 id="Filtering"><a href="#Filtering" class="headerlink" title="Filtering"></a>Filtering</h5><p>在参数过滤时通常会为参数值定义数据格式。为了在所有 API 中提供一致的开发者体验并减少学习曲线，API 设计人员<strong>必须</strong>使用以下<a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F#%E7%BA%A6%E5%AE%9A" target="_blank" rel="noopener">扩展巴科斯范式</a>（Extended Backus-Naur Form，简写为“EBNF”）语法的变体来定义这样的语法：</p><pre><code class="hljs javascript">Production  = name <span class="hljs-string">"="</span> [ Expression ] <span class="hljs-string">";"</span> ;Expression  = Alternative &#123; <span class="hljs-string">"|"</span> Alternative &#125; ;Alternative = Term &#123; Term &#125; ;Term        = name | TOKEN | Group | Option | Repetition ;Group       = <span class="hljs-string">"("</span> Expression <span class="hljs-string">")"</span> ;Option      = <span class="hljs-string">"["</span> Expression <span class="hljs-string">"]"</span> ;Repetition  = <span class="hljs-string">"&#123;"</span> Expression <span class="hljs-string">"&#125;"</span> ;</code></pre><blockquote><p><strong>注意</strong>：<code>TOKEN</code> 表示在语法之外定义的终端符号。</p></blockquote><p>Example</p><pre><code class="hljs http">GET /zoos?id=1001,1002,1003</code></pre><h4 id="Long-running"><a href="#Long-running" class="headerlink" title="Long running"></a>Long running</h4><p>有时，POST、PUT、PATCH 或 DELETE 操作可能需要一段时间才能完成。如果需要等待该操作完成后才能向客户端发送响应，可能会造成不可接受的延迟。在这种情况下，请考虑将该操作设置为异步操作。返回 HTTP 状态代码 202（已接受），指示该请求已接受进行处理，但尚未完成。</p><p>应公开一个可返回异步请求状态的终结点，使客户端能够通过轮询状态终结点来监视状态。在 202 响应的 Location 标头中包含状态终结点的 URI。例如：</p><pre><code class="hljs http">HTTP/1.1 <span class="hljs-number">202</span> Accepted<span class="hljs-attribute">Location</span>: /api/status/12345</code></pre><p>如果客户端向此终结点发送 GET 请求，响应中应包含该请求的当前状态。（可选）响应中还可以包含预计完成时间，或者用于取消操作的链接</p><pre><code class="hljs http">HTTP/1.1 <span class="hljs-number">200</span> OK<span class="hljs-attribute">Content-Type</span>: application/json<span class="json">&#123;    <span class="hljs-attr">"status"</span>:<span class="hljs-string">"In progress"</span>,    <span class="hljs-attr">"link"</span>: &#123; <span class="hljs-attr">"rel"</span>:<span class="hljs-string">"cancel"</span>, <span class="hljs-attr">"method"</span>:<span class="hljs-string">"delete"</span>, <span class="hljs-attr">"href"</span>:<span class="hljs-string">"/api/status/12345"</span> &#125;&#125;</span></code></pre><p>如果异步操作创建了新资源，则该操作完成后，状态终结点应返回状态代码 303（查看其他）。在 303 响应中，包含一个 Location 标头用于提供新资源的 URI：</p><pre><code class="hljs http">HTTP/1.1 <span class="hljs-number">303</span> See Other<span class="hljs-attribute">Location</span>: /api/orders/12345</code></pre><p>有关详细信息，请参阅<a href="https://docs.microsoft.com/zh-cn/azure/architecture/patterns/async-request-reply" target="_blank" rel="noopener">异步请求-回复模式</a>。</p><h4 id="Sub-collection"><a href="#Sub-collection" class="headerlink" title="Sub-collection"></a>Sub-collection</h4><p>有时，API 需要让客户跨子集执行 <code>List/Search</code> 操作。例如，“API 图书馆”有一组书架，每个书架都有一系列书籍，而客户希望在所有书架上搜索某一本书。在这种情况下，建议在子集合上使用标准 <code>List</code>，并为父集合指定通配符集合 ID <code>&quot;-&quot;</code>。对于“API 图书馆”示例，我们可以使用以下 REST API 请求：</p><pre class="md-fences md-end-block ty-contain-cm modeLoaded">GET https://library.googleapis.com/v1/shelves/-/books/{id}</pre><blockquote><p><strong>注意</strong>：选择 <code>&quot;-&quot;</code> 而不是 <code>&quot;*&quot;</code> 的原因是为了避免需要进行 URL 转义。</p></blockquote><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p><ul><li>GET（SELECT）：从服务器取出资源（一项或多项）。</li><li>POST（CREATE）：在服务器新建一个资源。</li><li>PUT（UPDATE）：在服务器更新资源（客户端提供改变的属性）</li><li>DELETE（DELETE）：从服务器删除资源。</li></ul><p>对于非标准的操作，以上动词无法无法满足需求，可以在资源上使用“操作”子集合。 动作基本上类似于RPC的消息，用于对资源执行特定操作。 “动作”子集合可以看作是一个命令队列，可以将新的动作发布到该命令队列中，然后由API执行。定义标准动词如下：</p><ol><li>batch：批量操作</li><li>search：搜索操作</li></ol><pre><code class="hljs html">GET /zoos：列出所有动物园POST /zoos：新建一个动物园GET /zoos/ID：获取某个指定动物园的信息PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）DELETE /zoos/ID：删除某个动物园GET /zoos/ID/animals：列出某个指定动物园的所有动物DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物GET /zoos/-/action/batch  批量查询POST /zoos/-/action/batch 批量更新POST /zoos/-/action/search 搜索</code></pre><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p>对 <code>null</code> 和不存在的属性使用相同的语义</p><table><thead><tr><th>required</th><th>nullable</th><th>{}</th><th>{“example”:null}</th></tr></thead><tbody><tr><td><code>true</code></td><td><code>true</code></td><td>✗ No</td><td>✔ Yes</td></tr><tr><td><code>false</code></td><td><code>true</code></td><td>✔ Yes</td><td>✔ Yes</td></tr><tr><td><code>true</code></td><td><code>false</code></td><td>✗ No</td><td>✗ No</td></tr><tr><td><code>false</code></td><td><code>false</code></td><td>✔ Yes</td><td>✗ No</td></tr></tbody></table></li><li><p>路径使用 中划线 <code>-</code> 代替 下划线 <code>_</code>；</p><blockquote><p>在搜索引擎中，把中划线当做空格处理，而下划线是被忽略的。使用中划线是对搜索引擎友好的写法</p></blockquote><p>Example:</p>  <pre><code class="hljs applescript">/shipment-orders/&#123;shipment-order-<span class="hljs-built_in">id</span>&#125;</code></pre></li><li><p>范围</p><p>表示范围的字段<strong>应该</strong>使用半开区间和命名惯例 <code>[start_xxx, end_xxx)</code>，例如 <code>[start_key, end_key)</code> 或 <code>[start_time, end_time)</code>。通常 C ++ STL 库和 Java 标准库会使用半开区间语义。API <strong>应该</strong>避免使用其他表示范围的方式，例如 <code>(index, count)</code> 或 <code>[first, last]</code>。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>完成以上这些，也仅仅是达到REST Level 2，由于Level 3 对于API风格影响不大，暂不涉及。对 HATEOAS 感兴趣，可以参考 Github v3 版本的API。</p><p><strong>参考链接</strong></p><ul><li><a href="https://cloud.google.com/apis/design" target="_blank" rel="noopener">Google Cloud API guide</a></li><li><a href="https://docs.microsoft.com/zh-cn/azure/architecture/best-practices/api-design" target="_blank" rel="noopener">Microsoft API design best practices</a></li><li><a href="https://opensource.zalando.com/restful-api-guidelines/" target="_blank" rel="noopener">Zalando RESTful API and Event Scheme Guidelines</a></li><li><a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md" target="_blank" rel="noopener">OpenAPI-Specification</a></li><li><a href="https://raw.githubusercontent.com/tlhunter/consumer-centric-api-design/master/pdf/Consumer-Centric%20API%20Design%20v0.4.0.pdf" target="_blank" rel="noopener">Consumer-Centric API Design v0.4.0.pdf</a></li><li><a href="https://stackoverflow.com/questions/19843480/s3-rest-api-and-post-method/19844272#19844272" target="_blank" rel="noopener">s3 rest api and post method</a></li><li><a href="https://stackoverflow.com/questions/29584903/what-is-hypermedia-hypermedia-controls-hypermedia-formats/29586455#29586455" target="_blank" rel="noopener">what is hypermedia hypermedia controls hypermedia formats</a></li><li><a href="https://martinfowler.com/articles/enterpriseREST.html" target="_blank" rel="noopener">Enterprise Integration Using REST</a></li></ul><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/06-29-2020/how-to-write-restful-api.html">https://www.cyningsun.com/06-29-2020/how-to-write-restful-api.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在项目中往往会需要确定一个好的API风格，到底有哪些风格可以参考，API Style 的细节要点有哪些呢？&lt;/p&gt;
&lt;h3 id=&quot;Http-API-Style-有哪些？&quot;&gt;&lt;a href=&quot;#Http-API-Style-有哪些？&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>跨服务错误处理</title>
    <link href="https://www.cyningsun.com/06-07-2020/unified-error-handling.html"/>
    <id>https://www.cyningsun.com/06-07-2020/unified-error-handling.html</id>
    <published>2020-06-06T16:00:00.000Z</published>
    <updated>2020-07-21T13:30:28.369Z</updated>
    
    <content type="html"><![CDATA[<p>无论使用什么语言，错误处理都是系统中很关键的一个点。优雅的错误处理能够极大的提高代码的整洁度，而代码整洁度又直接影响可维护性，但是要实现优雅的错误处理却并非易事。那究竟难在哪里呢？</p><ol><li><p>重复的错误处理代码</p><blockquote><pre><code class="hljs json">_, err = fd.Write(p2[e:f])if err != nil &#123;    fmt.Println(err, ...)    return err&#125;</code></pre><p>在分层系统中（例如：Controller、Service、DAO），每一层都会重复以上代码</p></blockquote></li><li><p>原始错误的上下文</p><blockquote><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AuthenticateRequest</span><span class="hljs-params">(r *Request)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">return</span> authenticate(r.User)&#125;</code></pre><p>如果 <code>authenticate</code> 返回错误，那么 <code>AuthenticateRequest</code> 会将错误返回给调用者，调用者也可能会这样做，依此类推。 在程序的顶部，程序的主体将错误打印到屏幕或日志文件，所有打印的都会是： <code>No such file or directory</code></p></blockquote></li><li><p>原始错误 vs 错误码错误</p><blockquote><pre><code class="hljs go">errors.New(<span class="hljs-string">"connection error"</span>)<span class="hljs-comment">// vs </span><span class="hljs-keyword">var</span> errno <span class="hljs-keyword">uint32</span> = <span class="hljs-number">10001</span>errors.New(errno, <span class="hljs-string">"connection error"</span>)</code></pre><p>标准库或第三方应用库返回的是一般是上一种错误，然而H5或APP不可能根据字符串进行错误判断。因此在业务中需要把所有的错误进行统一封状为错误码错误返回，那么错误码错误中需要保存原始错误么？</p></blockquote></li><li><p>RPC错误 vs 业务错误</p><blockquote><ul><li>一方面，与业务层的错误相似，RPC框架也会自己的错误。而RPC框架往往也会集成一些包括过载处理、异常节点剔除的功能，依赖于对两种错误的识别能力。该如何设计错误才能让两者区分开来呢？</li><li>另一方面，无论是RPC框架错误和业务错误，调用端都需要进行统一解码（decode）。该如何设计错误才能让两者融合起来呢？</li></ul></blockquote></li></ol><p>从简单来看，所有问题是相互独立的，但是透过现象来看本质。以上问题又都有关联，在于进行错误模型设计。从业界各种框架的设计情况来看，可以把错误分为以下三种：</p><p><img src="/images/error-model.png" alt=""></p><ul><li><p><strong>Error codes model</strong></p><!-- Errors are raised under various circumstances, from network failures to unauthenticated connections, each of which is associated with a particular code. --><blockquote><p>从网络故障到未经验证的连接，各种情况下都会引发错误，每种错误都可以都与特定错误码关联。</p></blockquote></li><li><p><strong>Standard error model</strong></p><!-- If an error occurs, return error codes instead, with an optional string error message that provides further details about what happened. --><blockquote><p>如果发生错误，则返回错误代码以及一条可选的字符串错误信息，该信息提供有关所发生事件的详细信息。</p></blockquote></li><li><p><strong>Richer error model</strong></p><!-- Enables servers to return and clients to consume additional error details. It further specifies a standard set of error message types to cover the most common needs (such as invalid parameters, quota violations, and stack traces). --><blockquote><p>允许服务器和客户端返回、使用额外的错误详细信息。它进一步指定了一组标准的错误消息类型，以满足最常见的需求（例如无效参数、配额冲突和堆栈跟踪）</p></blockquote></li></ul><p>三种类型的错误，层层递进，能够囊括的信息也越来越多。当然，信息越是丰富，框架实现难度越高，对使用者也越友好。在微信，svrkit 选择的模型是<code>Error codes model</code>；开源框架 grpc 选择的模型则是<code>Standard error model</code> ，但是本身支持<code>Richer error model</code>，参考：<a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto" target="_blank" rel="noopener">googleapis</a></p><p>想清楚了问题，再看解决问题的方案：</p><ul><li><p>难点 1、2：可以按照以下两种思想来解决：<a href="https://www.cyningsun.com/08-19-2019/errors-are-values-cn.html">《Errors are values》</a>、<a href="https://www.cyningsun.com/09-09-2019/dont-just-check-errors-handle-them-gracefully-cn.html">Don’t just check errors, handle them gracefully</a></p></li><li><p>难点 3：错误的主要作用有以下两点：</p><blockquote><ul><li><p>根据错误的类型，进行针对性的处理</p></li><li><p>错误原因追踪</p></li></ul></blockquote><p>前者可以使用错误码来代替，后者可以简化为message。即，毋需保留错误本身，只需要将错误转化为错误码和message。</p></li><li><p>难点 4：即根据需要选择合适的错误模型，统一业务错误和框架错误。区分业务错误和框架错误，可以将 code 分段，框架优先占有指定的号段。</p><blockquote><p>更进一步，code 号段可以融合到服务治理中，在服务申请阶段分配对应的号段</p></blockquote></li></ul><!--  [**Error Handling**: How gRPC deals with errors, and gRPC error codes](https://grpc.io/docs/guides/error/)[Google API 错误模型](https://cloud.google.com/apis/design/errors) --><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/06-07-2020/unified-error-handling.html">https://www.cyningsun.com/06-07-2020/unified-error-handling.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;无论使用什么语言，错误处理都是系统中很关键的一个点。优雅的错误处理能够极大的提高代码的整洁度，而代码整洁度又直接影响可维护性，但是要实现优雅的错误处理却并非易事。那究竟难在哪里呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;重复的错误处理代码&lt;/p&gt;
&lt;blockquote&gt;
&lt;pr
      
    
    </summary>
    
    
      <category term="Error handling" scheme="https://www.cyningsun.com/category/Error-handling/"/>
    
    
      <category term="跨服务" scheme="https://www.cyningsun.com/tag/%E8%B7%A8%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Coaching中的版本思维</title>
    <link href="https://www.cyningsun.com/05-23-2020/why-version-is-important-when-coaching.html"/>
    <id>https://www.cyningsun.com/05-23-2020/why-version-is-important-when-coaching.html</id>
    <published>2020-05-22T16:00:00.000Z</published>
    <updated>2020-05-22T16:47:03.551Z</updated>
    
    <content type="html"><![CDATA[<p>你是否在工作中遇到过以下场景：</p><blockquote><ul><li><p>A 同学在做一个方案设计，针对方案中的某些部分。A 同学纯凭口述向你讲述了下他面临的困境，并向你请教“我这样做对不对？”</p></li><li><p>B 同学是一个新手，在负责实现 XXX 功能。该功能的目标比较明确，但是具体实现有一定的探索性。 B 同学会向你确认“我是不是该这么做？”</p></li></ul></blockquote><p>此时，作为团队 Leader 或者导师的你，应该正面回答他“对还是不对”、“应该还是不应该” 么？</p><p>初出茅庐时，我也遇到过类似的问题，一般都会依据自己的经验给予解答，殊不知大错特错。每一次的解答都像给对方的习惯打了一剂增强针，引来对方后续源源不断的问题。</p><p>为什么会有源源不断的问题？</p><blockquote><ul><li>你的答案终止了他的思考，使其不能更进一步，能力原地打转</li><li>你的结论如果与其不同，可能会伤害其自信。以后遇到类似的问题，他将再次问你。</li><li>探索性的问题，他几乎不可能提供全部的Context，你根据描述产出的结论可能会是错的</li><li>限于其能力，其描述与实际产出可能有出入，不适合根据描述作出结论</li><li>可能会因为权威的因素，附和或顺从你的结论</li><li>无论结论对错，你都将负责结果，责任感缺位可能会降低其积极性</li></ul></blockquote><p>Coaching 的时候，会遇到有些同学或是“不敢拍板”；或是”相信权威“；或是”想走捷径“；或是”喜欢拍脑袋“，使用口头的描述来征求建议。让我意识到所有的建议，应该建立在“完整”的、“可版本管理”的产出物之上。</p><p><img src="/images/why-version-is-important-when-coaching/versioning-control.png" alt=""></p><ol><li>该产出物可以是：</li></ol><blockquote><ol><li><p>设计文档</p></li><li><p>代码</p></li><li><p>步骤清单</p><p>…</p></li></ol></blockquote><ol start="2"><li>完整意味着，“建议”只能用来改良产出物，而不是用来完善或成为产出物的一部分。</li></ol><p><img src="/images/why-version-is-important-when-coaching/changes.svg" alt=""></p><p>只有如此，“建议”的才能产出一个新的版本。提问者可以根据两个版本的 <code>diff</code>，理解发生了什么，进行自我纠偏和总结。</p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/05-23-2020/why-version-is-important-when-coaching.html">https://www.cyningsun.com/05-23-2020/why-version-is-important-when-coaching.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你是否在工作中遇到过以下场景：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A 同学在做一个方案设计，针对方案中的某些部分。A 同学纯凭口述向你讲述了下他面临的困境，并向你请教“我这样做对不对？”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;B 同学是一个新手，在负责实
      
    
    </summary>
    
    
      <category term="Coaching" scheme="https://www.cyningsun.com/category/Coaching/"/>
    
    
      <category term="Coaching" scheme="https://www.cyningsun.com/tag/Coaching/"/>
    
  </entry>
  
  <entry>
    <title>使用 go race 排查 protobuf Marshal Panic</title>
    <link href="https://www.cyningsun.com/05-11-2020/proto-marshal-panic.html"/>
    <id>https://www.cyningsun.com/05-11-2020/proto-marshal-panic.html</id>
    <published>2020-05-10T16:00:00.000Z</published>
    <updated>2020-05-11T15:39:33.173Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>在斋月节大促压测期间，有一个业务压测发现，有一个RPC调用，在高并发的情况下出现panic，而panic的位置是在微服务框架序列化的位置(proto.Marshal)。但是由于框架在近期没有做什么变更，而且业务最近也没上线什么新的需求。所有的Panic仅在并发量较高的时候偶然出现，并且被框架的recover捕获，因此判定此问题已经在线上很久，只是由于出现的概率较低没有被发现。</p><p>示例代码：</p><pre><code class="hljs go"><span class="hljs-number">2020</span>/<span class="hljs-number">05</span>/<span class="hljs-number">11</span> <span class="hljs-number">19</span>:<span class="hljs-number">56</span>:<span class="hljs-number">32</span> http: <span class="hljs-built_in">panic</span> serving <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">59816</span>: runtime error: index out of <span class="hljs-keyword">range</span>goroutine <span class="hljs-number">20</span> [running]:net/http.(*conn).serve.func1(<span class="hljs-number">0xc00015e0a0</span>)/usr/local/Cellar/<span class="hljs-keyword">go</span>@<span class="hljs-number">1.12</span>/<span class="hljs-number">1.12</span><span class="hljs-number">.13</span>/libexec/src/net/http/server.<span class="hljs-keyword">go</span>:<span class="hljs-number">1769</span> +<span class="hljs-number">0x139</span><span class="hljs-built_in">panic</span>(<span class="hljs-number">0x13c1cc0</span>, <span class="hljs-number">0x175ad90</span>)/usr/local/Cellar/<span class="hljs-keyword">go</span>@<span class="hljs-number">1.12</span>/<span class="hljs-number">1.12</span><span class="hljs-number">.13</span>/libexec/src/runtime/<span class="hljs-built_in">panic</span>.<span class="hljs-keyword">go</span>:<span class="hljs-number">522</span> +<span class="hljs-number">0x1b5</span>github.com/cyningsun/<span class="hljs-keyword">go</span>-test/<span class="hljs-number">20200508</span>-<span class="hljs-keyword">go</span>-race/pb.encodeVarintPerson(<span class="hljs-number">0xc000228ec0</span>, <span class="hljs-number">0x3c</span>, <span class="hljs-number">0x3c</span>, <span class="hljs-number">0x3c</span>, <span class="hljs-number">0x1f</span>, <span class="hljs-number">0x3b</span>)/Users/yinhang.sun/Documents/workspace/src/github.com/cyningsun/<span class="hljs-keyword">go</span>-test/<span class="hljs-number">20200508</span>-<span class="hljs-keyword">go</span>-race/pb/person.pb.<span class="hljs-keyword">go</span>:<span class="hljs-number">146</span> +<span class="hljs-number">0x6a</span>.../Users/yinhang.sun/Documents/workspace/src/github.com/cyningsun/<span class="hljs-keyword">go</span>-test/<span class="hljs-number">20200508</span>-<span class="hljs-keyword">go</span>-race/pb/person.pb.<span class="hljs-keyword">go</span>:<span class="hljs-number">47</span> +<span class="hljs-number">0x5b</span>github.com/gogo/protobuf/proto.Marshal(<span class="hljs-number">0x14af2e0</span>, <span class="hljs-number">0xc0000bc040</span>, <span class="hljs-number">0x1</span>, <span class="hljs-number">0x140e400</span>, <span class="hljs-number">0xc0000bc040</span>, <span class="hljs-number">0xc00015c001</span>, <span class="hljs-number">0x0</span>).../usr/local/Cellar/<span class="hljs-keyword">go</span>@<span class="hljs-number">1.12</span>/<span class="hljs-number">1.12</span><span class="hljs-number">.13</span>/libexec/src/net/http/server.<span class="hljs-keyword">go</span>:<span class="hljs-number">2884</span> +<span class="hljs-number">0x2f4</span></code></pre><p>由于报错的结构体是业务最常用的一个，且报错的接口逻辑较深，通读代码也没有发现明显的点（其实是代码量太大了，很难关注的到）。报错又出现在框架层，panic 调用栈并没有提供任何有效信息。</p><h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><p>经过背景的一系列分析之后，所有的排查思路都被打断了。好在我们发现报错的错误类型是<code>index out of range</code>，通过阅读proto.Marshal的代码之后发现，此函数分为三步：</p><pre><code class="hljs go">siz := info.Size(pb)b := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">0</span>, siz)<span class="hljs-keyword">return</span> info.Marshal(b, pb, <span class="hljs-literal">false</span>)</code></pre><ol><li>先获取结构体 Size</li><li>然后按照 Size 创建字节数组</li><li>将数据序列化到字节数组中</li></ol><p>因此，合理猜测是再获取 Size之后，Marshal之前，结构体的大小发生了变化。将 protobuf 的类型分类，可以排除固定长度的数值类型，剩下就是变长的 string 类型和 bytes 类型。虽然有了这个推论，由于发生panic的结构体十分复杂，还是很难定位到具体是哪个字段变化导致的。最后没有办法只有使用很笨的方法，修改 vendor 中的 protobuf 代码，添加日志，使用二分法，在info.Size()和info.Marshal()中打印字段的偏移量，并且在proto.Marshal中直接捕获发生panic的协程再打印数据，避免全部打印时panic请求与日志无法对应。然后对比排查，最终定位到了出现问题的字段，然后根据相关字段搜索相关代码，最终定位到了问题所在。</p><h3 id="问题反思"><a href="#问题反思" class="headerlink" title="问题反思"></a>问题反思</h3><p>修复完问题之后，促使我们反思，难道排查类似的问题一定要如此艰难么，有没有什么通用的方案来排查类似的问题呢。从问题源头出发，该问题本质来说还是数据的协程并发访问题，有了这个结论再看我们手头的已有工具，golang race 工具 出现在眼前。</p><p>理论上讲，可以在非生产环境打开 race 参数，辅助定位问题。说做就做，按照问题的原因，编写测试复现的test case</p><p><strong>进程缓存</strong></p><pre><code class="hljs go"><span class="hljs-keyword">const</span> Max = <span class="hljs-keyword">uint64</span>(<span class="hljs-number">1</span>)<span class="hljs-keyword">type</span> PersonCache <span class="hljs-keyword">struct</span> &#123;c *gocache.Cache&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPersonCache</span><span class="hljs-params">()</span> *<span class="hljs-title">PersonCache</span></span> &#123;one := &amp;PersonCache&#123;c:gocache.New(time.Minute, time.Hour)&#125;<span class="hljs-keyword">go</span> one.load()<span class="hljs-keyword">return</span> one&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *PersonCache)</span> <span class="hljs-title">load</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i:=<span class="hljs-keyword">uint64</span>(<span class="hljs-number">0</span>); i &lt; Max; i++&#123;r :=  i % <span class="hljs-number">100</span>key := strconv.FormatUint(r,<span class="hljs-number">10</span>)newOne := &amp;pb.Person&#123;Id:                   proto.Uint64(r),Name:                 proto.String(<span class="hljs-string">"init Name"</span>),Age:                  proto.Uint32(rand.Uint32()),Address:   proto.String(<span class="hljs-string">"init address"</span>),&#125;p.c.Set(key, newOne, time.Minute)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *PersonCache)</span> <span class="hljs-title">Get</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(*pb.Person,<span class="hljs-keyword">bool</span>)</span></span> &#123;ret, ok := p.c.Get(key)<span class="hljs-keyword">if</span> !ok &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>&#125;<span class="hljs-keyword">return</span> ret.(*pb.Person),<span class="hljs-literal">true</span>&#125;</code></pre><p><strong>并发访问</strong></p><pre><code class="hljs go"><span class="hljs-keyword">const</span> letterBytes = <span class="hljs-string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span><span class="hljs-keyword">const</span> letterLength = <span class="hljs-built_in">len</span>(letterBytes)<span class="hljs-keyword">var</span> (c = cache.NewPersonCache())<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">randString</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">string</span></span> &#123;b := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, n)<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> b &#123;b[i] = letterBytes[rand.Intn(<span class="hljs-built_in">len</span>(letterBytes))]&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(b)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Write</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;r := rand.Uint64() % cache.Maxkey := strconv.FormatUint(r, <span class="hljs-number">10</span>)p, ok := c.Get(key)<span class="hljs-keyword">if</span> !ok &#123;<span class="hljs-keyword">return</span>&#125;p.Name = proto.String(randString(rand.Int()%letterLength))time.Sleep(time.Nanosecond)p.Address = proto.String(randString(rand.Int()%letterLength))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Read</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;r :=  rand.Uint64() % cache.Maxkey := strconv.FormatUint(r,<span class="hljs-number">10</span>)p,ok := c.Get(key)<span class="hljs-keyword">if</span> !ok &#123;<span class="hljs-keyword">return</span>&#125;b,_ := proto.Marshal(p)w.Write(b)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;http.HandleFunc(<span class="hljs-string">"/read"</span>, Read)http.HandleFunc(<span class="hljs-string">"/write"</span>, Write)fmt.Println(<span class="hljs-string">"server is listening on 8080"</span>)http.ListenAndServe(<span class="hljs-string">":8080"</span>, <span class="hljs-literal">nil</span>)&#125;</code></pre><p><strong>压测脚本</strong></p><pre><code class="hljs make">run:go run main.go &amp;&gt; normal.logracerun:go run -race main.go &amp;&gt; race.log benchmark:wrk -t1 -c2 -d30s http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;read &amp;wrk -t1 -c2 -d30s http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;write &amp;</code></pre><p><strong>日志结果</strong></p><pre><code class="hljs go">==================WARNING: DATA RACERead at <span class="hljs-number">0x00c000188140</span> by goroutine <span class="hljs-number">11</span>:  github.com/cyningsun/<span class="hljs-keyword">go</span>-test/<span class="hljs-number">20200508</span>-<span class="hljs-keyword">go</span>-race/pb.(*Person).Size()...Previous write at <span class="hljs-number">0x00c000188140</span> by goroutine <span class="hljs-number">55</span>:  main.Write()      /Users/yinhang.sun/Documents/workspace/src/github.com/cyningsun/<span class="hljs-keyword">go</span>-test/<span class="hljs-number">20200508</span>-<span class="hljs-keyword">go</span>-race/main.<span class="hljs-keyword">go</span>:<span class="hljs-number">39</span> +<span class="hljs-number">0x271</span>...</code></pre><p>通过日志，可以很轻松的发现问题的原因。</p><h3 id="总结优化"><a href="#总结优化" class="headerlink" title="总结优化"></a>总结优化</h3><p>以上过程促使我们优化非生产环境的运行脚本，通过编译参数控制 -race 参数的开关，当再遇到类似的问题时，可以快速复现、定位、修复。</p><p><em>源码链接:</em></p><p><a href="https://github.com/cyningsun/go-test/tree/master/20200508-go-race" target="_blank" rel="noopener">https://github.com/cyningsun/go-test/tree/master/20200508-go-race</a></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/05-11-2020/proto-marshal-panic.html">https://www.cyningsun.com/05-11-2020/proto-marshal-panic.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h3&gt;&lt;p&gt;在斋月节大促压测期间，有一个业务压测发现，有一个RPC调用，在高并发的情况下出现panic，而panic的位置是在微服务框架
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>移动端接入关键技术解析</title>
    <link href="https://www.cyningsun.com/05-03-2020/mobile-application-access-tech.html"/>
    <id>https://www.cyningsun.com/05-03-2020/mobile-application-access-tech.html</id>
    <published>2020-05-02T16:00:00.000Z</published>
    <updated>2020-05-11T14:03:06.688Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>随着移动互联网成长成熟，移动端逐渐涌现出与WEB不一样的产品形态。</p><ul><li><p>互动</p><blockquote><p>越来越多的互动形式的出现，各种产品向社交化、娱乐化不断迈进</p></blockquote></li><li><p>媒体化</p><blockquote><p>从文字+图片为主的生态，逐渐向以视频为主的内容生态进化</p></blockquote></li><li><p>实时性</p><blockquote><p>内容生产逐渐由推荐式替代陈列式的形态；内容促达充分利用移动特性，实时触达用户，抢占用户的碎片时间</p></blockquote></li></ul><p>以上变化也推动了移动端接入技术演化发展，不再局限于常见的“请求-响应”的通信模式。</p><p>如果把移动端接入服务分为两层：流量接入层和应用接入层，本篇文章更多侧重于应用接入层，对于流量接入层如何实现，已经在<a href="https://www.cyningsun.com/02-03-2019/access-layer-architecture.html">《高可用的接入层架构细节实现》</a>覆盖。</p><h3 id="通信方式细分"><a href="#通信方式细分" class="headerlink" title="通信方式细分"></a>通信方式细分</h3><p>如果WEB时代接入层支持<code>单工</code>即可，客户端主动获取（PULL）数据；那么移动时代接入层需要支持<code>双工</code>，服务端也可以主动推送（PUSH）数据给客户端。如果客户端也像服务端一样可以24小时在线，那么只需要支持如此两种形式的通信方式即可，然而现实情况更为复杂。</p><ol><li><p>频繁打开关闭，如何进行离线数据同步</p></li><li><p>数据同步面临 网络状况复杂、同步速度、客户端耗电量等要求</p></li><li><p>多终端离线数据同步，如何做到数据不遗漏、不重复</p></li></ol><p>基于以上几点，可以降PUSH模式进行细分，拆解成两种模式：推送数据 + 数据同步（SYNC）。总结一下，在应用接入层需要支持以下三种形式的通信模式：</p><ul><li>RPC 负责“客户端向服务端请求数据（请求 - 响应）”的通信模式；</li><li>SYNC 负责“客户端从服务端同步数据”的通信模式；</li><li>PUSH 负责“服务端向在线客户端 PUSH 数据”的通信模式。 </li></ul><p><img src="/images/mobile-application-access/layer.png" alt=""></p><h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3><p>以下的部分重点讲述实现以上通信方式所需要的关键技术</p><h4 id="SYNC-机制"><a href="#SYNC-机制" class="headerlink" title="SYNC 机制"></a>SYNC 机制</h4><p>本质上 SYNC 是基于 SyncKey 的一种同步协议。微信在聊天界面拉取所有的未读消息，很卡很耗费流量。SYNC 机制是同步差量数据，以达到了提高通信效率、节省流量的效果。</p><p>在消息投递时选择合适的 <a href="https://www.cyningsun.com/12-26-2018/id-generator.html">ID生成方案</a>，为消息绑定递增的序号。推送消息时，不是把消息直接推送下去，而是发一个通知到客户端，客户端收到通知，根据用户上翻或者下翻的行为，带上一个最近收到消息的最大的序列号，按需、分页拉取消息。此机制保障了消息不重不漏，并且可以有效支持多终端数据同步。</p><p>客户端无需实时在线，对于用户不在线的情况，SYNC Server 会将差量数据保存在数据库中。当客户端下次连接到服务器时，再同步差量数据给用户。</p><h4 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h4><p>服务端要做到主动把消息推送给客户端，就需要长连接的支持。那么长连接是不是就是 HTTP Keep Alive 呢？</p><p>HTTP Keep Alive 又被称为<code>持久连接</code>，允许 HTTP 请求结束之后将 TCP 连接保持在打开状态，以便为未来的 HTTP 请求重用现存的连接。持久连接侧重于 HTTP 应用层。</p><p>所以常说的长连接是指 TCP 长连接。在移动网络下，网络状态复杂多变，长连接会因为以下因素断开：</p><ul><li><p>长连接进程退出</p><blockquote><p>客户端被系统 Kill 掉</p></blockquote></li><li><p>用户切换网络</p><blockquote><p>手机网络断开、Wi-Fi和蜂窝数据切换</p></blockquote></li><li><p>NAT超时</p><blockquote><p>设备休眠，NAT超时，导致公网IP回收</p></blockquote></li><li><p>DHCP 过期</p><blockquote><p>DHCP 租期过期，如果没有及时续约，同样会导致IP地址失效</p></blockquote></li></ul><p>如果发生长连接断开，那么就需要尽快发现并重连，此时就需要引入<code>心跳机制</code>.</p><h4 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h4><p>在应用层做心跳检测连接断开，不熟悉的人不太能理解这一点。为什么使用应用层心跳，TCP 不是有 KeepAlive 机制么，通过这个机制来实现不就可以了吗？</p><pre><code class="hljs json">keepalive_probes  探测次数（9次）keepalive_time    探测的超时（2小时）keepalive_intvl   探测间隔(75s)</code></pre><p>事实上，TCP KeepAlive 的机制其实并不适用于此。Keep Alive 机制开启后，，如果2小时内在此套接口的任一方向都没有数据交换，TCP就自动给对方发一个保持存活探测分节（keepalive probe），会导致一下三种情况</p><ul><li>对方接收一切正常：以期望的ACK响应。2小时后，TCP将发出另一个探测分节</li><li>对方已崩溃且已重新启动：以RST响应。套接口的待处理错误被置为ECONNRESET，套接 口本身则被关闭。</li><li>对方无任何响应：TCP发送另外8个探测分节，相隔75秒一个，试图得到一个响应。一共尝试9次，即在发出第一个探测分节11分钟 15秒后若仍无响应就放弃。</li></ul><p>显然默认值无法满足我们的需求，而修改过设置后就可以满足了吗？答案仍旧是否定的。因为 TCP KeepAlive 是用于检测连接的死活，而心跳机制则附带一个额外的功能：检测通讯双方的存活状态。两者听起来似乎是一个意思，但实际上并非如此。例如，某台服务器无法响应任何业务请求，使用 TCP 探针则仍旧能够确定连接状态。对客户端而言，此时的最好选择就是断线后重新连接其他服务器，而不是持续向当前服务器发送请求。</p><h3 id="应用层架构"><a href="#应用层架构" class="headerlink" title="应用层架构"></a>应用层架构</h3><p>理清楚以上关键点，再去设计架构，就比较清晰容易了。因为几大国民应用（淘宝、支付宝、微信、QQ）都是采用类似的实现方式，也从侧面进一步印证了该设计的合理性</p><p><img src="/images/mobile-application-access/application-architecture.png" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实无论是 “单直播间百万CCU的弹幕服务” ，还是“单用户千万粉丝的红点服务”，在整体上都脱不开这个模型。只是要根据业务特性，在实现上做一定的修改变化以适应业务的需要</p><br/><p><strong>参考链接</strong> </p><ul><li><p><a href="https://www.infoq.cn/article/58WHhVew7kUYwHS*L6sE" target="_blank" rel="noopener">蚂蚁金服亿级并发下的移动端到端网络接入架构解析</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/66807833" target="_blank" rel="noopener">知乎千万级高性能长连接网关揭秘</a></p></li><li><p><a href="http://www.blogjava.net/yongboy/archive/2014/03/05/410636.html" target="_blank" rel="noopener">微信协议简单调研笔记</a></p></li><li><p><a href="https://www.infoq.cn/article/taobao-mobile-terminal-access-gateway-infrastructure" target="_blank" rel="noopener">阿里无线 11.11：手机淘宝移动端接入网关基础架构演进之路</a></p></li><li><p><a href="https://docs.huihoo.com/infoq/qconbeijing-evolution-and-enlightenment-of-qq-im-backend-architecture-20140426.pdf" target="_blank" rel="noopener">移动时代——QQ后台架构的演化与启示</a></p></li><li><p><a href="https://tech.meituan.com/2017/03/17/shark-sdk.html" target="_blank" rel="noopener">美团点评移动网络优化实践</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&mid=2247484552&idx=1&sn=40852d08a7fc5ce5bbef40e82b70f6b1" target="_blank" rel="noopener">魅族实时消息推送架构</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=209727496&idx=1&sn=86b64ddadcc91bc6b0741a870692b3c0" target="_blank" rel="noopener">360 如何实现支持数亿用户的长连消息系统</a></p></li><li><p><a href="https://yeqown.github.io/2020/04/02/%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E6%9E%B6%E6%9E%84-based-GOIM/" target="_blank" rel="noopener">消息推送架构-BASED-GOIM</a></p></li><li><p><a href="https://juejin.im/post/5cd12fa16fb9a0320b40ec32" target="_blank" rel="noopener">goim 中的 data flow 数据流转及思考</a></p></li><li><p><a href="http://yunxin.163.com/blog/im10-0608/" target="_blank" rel="noopener">移动IM开发指南2：心跳指令详解</a></p></li><li><p><a href="http://www.52im.net/thread-341-1-1.html" target="_blank" rel="noopener">Android端消息推送总结：实现原理、心跳保活、遇到的问题等</a></p></li><li><p><a href="https://juejin.im/post/5c6234426fb9a049e7029555" target="_blank" rel="noopener">Android 架构之长连接技术</a></p></li><li><p><a href="https://halfrost.com/advance_tcp/" target="_blank" rel="noopener">TCP 进阶</a></p></li></ul><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/05-03-2020/mobile-application-access-tech.html">https://www.cyningsun.com/05-03-2020/mobile-application-access-tech.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;随着移动互联网成长成熟，移动端逐渐涌现出与WEB不一样的产品形态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;互动&lt;/p&gt;
&lt;blockquote&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>监控告警成长之路</title>
    <link href="https://www.cyningsun.com/03-28-2020/site-reliability-engineering.html"/>
    <id>https://www.cyningsun.com/03-28-2020/site-reliability-engineering.html</id>
    <published>2020-03-27T16:00:00.000Z</published>
    <updated>2020-05-11T14:03:06.687Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在过去的两年里，我们从零开始搭建了整个事业群的监控。目前整套系统接入200+的服务，700+的实例，收集了上万个指标。不停探索，历经曲折，方得自由。本文主要内容是总结两年间走过的路，趟过的坑，学习到的经验。</p><h3 id="一无所有"><a href="#一无所有" class="headerlink" title="一无所有"></a>一无所有</h3><p>业务刚开始上线时，是没有任何监控的，所有的监控都是依赖接入层的Nginx的监控数据，所有的故障都是从用户获取到反馈才能发现；排查问题依靠日志系统；从上游服务开始，逐层查询日志。每次发布上线内心都在敲锣打鼓。</p><h3 id="疲于奔命"><a href="#疲于奔命" class="headerlink" title="疲于奔命"></a>疲于奔命</h3><p>在业务第一个大版本上线之后，我们开始着手给业务系统接入监控，此时的选择是兄弟团队搭建的 openfalcon，使用 grafana 作为看板。基于对立体化监控的理解，开始着手建立各种纬度的看板</p><ul><li>服务纬度：<blockquote><p>提供 Client、Server 端视图，从服务的状态、性能、质量、容量四个维度，分析需要添加到看板的指标</p></blockquote></li><li>业务纬度：<blockquote><p>关注业务的关键路径，建立业务监控树，用于出现问题时，快速定位到具体的服务</p></blockquote></li><li>产品纬度：<blockquote><p>分析产品关键指标，构建公共看板</p></blockquote></li></ul><p>在这个阶段，我们投入了大量的人力资源到监控中，却收效甚微，主要有以下几点原因：</p><ol><li>从下往上的构建看板，需要不停的耗费人力补齐遗漏的指标</li><li>关注服务质量的指标多于关注产品质量指标，对于产品指标缺少足够的认识</li><li>受限于 openfalcon+grafana的能力，建立和维护 监控和告警，人力成本极高</li><li>所有人都要摸索熟悉监控的基础概念、门槛高</li><li>告警与业务关联度不高，业务一有波动就会误告，真正出现问题又发现没有配置告警</li></ol><p>在这个阶段，我们投入了大量的人力，建立和维护各种看板，处理各种告警，疲于奔命，却不尽如人意。</p><h3 id="前路始现"><a href="#前路始现" class="headerlink" title="前路始现"></a>前路始现</h3><p>在第一个版本稳定之后，很长一段时间没有大需求，促使我们考虑如何解决这些问题。同时在这个阶段，在部门内部开始开发自己的RPC框架，基于在微信的工作经验，促使我们把目光投向 Prometheus 等基于数据的监控平台。</p><p>在监控方面，我们使用 <a href="https://www.cyningsun.com/09-15-2019/micro-service-monitor-prometheus-client.html">SDK（数据上报）</a> + <a href="https://www.cyningsun.com/09-13-2019/micro-service-monitor-prometheus-ha.html">Prometheus（数据收集）</a>+ Grafana（监控看板），构建了更灵活方便的看板</p><ul><li>服务纬度<blockquote><p>在开发RPC框架的同时，将服务纬度的上报直接嵌入框架中，同时提供SDK给兄弟团队用于现有服务的接入。然后统一维护了两套服务看板：全局看板，详细看板。前者负责日常运营，后者负责排查问题。</p></blockquote></li><li>业务&amp;产品纬度<blockquote><p>SDK设计了统一简单的上报接口，方便构建业务、产品相关的看板</p></blockquote></li></ul><p>至此，服务纬度的数据变成了可以逐渐迭代优化的统一视图，随着经验的积累，对监控的认识越深刻，看板使用越是应手。</p><p>在告警方面，使用 <a href="https://www.cyningsun.com/09-13-2019/micro-service-monitor-prometheus-ha.html">Promtheus（数据计算）</a> + Promgen（规则管理） + AlertManager（告警管理） + Webhook （告警调用）+ 企业微信群，构建了完善的告警链条。</p><h3 id="方得自由"><a href="#方得自由" class="headerlink" title="方得自由"></a>方得自由</h3><p>在监控告警中，我们会频繁遇到以下问题：</p><ol><li>阈值设定：不同业务场景，不同指标，如何衡量阈值是过于宽松，还是过于严格。</li><li>流量波动：在理想的世界里，流量是有起伏规律的，监控系统能够掌握这种规律，当流量上升时，告警阈值自动上升</li><li>瞬态告警：每个人都会遇到这样的情况，同样的问题隔段时间就出现一次，持续时间不过几分钟，来得快去得也快。说实话，你已经忙得不可开交了，近期内也不大会去排除这种问题。是忽略呢？还是忽略呢？</li><li>信息过载：典型的信息过载场景是，给所有需要的地方都加上了告警，以为这样即可高枕无忧了，结果随着而来的是，各种来源的告警轻松挤满你的收件箱。</li><li>故障定位：在相对复杂的业务场景下，一个“告警事件” 除了包含“时间”(何时发生)、“地点”(哪个服务器/组件)、“内容”(包括错误码、状态值等)外，还包含地区、机房、服务、接口等，故障定位之路道阻且长。</li></ol><p>那么目前我们解决的怎么样了呢？</p><ul><li>问题 1、2，为了解决该问题，在监控平台里，引入了<a href="https://www.cyningsun.com/01-22-2020/use-prometheus-for-anomaly-detection.html">异常检测算法（anomaly detection）</a> ，得到了很好的解决</li><li>问题 3，使用Prometheus的能力，得以解决</li><li>问题 4，我们对告警指标进行分级，只在调用链条的最上游配置细化的重要告警指标，告警之后通过链接跳转到对应的详细看板进行问题排查，告警更少更精确可查，维护起来也更简单了。</li><li>问题 5，目前仍然没有得到很好的解决，但是已经有了方案，将在后续进一步优化</li></ul><h3 id="未来之路"><a href="#未来之路" class="headerlink" title="未来之路"></a>未来之路</h3><p>基于 <a href="https://www.cyningsun.com/02-22-2020/hidden-secret-to-understanding-prometheus.html">Prometheus 的数据平台能力</a>，可以构建出业务所有服务的调用的树状图，并且当时的错误变化情况，进行自动故障根源分析，这也是我们以后将要做的</p><BR/>附：<p><img src="/images/site-reliability-engineering/overview.png" alt="overview"><br>（全局看板部分视图）</p><p><img src="/images/site-reliability-engineering/detail1.png" alt="detail1"><br><img src="/images/site-reliability-engineering/detail2.png" alt="detail2"><br>（详细看板部分视图）</p><p><strong>参考链接</strong><br><a href="https://www.jianshu.com/p/06c7dd803d4a" target="_blank" rel="noopener">https://www.jianshu.com/p/06c7dd803d4a</a></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/03-28-2020/site-reliability-engineering.html">https://www.cyningsun.com/03-28-2020/site-reliability-engineering.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;在过去的两年里，我们从零开始搭建了整个事业群的监控。目前整套系统接入200+的服务，700+的实例，收集了上万个指标。不停探索，历经曲折，方
      
    
    </summary>
    
    
      <category term="SRE" scheme="https://www.cyningsun.com/category/SRE/"/>
    
    
      <category term="Alert" scheme="https://www.cyningsun.com/tag/Alert/"/>
    
  </entry>
  
  <entry>
    <title>缓存(3) —— 一致性</title>
    <link href="https://www.cyningsun.com/03-07-2020/high-concurrency-cache-consistent.html"/>
    <id>https://www.cyningsun.com/03-07-2020/high-concurrency-cache-consistent.html</id>
    <published>2020-03-06T16:00:00.000Z</published>
    <updated>2020-04-25T01:36:45.890Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>毋庸置疑，数据只要有多个副本（replica/copy），就一定会存在一致性的问题。数据多副本一般有以下作用：</p><ol><li>容错手段：当某一个副本出现故障时，可以从其他副本读取数据，确保容错并避免单点问题。</li><li>改善性能：在多个位置具有相同的数据可以降低数据访问延迟<blockquote><ul><li>将数据副本存放在更靠近用户的位置，典型的例子：CDN</li><li>将数据放在高性能的存储介质中，典型的例子：缓存</li></ul></blockquote></li><li>分担负荷：由于数据存在多个副本，每个副本都可以承担一部分查询请求。</li></ol><p>通常，对副本的访问与对原始数据的访问应当是一致的，副本本身对外部用户应该是透明的，这就是通常理解的一致性。人人都在谈一致性，但是大家说的一致性却不一定是同一个东西。</p><h3 id="一致性视角"><a href="#一致性视角" class="headerlink" title="一致性视角"></a>一致性视角</h3><p>从使用的角度，数据从存储系统分离取出来之后，会经过业务系统的加工，最终展现给普通用户。</p><p><img src="/images/high-concurrency-cache-consistent/consistent-view.png" alt="consistent-view.png"></p><p>因此，存在两个视角可以来看数据一致性的问题，分别是：</p><ul><li>V1: 服务端视角</li><li>V2: 用户视角</li></ul><h4 id="用户端一致性"><a href="#用户端一致性" class="headerlink" title="用户端一致性"></a>用户端一致性</h4><p>首先定义如下场景：</p><ul><li>存储系统：存储系统存储了用户的数据。</li><li>用户A：往存储系统写入数据，并读取自己与其他人的数据。</li><li>用户B、用户C：读取自己与其他人的数据。</li></ul><p>从用户的角度来看，一致性包含如下三种情况：</p><ul><li><strong>强一致性</strong>：假如A先写入了一个值到存储系统，存储系统保证后续A，B，C的读取操作都将返回最新值。当然，如果写入操作“超时”，那么成功或者失败都是可能的，A不应该做任何假设。</li><li><strong>弱一致性</strong>：假如A先写入了一个值到存储系统，存储系统不能保证后续A，B，C的读取操作是否能够读取到最新值。</li><li><strong>最终一致性</strong>：最终一致性是弱一致性的一种特例。假如A首先写入一个值到存储系统，存储系统保证如果后续没有写操作更新同样的值，A，B，C的读取操作“最终”都会读取到A写入的最新值。“最终”一致性有一个“不一致窗口”的概念，它特指从A写入值，到后续A，B，C读取到最新值的这段时间。“不一致性窗口”的大小依赖于以下的几个因素：交互延迟，系统的负载，以及复制协议要求同步的副本数。</li></ul><p>最终一致性描述比较粗略，其他常见的变体如下：</p><ul><li><strong>读写（Read-your-writes）一致性</strong>：如果客户端A写入了最新的值，那么A的后续操作都会读取到最新值。但是其他用户（比如B或者C）可能要过一会才能看到。</li><li><strong>会话（Session）一致性</strong>：要求用户和存储系统交互的整个会话期间保证读写一致性。如果原有会话因为某种原因失效而创建了新的会话，原有会话和新会话之间的操作不保证读写一致性。</li><li><strong>单调读（Monotonic read）一致性</strong>：如果客户端A已经读取了对象的某个值，那么后续操作将不会读取到更早的值。</li><li><strong>单调写（Monotonic write）一致性</strong>：客户端A的写操作按顺序完成，这就意味着，对于同一个客户端的操作，存储系统的多个副本需要按照与客户端相同的顺序完成。</li></ul><p>从用户角度看，一般要求业务系统能够支持读写一致性，会话一致性，单调读，单调写等特性，以放松一致性来提供高可用性。</p><h4 id="服务端一致性"><a href="#服务端一致性" class="headerlink" title="服务端一致性"></a>服务端一致性</h4><p>在开始之前确定一些定义：<br>N = 存储数据副本的节点数<br>W = 更新完成之前需要确认收到更新的副本数<br>R = 通过读取操作访问数据对象时获取的副本数</p><p>如果 W + R &gt; N，则写集和读集始终重叠，并且可以保证强一致性。在实现同步复制的主备份 Mysql 方案中，N = 2，W = 2 和 R = 1。无论客户端从哪个副本中读取内容，都将始终获得一致的结果。在启用从备份读取的异步复制中，N = 2，W = 1 和 R = 1。在这种情况下，R + W = N，则不能保证一致性。</p><blockquote><p>在需要提供高性能和高可用性的分布式存储系统中，副本的数量通常大于两个。仅专注于容错的系统通常使用N = 3（W = 2和R = 2配置）。微信早期的 QuorumKV，就是使用的该配置</p></blockquote><p>当W + R &lt;= N，会出现弱/最终一致性，这意味着读写集可能不会重叠。是否可以实现读写、会话和单调一致性通常取决于client与执行分布式协议的服务器的“粘性”。如果每次都是同一台服务器，那么就比较容易保证读写和单调读。同时也使得负载平衡管理和容错稍微有点困难，但这是一个简单的解决方案。</p><p>从业务系统的角度看，存储系统可以支持强一致性，也可以为了性能考虑只支持最终一致性。无法提供一致性的系统，使用比较麻烦。</p><h3 id="复制机制"><a href="#复制机制" class="headerlink" title="复制机制"></a>复制机制</h3><p>从存储系统的可用性来看，组合“存储结构”和“复制机制”有以下三种模式：</p><ul><li>单主，异步/异步复制</li><li>自动选主，同步复制</li><li>多主可用，同步复制</li></ul><p><img src="/images/high-concurrency-cache-consistent/replication-struct.png" alt="replication-struct.png"></p><p>三种模式从实现难度来看，从低到高。“<a href="https://www.cyningsun.com/02-02-2020/high-concurrency-hierarchical-storage.html#%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84">内存数据库 + 磁盘数据库</a>” 类型的存储架构，如果将两者看作整体，很容易理解其“单主”的形态：</p><ol><li>读请求大部分命中内存数据库，少数落到磁盘数据库</li><li>写请求写到磁盘数据库，然后由磁盘数据库同步到内存数据库</li></ol><p>考虑通用架构，由于内存数据库存在数据丢失风险，数据一般会写入磁盘数据库，然后再写入或同步到内存数据库。因此在很多公司的设计中（例如Facebook和我司），均采用异步复制的方式来更新缓存。具体到Mysql，则是利用了磁盘数据库的提交日志（即Commit Log，以Mysql为例，binlog）自动异步更新缓存</p><p><img src="/images/high-concurrency-cache-consistent/facebook-data-replication.png" alt="facebook-data-replication.png"><br>Facebook</p><p><img src="/images/high-concurrency-cache-consistent/shopee-data-replication.png" alt="shopee-data-replication.png"><br>shopee</p><p>当然，异步复制只能解决最终一致性，无法解决用户角度强一致性的场景。对于这种场景可以通过 “<a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">Cache Aside Pattern</a>” 来解决。</p><p>参考链接：</p><ul><li><a href="https://coolshell.cn/articles/10910.html" target="_blank" rel="noopener">分布式系统的事务处理</a></li><li><a href="https://queue.acm.org/detail.cfm?id=1466448" target="_blank" rel="noopener">Eventually Consistent</a></li><li><a href="https://myslide.cn/slides/20807" target="_blank" rel="noopener">微信后台架构与基础设施简介</a></li><li><a href="https://en.wikipedia.org/wiki/Replication_%28computing%29" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Replication_(computing)</a></li><li><a href="https://www.usenix.org/conference/nsdi13/scaling-memcache-facebook" target="_blank" rel="noopener">Scaling Memcache at Facebook</a></li><li><a href="https://static001.geekbang.org/con/40/pdf/4109523403/file/%E6%9E%97%E9%94%8B-Shopee%E6%95%B0%E6%8D%AE%E4%BA%8B%E4%BB%B6%E4%B8%AD%E5%BF%83%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0.pdf" target="_blank" rel="noopener">Shopee数据事件中心的设计和实现</a></li><li><a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="noopener">缓存更新的套路</a></li></ul><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/03-07-2020/high-concurrency-cache-consistent.html">https://www.cyningsun.com/03-07-2020/high-concurrency-cache-consistent.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;毋庸置疑，数据只要有多个副本（replica/copy），就一定会存在一致性的问题。数据多副本一般有以下作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;容
      
    
    </summary>
    
    
      <category term="缓存" scheme="https://www.cyningsun.com/category/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="一致性" scheme="https://www.cyningsun.com/tag/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>缓存(2) —— 命中率</title>
    <link href="https://www.cyningsun.com/02-27-2020/high-concurrency-cache-miss.html"/>
    <id>https://www.cyningsun.com/02-27-2020/high-concurrency-cache-miss.html</id>
    <published>2020-02-26T16:00:00.000Z</published>
    <updated>2020-04-25T01:36:45.889Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><a href="https://www.cyningsun.com/02-02-2020/high-concurrency-hierarchical-storage.html">上一篇</a>文章讲述了缓存的本质，使用快速的存储，承载尽可能多的请求，那么衡量缓存服务质量有两个标准：</p><ol><li>平均访问延迟AAT（Average Access Time） = HitTime + (Miss Ratio * Miss Penalty)</li><li>缓存命中率 Cache Hit Ratio = [Cache Hits / (Cache Hits + Cache Misses)] x 100 %<br>前者因为不涉及技术问题，不再详谈。后者，却是至关重要。</li></ol><p>缓存命中（Cache Hit），符合我们预期，喜闻乐见；缓存未命中（Cache Miss），就很有可能要了老命。各种称谓也很繁杂</p><blockquote><p>国内按照场景分称为：缓存击穿、缓存穿透、缓存雪崩<br>国外使用不同词汇表达同一含义：<a href="https://en.wikipedia.org/wiki/Thundering_Herd" target="_blank" rel="noopener">Thundering Herd</a>、<a href="https://en.wikipedia.org/wiki/Cache_stampede" target="_blank" rel="noopener">Cache stampede</a>、<a href="https://books.google.com/books?id=daDAnXPnRkcC&pg=PA353" target="_blank" rel="noopener">Dog-Pile Effect</a></p></blockquote><p>以下的篇幅分场景来讲下缓存不命中的场景和常见的解决方案</p><h3 id="数据不在缓存"><a href="#数据不在缓存" class="headerlink" title="数据不在缓存"></a>数据不在缓存</h3><h4 id="Cold-cache"><a href="#Cold-cache" class="headerlink" title="Cold cache"></a>Cold cache</h4><p>缓存最好是使用渐进式策略进行warmup，要做到业务无感就需要引入中间组件，例如Facebook使用 mcrouter 来预热新机群</p><p><img src="/images/high-concurrency-cache-miss/mcrouter.png" alt="mcrouter.png"></p><h4 id="Adding-removing-nodes"><a href="#Adding-removing-nodes" class="headerlink" title="Adding / removing nodes"></a>Adding / removing nodes</h4><p>模哈希路由的主要缺点是缓存节点的数量需要保持稳定，增加节点或者节点下线将导致大多数缓存散列到新节点。即使这些值仍在缓存中，如果将Key分发给其他节点，查找也会 <code>Miss</code>。使用<a href="https://juejin.im/post/5ae1476ef265da0b8d419ef2" target="_blank" rel="noopener">一致性哈希</a>可以使缓存节点增减更加灵活。</p><p><img src="/images/high-concurrency-cache-miss/consistent-hash.png" alt="consistent-hash.png"></p><h4 id="Out-of-cache-memory"><a href="#Out-of-cache-memory" class="headerlink" title="Out of cache memory"></a>Out of cache memory</h4><p>对于不在内存中的数据，有两种可能：</p><ol><li>缓存时间到期（TTL），数据从缓存中淘汰出去了</li><li>由于之前没有访问，数据不在缓存中</li></ol><p>对于不在缓存的访问，处理的方式比较统一，严格限制并发访问下游存储，具体落实到各个公司各不相同：</p><ul><li>Instagram： 在C++语言中使用 <a href="https://instagram-engineering.com/thundering-herds-promises-82191c8af57d" target="_blank" rel="noopener">Promise</a> 模式来限制并发访问</li><li>Google：在Go语言中使用 <a href="https://pkg.go.dev/golang.org/x/sync/singleflight?tab=doc" target="_blank" rel="noopener">Single Flight</a> 来限制并发访问</li><li>Facebook：使用 <a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf" target="_blank" rel="noopener">Leases</a> 机制，保证同一时间只有第一个访问到不在缓存的请求可以访问下游，并将其添加到缓存；其他请求则返回未命中，然后等待一段时间再次尝试访问缓存。</li></ul><h3 id="数据不存在"><a href="#数据不存在" class="headerlink" title="数据不存在"></a>数据不存在</h3><p>对于数据不存在的情况，尽量通过参数校验的情况予以拦截。拿公众号文章的链接举例:</p><p><strong>早期</strong></p><pre><code class="hljs go">http:<span class="hljs-comment">//mp.weixin.qq.com/s?__biz=MzAwNTMxMzg1MA==&amp;mid=2654067776&amp;idx=1&amp;sn=b4c1261a785a59dd6268142b0b358b50&amp;scene=4#wechat_redirect</span></code></pre><p>可以看到该链接中几个关键的请求参数：</p><blockquote><p>__biz=MzAwNTMxMzg1MA== // 公众号ID base64<br>mid=2654067776        // 推送ID<br>idx=1                // 消息位置（每次推送有多篇文章）</p></blockquote><p>有这些参数，完全可以随意拼接参数，伪造URL爬取微信公众号的数据。如果URL并没有对应的数据，那么微信就会遇到数据不存在穿透到下层存储的问题。</p><p><strong>中期</strong></p><pre><code class="hljs go">http:<span class="hljs-comment">//mp.weixin.qq.com/s?timestamp=1469352451&amp;src=3&amp;ver=1&amp;signature=56kgMk71dIMM59VsUWlueRZ1ljkNODBEgrW78vmgXfJs82nkMESO8W*7EXf2ylOyamiUvL0zQ5OAfVraI8tPp-Hhdzv5WRQKSPa-MF6hiFMZf7rqxmZRvsYsd-7WSsy5qiafAQNfxBSkWzSulgB575CWRYnn6QZTRJ4NdR*gs0s=</span></code></pre><p>唔，带上时间戳了，不太好搞了，但是如果知道签名策略，仍然可以解出来必需的访问参数</p><p><strong>最新</strong></p><pre><code class="hljs go">https:<span class="hljs-comment">//mp.weixin.qq.com/s/zCyzv_DRzLSUjhs5E9gZtQ</span></code></pre><p>最新版就丧心病狂了，直接转成了短链接，外部人员丝毫没有办法，完美解决了问题。</p><p>对于无法通过数据拦截的，则需要根据依赖额外的过滤器来进行甄别，例如：<a href="https://en.wikipedia.org/wiki/Bloom_filter" target="_blank" rel="noopener">Bloom filter</a>、<a href="https://coolshell.cn/articles/17225.html" target="_blank" rel="noopener">Cuckoo filter</a> 等。以容忍误报置换空间，节约存储资源</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>除了以上常规且通用的处理方案，业界还有各种贴合业务场景的方案，在此不过多涉及。</p><blockquote><p>非常规方案：</p><ul><li><a href="http://highscalability.com/bunch-great-strategies-using-memcached-and-mysql-better-together" target="_blank" rel="noopener">Pre-Populating Cache</a></li><li><a href="https://kovyrin.net/2008/03/10/dog-pile-effect-and-how-to-avoid-it-with-ruby-on-rails-memcache-client-patch/" target="_blank" rel="noopener">monkey patch</a></li><li>Randomize TTL values</li></ul></blockquote><br/><p>参考链接 </p><ol><li><a href="https://engineering.fb.com/web/introducing-mcrouter-a-memcached-protocol-router-for-scaling-memcached-deployments/" target="_blank" rel="noopener">https://engineering.fb.com/web/introducing-mcrouter-a-memcached-protocol-router-for-scaling-memcached-deployments/</a></li><li><a href="https://github.com/leafney/wxSpider/blob/master/GETCONTENT.md" target="_blank" rel="noopener">https://github.com/leafney/wxSpider/blob/master/GETCONTENT.md</a></li><li><a href="https://instagram-engineering.com/thundering-herds-promises-82191c8af57d" target="_blank" rel="noopener">https://instagram-engineering.com/thundering-herds-promises-82191c8af57d</a></li></ol><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/02-27-2020/high-concurrency-cache-miss.html">https://www.cyningsun.com/02-27-2020/high-concurrency-cache-miss.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.cyningsun.com/02-02-2020/high-concurrency-hierarc
      
    
    </summary>
    
    
      <category term="缓存" scheme="https://www.cyningsun.com/category/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="命中率" scheme="https://www.cyningsun.com/tag/%E5%91%BD%E4%B8%AD%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出 Prometheus</title>
    <link href="https://www.cyningsun.com/02-22-2020/hidden-secret-to-understanding-prometheus.html"/>
    <id>https://www.cyningsun.com/02-22-2020/hidden-secret-to-understanding-prometheus.html</id>
    <published>2020-02-21T16:00:00.000Z</published>
    <updated>2020-04-25T01:36:45.888Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>对很多人来说，未知、不确定、不在掌控的东西，会有潜意识的逃避。当我第一次接触 Prometheus 的时候也有类似的感觉。对初学者来说， Prometheus 包含的概念太多了，门槛也太高了。</p><blockquote><p>概念： Instance、Job、Metric、Metric Name、Metric Label、Metric Value、Metric Type（Counter、Gauge、Histogram、Summary）、DataType（Instant Vector、Range Vector、Scalar、String）、Operator、Function</p></blockquote><p>马云说：“虽然阿里巴巴是全球最大的零售平台，但阿里不是零售公司，是一家数据公司”。Prometheus 也是一样，本质来说是一个基于数据的监控系统。</p><h3 id="日常监控"><a href="#日常监控" class="headerlink" title="日常监控"></a>日常监控</h3><p>假设需要监控 WebServerA 每个API的请求量为例，需要监控的维度包括：服务名（job）、实例IP（instance）、API名（handler）、方法（method）、返回码(code)、请求量（value）。</p><p><img src="/images/hidden-secret-to-understanding-prometheus/sql.png" alt="promql"></p><p>如果以SQL为例，演示常见的查询操作：</p><ol><li>查询 method=put 且 code=200 的请求量(红框)<blockquote><p>SELECT * from http_requests_total WHERE code=”200” AND method=”put” AND created_at BETWEEN 1495435700 AND 1495435710;</p></blockquote></li><li>查询 handler=prometheus 且 method=post 的请求量(绿框)<blockquote><p>SELECT * from http_requests_total WHERE handler=”prometheus” AND method=”post” AND created_at BETWEEN 1495435700 AND 1495435710;</p></blockquote></li><li>查询 instance=10.59.8.110 且 handler 以 query 开头 的请求量(绿框)<blockquote><p>SELECT * from http_requests_total WHERE handler=”query” AND instance=”10.59.8.110” AND created_at BETWEEN 1495435700 AND 1495435710;</p></blockquote></li></ol><p>通过以上示例可以看出，在常用查询和统计方面，日常监控多用于根据监控的维度进行查询与时间进行组合查询。<strong>如果监控100个服务，平均每个服务部署10个实例，每个服务有20个API，4个方法，30秒收集一次数据，保留60天。那么总数据条数为：100(服务)* 10（实例）* 20（API）* 4（方法）* 86400（1天秒数）* 60(天) / 30（秒）= 138.24 亿条数据，写入、存储、查询如此量级的数据是不可能在Mysql类的关系数据库上完成的</strong>。因此 Prometheus 使用 TSDB 作为 存储引擎</p><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>TSDB 作为 Prometheus 的存储引擎完美契合了监控数据的应用场景</p><ul><li>存储的数据量级十分庞大</li><li>大部分时间都是写入操作</li><li>写入操作几乎是顺序添加，大多数时候数据到达后都以时间排序</li><li>写操作很少写入很久之前的数据，也很少更新数据。大多数情况在数据被采集到数秒或者数分钟后就会被写入数据库</li><li>删除操作一般为区块删除，选定开始的历史时间并指定后续的区块。很少单独删除某个时间或者分开的随机时间的数据</li><li>基本数据大，一般超过内存大小。一般选取的只是其一小部分且没有规律，缓存几乎不起任何作用</li><li>读操作是十分典型的升序或者降序的顺序读</li><li>高并发的读操作十分常见</li></ul><p>那么 TSDB 是怎么实现以上功能的呢？</p><pre><code class="hljs json">"labels": [&#123;"latency":        "500"&#125;]"samples":[&#123;"timestamp": 1473305798,"value": 0.9&#125;]</code></pre><p>原始数据分为两部分 label, samples。前者记录监控的维度（标签:标签值），指标名称和标签的可选键值对唯一确定一条时间序列（使用 series_id 代表）；后者包含包含了时间戳（timestamp）和指标值（value）。</p><pre><code class="hljs txt">series^│. . . . . . . . . . . .   server&#123;latency&#x3D;&quot;500&quot;&#125;│. . . . . . . . . . . .   server&#123;latency&#x3D;&quot;300&quot;&#125;│. . . . . . . . . .   .   server&#123;&#125;│. . . . . . . . . . . . v&lt;-------- time ----------&gt;</code></pre><p>TSDB 使用 timeseries:doc:<timestamp>:<series_id> 为 key 存储 value。为了加速常见查询查询操作：label 和 时间范围结合。TSDB 额外构建了三种索引：<code>Series</code>, <code>Label Index</code> 和 <code>Time Index</code>。</p><p>以标签 <code>latency</code> 为例：</p><ul><li>Series<blockquote><p>存储两部分数据。一部分是按照字典序的排列的所有标签键值对序列（series）；另外一部分是时间线到数据文件的索引，按照时间窗口切割存储数据块记录的具体位置信息，因此在查询时可以快速跳过大量非查询窗口的记录数据</p></blockquote></li><li>Label Index<blockquote><p>每对 label 为会以 index:label:<latency> 为 key，存储该标签所有值的列表，并通过引用指向 <code>Series</code> 该值的起始位置。</p></blockquote></li><li>Time Index<blockquote><p>数据会以 index:timeseries:<series_id>:<split_time> 为 key，指向对应时间段的数据文件</p></blockquote></li></ul><h3 id="数据计算"><a href="#数据计算" class="headerlink" title="数据计算"></a>数据计算</h3><p>强大的存储引擎为数据计算提供了完美的助力，使得 Prometheus 与其他监控服务完全不同。Prometheus 可以<a href="https://prometheus.io/docs/prometheus/latest/querying/basics/#time-series-selectors" target="_blank" rel="noopener">查询出不同的数据序列</a>，然后再加上<a href="https://prometheus.io/docs/prometheus/latest/querying/operators/" target="_blank" rel="noopener">基础的运算符</a>，以及<a href="https://prometheus.io/docs/prometheus/latest/querying/functions/" target="_blank" rel="noopener">强大的函数</a>，就可以执行 <code>metric series</code> 的矩阵运算（见下图）。</p><p><img src="/images/hidden-secret-to-understanding-prometheus/matrix.png" alt="time series matrix"></p><p>如此，Promtheus体系的能力不弱于监控界的“数据仓库”+“计算平台”。因此，在大数据的开始在业界得到应用，就能明白，这就是监控未来的方向。</p><h3 id="一次计算，处处查询"><a href="#一次计算，处处查询" class="headerlink" title="一次计算，处处查询"></a>一次计算，处处查询</h3><p>当然，如此强大的计算能力，消耗的资源也是挺恐怖的。因此，查询预计算结果通常比每次需要原始表达式都要快得多，尤其是在仪表盘和告警规则的适用场景中，仪表盘每次刷新都需要重复查询相同的表达式，告警规则每次运算也是如此。因此，Prometheus提供了 Recoding rules，可以预先计算经常需要或者计算量大的表达式，并将其结果保存为一组新的时间序列， 达到 <a href="https://prometheus.io/docs/prometheus/latest/querying/basics/#avoiding-slow-queries-and-overloads" target="_blank" rel="noopener">一次计算，多次查询</a> 的目的</p><p><img src="/images/hidden-secret-to-understanding-prometheus/rules.png" alt="prometheus rules"></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/02-22-2020/hidden-secret-to-understanding-prometheus.html">https://www.cyningsun.com/02-22-2020/hidden-secret-to-understanding-prometheus.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;对很多人来说，未知、不确定、不在掌控的东西，会有潜意识的逃避。当我第一次接触 Prometheus 的时候也有类似的感觉。对初学者来说， P
      
    
    </summary>
    
    
      <category term="SRE" scheme="https://www.cyningsun.com/category/SRE/"/>
    
    
      <category term="本质" scheme="https://www.cyningsun.com/tag/%E6%9C%AC%E8%B4%A8/"/>
    
  </entry>
  
  <entry>
    <title>缓存（1）—— 总述：分级存储</title>
    <link href="https://www.cyningsun.com/02-02-2020/high-concurrency-hierarchical-storage.html"/>
    <id>https://www.cyningsun.com/02-02-2020/high-concurrency-hierarchical-storage.html</id>
    <published>2020-02-01T16:00:00.000Z</published>
    <updated>2020-04-25T01:36:45.887Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>原本想聊下缓存的相关技术，但是纯聊缓存未免眼界太窄，视野太小，既然打算写一个系列，不如就先从底层聊起，然后慢慢铺开。本篇先聊分级存储引入的问题，以及对服务和架构的影响：服务分类、分层架构（服务分层）。</p><h3 id="分级存储"><a href="#分级存储" class="headerlink" title="分级存储"></a>分级存储</h3><p>了解计算机组成的都知道，存储结构是分层（级）的，到底是什么原因呢？</p><p><img src="/images/high-concurrency-hierarchical-storage/computer-architecture.png" alt="computer-architecture.png"></p><p>用户期望提供尽可能高的存取速度和尽量大的存储容量，但价格尽可能低。矛盾的现实是：</p><ol><li>速度越快，单位存储价格就越高；</li><li>在一定的单位存储价格下，容量越大，存储器的总价就越高。</li></ol><p>计算机发挥性能要求存储存取速度与CPU相匹配。离 CPU 越近的存储，速度越快，成本越高，容量也因此越小。</p><p>数据从产生的那一刻起就自然地进入到了一个循环，经过创建、访问、迁移、归档和销毁，最终完成一个生命周期，而这个过程必然需要良好的管理，否则，要么是浪费了过多的资源；要么是资源不足降低了工作效率。</p><p>数据生来并非平等的。不同的数据具有不同的价值，如业务生产相关的关键数据和日志；同一数据在其不同阶段价值也不一样。纵向来看，即访问越多，其价值越高。</p><p><strong>分级存储</strong>，利用了数据访问的<a href="https://en.wikipedia.org/wiki/Locality_of_reference" target="_blank" rel="noopener">局部性原理</a>，使用快速的存储，存储访问最多的数据。当访问数据时，先从内存中取，如果内存中没有，再从磁盘读入内存。以后访问该区域的数据时，就不用再从磁盘读取，因此上层的存储都可以认为是下层的缓存。</p><p>总结一下：局部性原理的缓存体系，平衡了速度和价格的矛盾。</p><h3 id="分级问题"><a href="#分级问题" class="headerlink" title="分级问题"></a>分级问题</h3><p>分级存储并非是解决问题的银弹，解决了矛盾的同时，也给存储本身引入了一些问题：</p><ol><li>命中率<blockquote><p>当数据被上层存储覆盖时，一切尽在掌握，分层存储的机制可以正常的工作。当热点数据穿透上层落到下层时，下层存储的性能将成为整体的瓶颈。</p></blockquote></li><li>一致性<blockquote><p>作为缓存，上层存储在提高系统处理性能的同时，也可能会“滞留”IO操作。如果在系统发生故障时，仍有部分IO“滞留”，真正写到下层存储的数据就会少于服务实际写出的数据，导致数据不一致。</p></blockquote></li><li>存储管理<blockquote><p>由于存在多个层级，数据在生命周期内就需要在不同层级间流动迁移。不同层级需要合适的迁移淘汰策略，满足业务场景的需求。缓存需要缓存策略；内存需要内存管理策略；磁盘需要磁盘管理策略。</p></blockquote></li></ol><h3 id="服务分类"><a href="#服务分类" class="headerlink" title="服务分类"></a>服务分类</h3><p>如同放洗澡水一样，首先检查热水多热，然后检查冷水多冷。然后调节水龙头旋钮，以流出温度合适的水。</p><p>类似的，基于不同类型存储访问速度的巨大差异，需要关注的重点不同。多级存储也给架构设计带来不少问题。</p><p>在大型互联网公司，所有的服务被分为三种类型：</p><ul><li><strong>CPU消耗型</strong>：也称为“计算密集型”，指服务使用CPU完成计算任务，受CPU速度限制。<em>CPU越快，任务处理越快。</em></li><li><strong>内存消耗型</strong>：也称为“内存密集型”，指服务执行任务过程中受内存大小和访问速度限制。<em>内存越大、访问速度越快，任务处理速度越快。</em> 通常为搜索类、缓存类、内存数据库等需求大量内存的服务</li><li><strong>I/O消耗型</strong>：也称为“I/O密集型”，指服务执行任务涉及到大量的网络传输或磁盘I/O，受I/O速度限制。<em>I/O越快，任务处理越快。</em> 一旦发生I/O，服务的工作线程(进程)就会处于等待状态，当I/O结束，数据准备好后，线程(进程)才会继续执行。</li></ul><p>一个服务可以既是“CPU消耗型“，同时也是“内存消耗型”，例如：搜索服务 —— 烧钱玩意儿，腾讯卖掉搜索给搜狗估计也是被烧的肉疼了吧 ：）。</p><p>那为什么如此划分呢？</p><ul><li>一方面，当服务陷入瓶颈的时候能够快速根据类型进行资源预估、调整和性能调优</li><li>另一方面，调度程序可以使用该信息来调度不同类型的服务，使用装包算法（<a href="https://en.wikipedia.org/wiki/Bin_packing_problem" target="_blank" rel="noopener">bin-packingalgorithms</a>）进行最优的混合部署，以达到资源最大利用。<br><img src="/images/high-concurrency-hierarchical-storage/bin-packing.png" alt="bin-packing.png"></li></ul><h3 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h3><p>盘点下业界在高并发场景下，使用的存储方案(至少保证数据不丢失)：</p><ol><li>纯内存数据库：以 mongodb 为代表。成本高昂</li><li>内存数据库 + 磁盘数据库：以 Redis/memcached + Mysql/TiDB 为代表。使用起来比较复杂，需要业务自己处理分级存储带来的问题</li><li>高性能高可用分布式数据库：以 megastore（谷歌）/ paxosstore(微信) / Dynamo (亚马逊)，技术门槛比较高，大厂专属</li></ol><p>可以看到绝大部分的互联网公司，还是依靠第二种方案扛住高并发的请求。那么应对高并发的架构中，就不能缺少存储层（也可以称为：持久层，数据访问层），否则业务代码会与存储管理的代码交叉耦合在一起</p><p><img src="/images/high-concurrency-hierarchical-storage/layer-architecture.png" alt="layer-architecture.png"></p><p>使用第二种方案，就免不了缓存的是是非非。既然缓存也是存储层级中的一层，所有的问题也就脱不开分级问题的范畴了，后续详聊。</p><br/><p>参考链接：</p><ul><li><a href="https://stackoverflow.com/questions/868568/what-do-the-terms-cpu-bound-and-i-o-bound-mean" target="_blank" rel="noopener">What do the terms “CPU bound” and “I/O bound” mean?</a></li><li><a href="https://www.slideshare.net/kubecon/kubecon-eu-2016-a-practical-guide-to-container-scheduling" target="_blank" rel="noopener">A Practical Guide to Container Scheduling</a></li><li><a href="https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/ch01.html" target="_blank" rel="noopener">Software Architecture Patterns</a></li></ul><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/02-02-2020/high-concurrency-hierarchical-storage.html">https://www.cyningsun.com/02-02-2020/high-concurrency-hierarchical-storage.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;原本想聊下缓存的相关技术，但是纯聊缓存未免眼界太窄，视野太小，既然打算写一个系列，不如就先从底层聊起，然后慢慢铺开。本篇先聊分级存储引入的问
      
    
    </summary>
    
    
      <category term="缓存" scheme="https://www.cyningsun.com/category/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="总述" scheme="https://www.cyningsun.com/tag/%E6%80%BB%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>译｜How to use Prometheus for anomaly detection in GitLab</title>
    <link href="https://www.cyningsun.com/01-22-2020/use-prometheus-for-anomaly-detection.html"/>
    <id>https://www.cyningsun.com/01-22-2020/use-prometheus-for-anomaly-detection.html</id>
    <published>2020-01-21T16:00:00.000Z</published>
    <updated>2020-04-25T01:36:45.886Z</updated>
    
    <content type="html"><![CDATA[<p>Prometheus 查询语言的最基本功能之一是实时汇总时间序列数据。GitLab基础架构团队的杰出工程师 <code>Andrew Newdigate</code> 认为 Prometheus 查询语言也可以用于检测时间序列数据中的异常。本博客文章解释了异常检测如何与 Prometheus 一起工作，并包括您需要在自己的系统上亲自尝试的代码片段。</p><h3 id="为什么异常检测有效？"><a href="#为什么异常检测有效？" class="headerlink" title="为什么异常检测有效？"></a>为什么异常检测有效？</h3><p>异常检测对 GitLab 非常重要的四个关键原因：</p><ul><li>诊断事件：我们可以快速找出哪些服务执行超出正常范围，并减少检测事件的平均时间（MTTD），从而更快地解决问题。</li><li>检测应用程序性能回归：例如，如果引入 n+1 回归，发现一个服务以很高的速率调用另一个服务，可以迅速找到问题并加以解决。</li><li>识别并解决滥用问题：GitLab 提供免费计算（GitLab CI/CD）和托管（GitLab Pages），会被一小部分用户加以利用。</li><li>安全性：异常检测对于发现 GitLab 时间序列数据中的异常趋势至关重要。</li></ul><p>由于以上以及其他许多原因，Andrew 研究了是否可以仅通过使用 Prometheus 查询和规则对 GitLab 时间序列数据执行异常检测。</p><h3 id="正确的聚合级别是什么？"><a href="#正确的聚合级别是什么？" class="headerlink" title="正确的聚合级别是什么？"></a>正确的聚合级别是什么？</h3><p>首先，时间序列数据必须正确聚合。尽管可以将相同的技术应用到许多其他类型的指标，Andrew 使用了标准计数器 <code>http_requests_total</code> 作为数据源进行演示。</p><pre><code class="hljs js">http_requests_total&#123; job=<span class="hljs-string">"apiserver"</span>, method=<span class="hljs-string">"GET"</span>, controller=<span class="hljs-string">"ProjectsController"</span>, status_code=<span class="hljs-string">"200"</span>, environment=<span class="hljs-string">"prod"</span>&#125;</code></pre><p>上述示例指标有一些额外的维度：<code>method</code>，<code>controller</code>，<code>status_code</code>，<code>environment</code>，如同 Prometheus 添加的维度 <code>instance</code> 和 <code>job</code> 一样。</p><p>接下来，您必须为正在使用的数据选择正确的聚合级别。这有点像“金发姑娘问题”-太多，太少还是恰到好处-但这对于发现异常至关重要。过多地汇总数据，数据将缩减为过小的维度，从而产生两个潜在的问题：</p><ol><li>可能会错过真正的异常，因为聚合隐藏了数据子集中出现的问题。</li><li>如果确实检测到异常，则不对异常进行更多调查，则很难将其归因于系统的特定部分。</li></ol><p>但是，聚合的数据汇太少，最终可能会得到一系列样本量非常小的数据。如此可能导致误报，并可能将真实数据标记为离群值（outliers）。</p><p>恰到好处：我们的经验表明，正确的聚合级别是服务级别，因此我们将 <code>job</code> 和 <code>environment</code> 标签标签包括进来，但删除了其他维度。在本演讲的以下部分中使用的数据聚合包括：<code>job</code>、<code>http requests</code>、<code>五分钟速率</code>(基本上是五分钟窗口中覆盖 <code>job</code> 和 <code>environment</code> 之上的速率)。</p><pre><code class="hljs ruby">- <span class="hljs-symbol">record:</span> <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m<span class="hljs-symbol">expr:</span> sum without(instance, method, controller, status_code)(rate(http_requests_total[<span class="hljs-number">5</span>m]))<span class="hljs-comment"># --&gt; job:http_requests:rate5m&#123;job="apiserver", environment="prod"&#125;  21321</span><span class="hljs-comment"># --&gt; job:http_requests:rate5m&#123;job="gitserver", environment="prod"&#125;  2212</span><span class="hljs-comment"># --&gt; job:http_requests:rate5m&#123;job="webserver", environment="prod"&#125;  53091</span></code></pre><h3 id="使用-z-score-进行异常检测"><a href="#使用-z-score-进行异常检测" class="headerlink" title="使用 z-score 进行异常检测"></a>使用 z-score 进行异常检测</h3><p>一些统计学的主要原理可以应用于 Prometheus 检测异常。</p><p>如果知道 Prometheus 序列的平均值和标准偏差（σ），则可以使用该系列中的任何样本来计算 <code>z-score</code>。<code>z-score</code> 表示为：与平均值的标准偏差值。因此 z-score 为 0 表示 z-score 与具有正态分布的数据的平均值相同，而 z-score 为 1 则相对于平均值为 1.0σ，依此类推。</p><p>假设基础数据是正态分布的，则 99.7％ 的样本的 z-score 应介于 0 到 3 之间。z-score 距离 0 越远，它越不可能出现。我们将此特性应用于检测 Prometheus 序列中的异常。</p><ol><li>使用样本数量较大的数据计算指标的平均值和标准偏差。在此示例中，我们使用了一周的数据。如果假设我们每分钟评估一次记录规则，那么一周的时间，能获得 10,000 多个样本。<pre><code class="hljs ruby"><span class="hljs-comment"># Long-term average value for the series</span>- <span class="hljs-symbol">record:</span> <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w<span class="hljs-symbol">expr:</span> avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w])<span class="hljs-comment"># Long-term standard deviation for the series</span>- <span class="hljs-symbol">record:</span> <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>stddev_over_time_1w<span class="hljs-symbol">expr:</span> stddev_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w])</code></pre></li><li>一旦有了聚合的平均值和标准差，就可以计算 Prometheus 查询的 z-score。<pre><code class="hljs sql"><span class="hljs-comment"># Z-Score for aggregation</span>(job:http_requests:rate5m -job:http_requests:rate5m:avg_over_time_1w) /  job:http_requests:rate5m:stddev_over_time_1w</code></pre></li></ol><p>根据正态分布的统计原理，我们可以假设任何超出大约 +3 到 -3 范围的值都是异常。我们可以围绕这一原则建立警报。例如，当聚合超出此范围超过五分钟时，我们将收到警报。</p><p><img src="/images/use-prometheus-for-anomaly-detection/gitlab-page-rps.png" alt="gitlab-page-rps.png"><br>GitLab.com 页面服务 48 小时的 RPS， ±3 z-score 区域为绿色</p><p>z-score 在图形上难以解释，因为它们没有度量单位。但是此图表上的异常很容易检测。出现在绿色区域（表示 z-score 在 +3 或 -3 范围内）之外的任何值都是异常。</p><h3 id="如果不是正态分布怎么办？"><a href="#如果不是正态分布怎么办？" class="headerlink" title="如果不是正态分布怎么办？"></a>如果不是正态分布怎么办？</h3><p>但是，请稍等：我们大跃进的假设潜在的聚合具有正态分布。如果我们使用非正态分布的数据计算 z-score，结果将不正确。有许多统计技术可以测试您的数据是否为正态分布，但是最好的选择是测试您的潜在数据的 z-score 约为 +4 到 -4。</p><pre><code class="hljs ruby">( max_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w]) - avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w])) / stddev_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w])<span class="hljs-comment"># --&gt; &#123;job="apiserver", environment="prod"&#125;  4.01</span><span class="hljs-comment"># --&gt; &#123;job="gitserver", environment="prod"&#125;  3.96</span><span class="hljs-comment"># --&gt; &#123;job="webserver", environment="prod"&#125;  2.96</span>( min_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w]) - avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w])) / stddev_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">1</span>w])<span class="hljs-comment"># --&gt; &#123;job="apiserver", environment="prod"&#125;  -3.8</span><span class="hljs-comment"># --&gt; &#123;job="gitserver", environment="prod"&#125;  -4.1</span><span class="hljs-comment"># --&gt; &#123;job="webserver", environment="prod"&#125;  -3.2</span></code></pre><p>两个 Prometheus 查询测试 z-score 的最小和最大值。</p><p>如果结果返回的范围是 +20 到 -20，则尾巴太长，结果将倾斜。还要记住，这需要在聚合而不是非聚合的序列上运行。可能没有正态分布的指标包括诸如错误率、等待时间、队列长度等，但是无论如何，在固定阈值下告警，许多这些指标都趋向于工作的很好。</p><h3 id="使用季节性检测异常"><a href="#使用季节性检测异常" class="headerlink" title="使用季节性检测异常"></a>使用季节性检测异常</h3><p>尽管时间序列数据为正态分布时，计算 z-score 效果很好，但是还有第二种方法可以产生更准确的异常检测结果。季节性是时间序列指标的一个特征，其中该指标会经历定期且可预测的变化，这些变化会在每个周期重复出现。</p><p><img src="/images/use-prometheus-for-anomaly-detection/gitaly-rps-weeks.png" alt="gitaly-rps-weeks.png"><br>周一至周日连续四个星期的每秒 Gitaly 请求（RPS）</p><p>该图说明了连续四周的周一到周日的7天中 Gitaly 的 RPS（每秒请求数）速率。七天范围称为“偏移”，表示需要度量的模式。图上的每个星期都有不同的颜色。数据的季节性由图表中所示趋势的一致性表示 —— 每个星期一早晨，RPS 速率都会上升，而在星期五晚上，RPS 速率会逐渐下降，每周如此。</p><p>通过利用时间序列数据中的季节性，可以创建更准确的预测，从而更好地进行异常检测。</p><h3 id="如何利用季节性？"><a href="#如何利用季节性？" class="headerlink" title="如何利用季节性？"></a>如何利用季节性？</h3><p>使用 Prometheus 计算季节性，需要在一些不同的统计原理上迭代。</p><p>在第一次迭代中，我们通过将目前滚动的一周的增长趋势（注：平均值）与前一周的值相加来计算。通过从目前滚动的一周平均值中减去上周的滚动一周平均值来计算增长趋势。</p><pre><code class="hljs ruby">- <span class="hljs-symbol">record:</span> <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m_prediction  <span class="hljs-symbol">expr:</span> &gt;    <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m offset <span class="hljs-number">1</span>w                     <span class="hljs-comment"># Value from last period</span>    + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w            <span class="hljs-comment"># One-week growth trend</span>    - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">1</span>w</code></pre><p>第一次迭代有点狭窄；我们使用本周和上周的五分钟窗口来得出我们的预测。</p><p>在第二次迭代中，将上周的四个小时平均值作为平均值，并将其与本周进行比较，以扩大范围。因此，如果要预测一个星期一上午8点的指标值，不是使用一周前的相同五分钟窗口，而是使用前一周早上的上午6点至上午10点的指标平均值。</p><pre><code class="hljs ruby">- <span class="hljs-symbol">record:</span> <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m_prediction  <span class="hljs-symbol">expr:</span> &gt;    avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">4</span>h] offset <span class="hljs-number">166</span>h) <span class="hljs-comment"># Rounded value from last period</span>    + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w             <span class="hljs-comment"># Add 1w growth trend</span>    - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">1</span>w</code></pre><p>在查询中使用166个小时而不是一周，因为要根据一天中的当前时间使用四个小时，因此需要将偏移减少两个小时。</p><p><img src="/images/use-prometheus-for-anomaly-detection/gitaly-rps-weeks-prediction.png" alt="gitaly-rps-weeks-prediction.png"><br>两周的 Gitaly 服务 RPS（黄色）vs 预测（蓝色）。</p><p>将实际的 Gitaly RPS（黄色）与 预测（蓝色）进行比较表明，计算相当准确。但是，这种方法有缺陷。因为5月1日是国际劳动节，一个许多国家庆祝的节日，GitLab 的使用量低于平常的星期三。由于增长率是由前一周的使用情况决定的，因此我们对下周（5月8日，星期三）RPS 的预测会比 如果5月1日（星期三）没有假期更低。</p><p>可以通过在5月1日（星期三）之前连续三周（之前的星期三，再之前的星期三和三周之前的星期三）进行三个预测来解决此问题。查询保持不变，但偏移量已调整。</p><pre><code class="hljs ruby">- <span class="hljs-symbol">record:</span> <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m_prediction  <span class="hljs-symbol">expr:</span> &gt;   quantile(<span class="hljs-number">0</span>.<span class="hljs-number">5</span>,     label_replace(       avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">4</span>h] offset <span class="hljs-number">166</span>h)       + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">1</span>w       , <span class="hljs-string">"offset"</span>, <span class="hljs-string">"1w"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>)     <span class="hljs-keyword">or</span>     label_replace(       avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">4</span>h] offset <span class="hljs-number">334</span>h)       + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">2</span>w       , <span class="hljs-string">"offset"</span>, <span class="hljs-string">"2w"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>)     <span class="hljs-keyword">or</span>     label_replace(       avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">4</span>h] offset <span class="hljs-number">502</span>h)       + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">3</span>w       , <span class="hljs-string">"offset"</span>, <span class="hljs-string">"3w"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>)   )   without (offset)</code></pre><p><img src="/images/use-prometheus-for-anomaly-detection/gitaly-rps-three-weeks-prediction.png" alt="gitaly-rps-three-weeks-prediction.png"><br>三个星期三的三个预测与实际 5月8日（星期三，国际劳动节之后的一周）的 Gitaly RPS</p><p>在该图上，绘制了5月8日星期三和5月8日之前连续三个星期的三个预测。可以看到其中两个预测是好的，但是5月1日的预测仍远未达到基准。</p><p>而且，我们不需要三个预测，我们想要<strong>一个预测</strong>。取平均值是不可行的，因为它将被倾斜的 5月1日 RPS数据所稀释。相反，我们要计算中位数。Prometheus没有中位数查询，但可以使用分位数聚合来代替中位数。该方法的一个问题是，试图在一个聚合中包括三个系列，而这三个系列实际上在三周内都是相同的系列。换句话说，它们都具有相同的标签，因此连接它们很棘手。为避免混淆，我们创建了一个名为 <code>offset</code> 的标签，并使用 label-replace 函数为三个星期添加offset。接下来，在分位数聚合中，将其去除，以获得了三个中间值。</p><pre><code class="hljs ruby">- <span class="hljs-symbol">record:</span> <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m_prediction  <span class="hljs-symbol">expr:</span> &gt;   quantile(<span class="hljs-number">0</span>.<span class="hljs-number">5</span>,     label_replace(       avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">4</span>h] offset <span class="hljs-number">166</span>h)       + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">1</span>w       , <span class="hljs-string">"offset"</span>, <span class="hljs-string">"1w"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>)     <span class="hljs-keyword">or</span>     label_replace(       avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">4</span>h] offset <span class="hljs-number">334</span>h)       + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">2</span>w       , <span class="hljs-string">"offset"</span>, <span class="hljs-string">"2w"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>)     <span class="hljs-keyword">or</span>     label_replace(       avg_over_time(<span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m[<span class="hljs-number">4</span>h] offset <span class="hljs-number">502</span>h)       + <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>avg_over_time_1w offset <span class="hljs-number">3</span>w       , <span class="hljs-string">"offset"</span>, <span class="hljs-string">"3w"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>)   )   without (offset)</code></pre><p>现在，从三个聚合系列中得出中值的预测更加准确。</p><p><img src="/images/use-prometheus-for-anomaly-detection/gitaly-rps-median-weeks-prediction.png" alt="gitaly-rps-median-weeks-prediction.png"><br>中位数预测与实际 Gitaly RPS 的比较，5月8日（星期三，国际劳动节之后的一周）</p><h3 id="怎么知道预测是真正准确的？"><a href="#怎么知道预测是真正准确的？" class="headerlink" title="怎么知道预测是真正准确的？"></a>怎么知道预测是真正准确的？</h3><p>为了测试预测的准确性，可以返回 z-score。可以使用 z-score 来测量样本与标准偏差预测值之间的差距。偏离预测的标准偏差越多，则特定值是异常可能性就越大。</p><p><img src="/images/use-prometheus-for-anomaly-detection/gitaly-rps-normal-range-prediction.png" alt="gitaly-rps-normal-range-prediction.png"><br>Gitaly 服务的预测正常范围 ±1.5σ</p><p>我们可以更新 Grafana 图表以使用季节性预测而不是每周滚动平均值。一天中特定时间的正常范围以绿色阴影显示。任何落在绿色阴影区域之外的东西都被认为是异常值。在这种情况下，离群值发生在周日下午，此时我们的云提供商遇到了一些网络问题。在我们的预测的任一侧使用±2σ的边界是确定季节性预测的异常值的一种很好的方法。</p><h3 id="如何使用Prometheus设置警报"><a href="#如何使用Prometheus设置警报" class="headerlink" title="如何使用Prometheus设置警报"></a>如何使用Prometheus设置警报</h3><p>如果要为异常事件设置警报，可以对 Prometheus 应用一个非常简单的规则，该规则检查指标的 z-score 是否在标准偏差 +2 或 -2 之间。</p><pre><code class="hljs ruby">- <span class="hljs-symbol">alert:</span> RequestRateOutsideNormalRange  <span class="hljs-symbol">expr:</span> &gt;   abs(     (       <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m - <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span>rate5m_prediction     ) / <span class="hljs-symbol">job:</span><span class="hljs-symbol">http_requests:</span><span class="hljs-symbol">rate5m:</span>stddev_over_time_1w   ) &gt; <span class="hljs-number">2</span>  <span class="hljs-symbol">for:</span> <span class="hljs-number">10</span>m  <span class="hljs-symbol">labels:</span>    <span class="hljs-symbol">severity:</span> warning  <span class="hljs-symbol">annotations:</span>    <span class="hljs-symbol">summary:</span> Requests <span class="hljs-keyword">for</span> job &#123;&#123; $labels.job &#125;&#125; are outside of expected operating parameters</code></pre><p>在 GitLab，我们使用了自定义路由规则，该规则会在检测到任何异常时 pings Slack，但不会寻呼值班的支持人员。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>Prometheus 可用于某些类型的异常检测</li><li>正确级别的数据聚合是异常检测的关键</li><li>如果数据具有正态分布，则 z-score 是一种有效的方法</li><li>季节性指标可以为异常检测提供出色的结果</li></ol><p>视频链接：<a href="https://vimeo.com/341141334" target="_blank" rel="noopener">https://vimeo.com/341141334</a><br>原文链接：<a href="https://about.gitlab.com/blog/2019/07/23/anomaly-detection-using-prometheus/" target="_blank" rel="noopener">https://about.gitlab.com/blog/2019/07/23/anomaly-detection-using-prometheus/</a></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/01-22-2020/use-prometheus-for-anomaly-detection.html">https://www.cyningsun.com/01-22-2020/use-prometheus-for-anomaly-detection.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Prometheus 查询语言的最基本功能之一是实时汇总时间序列数据。GitLab基础架构团队的杰出工程师 &lt;code&gt;Andrew Newdigate&lt;/code&gt; 认为 Prometheus 查询语言也可以用于检测时间序列数据中的异常。本博客文章解释了异常检测如何与 P
      
    
    </summary>
    
    
      <category term="SRE" scheme="https://www.cyningsun.com/category/SRE/"/>
    
    
      <category term="Anomaly detection" scheme="https://www.cyningsun.com/tag/Anomaly-detection/"/>
    
  </entry>
  
  <entry>
    <title>深度探索 Go 对象模型</title>
    <link href="https://www.cyningsun.com/01-12-2020/inside-the-go-object-model.html"/>
    <id>https://www.cyningsun.com/01-12-2020/inside-the-go-object-model.html</id>
    <published>2020-01-11T16:00:00.000Z</published>
    <updated>2020-02-03T06:53:29.646Z</updated>
    
    <content type="html"><![CDATA[<p>了解一门语言的高级特性，仅仅从浮于表面，是无法把握住语言的精髓的。学习过 C++ 的高阶开发者，一定读过神书《Inside The C++ Object Model》，本文的目标是一样的：通过对象模型，掌握 Go 语言的底层机制，从更深层次解释语言特性。</p><h3 id="编译与执行"><a href="#编译与执行" class="headerlink" title="编译与执行"></a>编译与执行</h3><p>众所周知，Go 源码并不能直接运行，所有代码必须一行行，通过“编译”——“汇编”——“链接” 阶段 转化为低级的机器语言指令，即可执行程序。</p><p><img src="/images/go-object-model/compile.png" alt="compile.png"></p><p>“汇编”和“链接”阶段各种语言并无区别，所以一般通过“编译”和“执行”阶段来支持各种语言特性。对于 Go 语言，执行过程并无法直接修改执行指令，因此所有语言特性都是“编译”相关的。理解这一点很重要，因为下面依赖“编译”的产物 <strong>汇编代码</strong> 来解读对象模型。</p><h3 id="什么是对象模型？"><a href="#什么是对象模型？" class="headerlink" title="什么是对象模型？"></a>什么是对象模型？</h3><p>何为 Go 对象模型？ Go 对象模型可以概括为以下两部分：</p><ol><li>支持面向对象程序设计的部分<blockquote><ul><li>封装</li><li>继承</li><li>多态</li></ul></blockquote></li><li>各种特性的底层实现机制<blockquote><ul><li>反射</li></ul></blockquote></li></ol><p>下面分别从 struct 和 interface 来解释模型如何支持以上两部分。</p><h3 id="Struct-语意学"><a href="#Struct-语意学" class="headerlink" title="Struct 语意学"></a>Struct 语意学</h3><p><img src="/images/go-object-model/struct.png" alt="struct.png"></p><p>面向对象编程，把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数，前者为成员变量，后者为成员函数。所以研究对象需要分别从成员变量和成员函数入手。</p><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>以下有三段程序：</p><pre><code class="hljs go"><span class="hljs-comment">// First: global varible</span><span class="hljs-keyword">var</span> (   X,Y,Z <span class="hljs-keyword">float32</span>)<span class="hljs-comment">// Second: simple type</span><span class="hljs-keyword">type</span> point3d <span class="hljs-keyword">struct</span> &#123;X, Y, Z <span class="hljs-keyword">float32</span>&#125;<span class="hljs-comment">// Third: inherit type</span><span class="hljs-keyword">type</span> point <span class="hljs-keyword">struct</span> &#123;X <span class="hljs-keyword">float32</span>&#125;<span class="hljs-keyword">type</span> point2d <span class="hljs-keyword">struct</span> &#123;pointY <span class="hljs-keyword">float32</span>&#125;<span class="hljs-keyword">type</span> point3d <span class="hljs-keyword">struct</span> &#123;point2dZ <span class="hljs-keyword">float32</span>&#125;</code></pre><p>从风格来看，三段程序截然不同。有许多令人信服的讨论告诉我们，为什么“数据封装”（Second &amp; Third）要比使用“全局变量”好。但，从程序员的角度看，会有几个疑问：</p><blockquote><ol><li>“数据封装” 之后，内存成本增加了多少？</li><li>“数据封装” 之后，在执行过程中，变量的存储效率是否降低了？</li></ol></blockquote><h5 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h5><p>先看内存变化。了解内存变化最好的办法就是通过代码打印对象的内存大小，先看全局变量大小</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> (X, Y, Z <span class="hljs-keyword">float32</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">"X size:%v, Y size:%v, Z size:%v\n"</span>, unsafe.Sizeof(X), unsafe.Sizeof(Y), unsafe.Sizeof(Z))fmt.Printf(<span class="hljs-string">"X addr:%v, Y addr:%v, Z addr:%v\n"</span>, &amp;X, &amp;Y, &amp;Z)&#125;</code></pre><p>执行程序输出为：</p><pre><code class="hljs sh">$ go run variable.goX size:4, Y size:4, Z size:4X addr:0x118ee88, Y addr:0x118ee8c, Z addr:0x118ee90</code></pre><p>可以看到，X、Y、Z三个字段大小均为4字节，且三个字段内存地址顺序排列。</p><p>再看第二段代码的输出</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestLayout</span><span class="hljs-params">(t *testing.T)</span></span> &#123;p := point3d&#123;X: <span class="hljs-number">1</span>, Y: <span class="hljs-number">2</span>, Z: <span class="hljs-number">3</span>&#125;fmt.Printf(<span class="hljs-string">"point3d size:%v, align:%v\n"</span>, unsafe.Sizeof(p), unsafe.Alignof(p))typ := reflect.TypeOf(p)fmt.Printf(<span class="hljs-string">"Struct:%v is %d bytes long\n"</span>, typ.Name(), typ.Size())fmt.Printf(<span class="hljs-string">"X at offset %v, size=%d\n"</span>, unsafe.Offsetof(p.X), unsafe.Sizeof(p.X))fmt.Printf(<span class="hljs-string">"Y at offset %v, size=%d\n"</span>, unsafe.Offsetof(p.Y), unsafe.Sizeof(p.Y))fmt.Printf(<span class="hljs-string">"Z at offset %v, size=%d\n"</span>, unsafe.Offsetof(p.Z), unsafe.Sizeof(p.Z))&#125;</code></pre><p>执行程序输出为：</p><pre><code class="hljs sh">$ go <span class="hljs-built_in">test</span> -v -run TestLayout=== RUN   TestLayoutpoint3d size:12, align:4Struct:point3d is 12 bytes longX at offset 0, size=4Y at offset 4, size=4Z at offset 8, size=4</code></pre><p>可以看到，X、Y、Z三个字段大小一样为4字节，内存排列也与上一个版本一样。</p><p>继续，第三段代码</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestLayout</span><span class="hljs-params">(t *testing.T)</span></span> &#123;p := point3d&#123;point2d: point2d&#123;point: point&#123;X: <span class="hljs-number">1</span>&#125;, Y: <span class="hljs-number">2</span>&#125;, Z: <span class="hljs-number">3</span>&#125;fmt.Printf(<span class="hljs-string">"point3d size:%v, align:%v\n"</span>, unsafe.Sizeof(p), unsafe.Alignof(p))typ := reflect.TypeOf(p)fmt.Printf(<span class="hljs-string">"Struct:%v is %d bytes long\n"</span>, typ.Name(), typ.Size())fmt.Printf(<span class="hljs-string">"X at offset %v, size=%d\n"</span>, unsafe.Offsetof(p.X), unsafe.Sizeof(p.X))fmt.Printf(<span class="hljs-string">"Y at offset %v, size=%d\n"</span>, unsafe.Offsetof(p.Y), unsafe.Sizeof(p.Y))fmt.Printf(<span class="hljs-string">"Z at offset %v, size=%d\n"</span>, unsafe.Offsetof(p.Z), unsafe.Sizeof(p.Z))&#125;</code></pre><p>执行程序输出为：</p><pre><code class="hljs sh">$ go <span class="hljs-built_in">test</span> -v -run TestLayout=== RUN   TestLayoutpoint3d size:12, align:4Struct:point3d is 12 bytes longX at offset 0, size=4Y at offset 4, size=4Z at offset 8, size=4</code></pre><p>可以看到，X、Y、Z三个字段大小一样为4字节，内存排列也与之前两个版本一样。</p><p>综上所述，我们可以看到，无论是否封装，还是多深的继承层次，对成员变量的内存布局都并无影响，均按照字段定义的顺序排列（不考虑内存对齐的情况）。即内存布局类似如下：</p><p><img src="/images/go-object-model/memory-offset.png" alt="memory-offset.png"></p><h5 id="变量存取"><a href="#变量存取" class="headerlink" title="变量存取"></a>变量存取</h5><p>成员变量有两种读取方式，既可以通过对象读取，也可以通过对象的指针读取。两种读取方式与直接变量读取会有什么不同么？使用一段代码再看下：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> point <span class="hljs-keyword">struct</span> &#123;X <span class="hljs-keyword">float32</span>&#125;<span class="hljs-keyword">type</span> point2d <span class="hljs-keyword">struct</span> &#123;pointY <span class="hljs-keyword">float32</span>&#125;<span class="hljs-keyword">type</span> point3d <span class="hljs-keyword">struct</span> &#123;point2dZ <span class="hljs-keyword">float32</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> (w <span class="hljs-keyword">float32</span>)point := point3d&#123;point2d: point2d&#123;point: point&#123;X: <span class="hljs-number">1</span>&#125;, Y: <span class="hljs-number">2</span>&#125;, Z: <span class="hljs-number">3</span>&#125; <span class="hljs-comment">// L25</span>p := &amp;point  <span class="hljs-comment">// L26</span>w = point.Y  <span class="hljs-comment">// L27</span>fmt.Printf(<span class="hljs-string">"w:%f\n"</span>, w)w = p.Y     <span class="hljs-comment">// L29</span>fmt.Printf(<span class="hljs-string">"w:%f\n"</span>, w)&#125;</code></pre><p>还记得之前提过的“编译”阶段么？我们使用 go tool 可以查看源代码汇编之后的代码</p><pre><code class="hljs x86asm"><span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x10948d8</span>f30f11442444<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x44</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x10948de</span>f30f11442448<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x48</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x10948e4</span>f30f1144244c<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x4c</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x10948ea</span>f30f10055ab50400<span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.</span>3f800000(SB), X0<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x10948f2</span>f30f11442444<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x44</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x10948f8</span>f30f100550b50400<span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.40000000</span>(SB), X0<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x1094900</span>f30f11442448<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x48</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x1094906</span>f30f100546b50400<span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.40400000</span>(SB), X0<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x109490e</span>f30f1144244c<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x4c</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">26</span><span class="hljs-number">0x1094914</span>488d442444LEAQ <span class="hljs-number">0x44</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span><span class="hljs-symbol">data_access.go:</span><span class="hljs-number">26</span><span class="hljs-number">0x1094919</span><span class="hljs-number">4889442450</span><span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0x50</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">27</span><span class="hljs-number">0x109491e</span>f30f10442448<span class="hljs-keyword">MOVSS</span> <span class="hljs-number">0x48</span>(<span class="hljs-built_in">SP</span>), X0// 读取 Y 到寄存器 X0<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">27</span><span class="hljs-number">0x1094924</span>f30f11442440<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x40</span>(<span class="hljs-built_in">SP</span>)// 赋值 寄存器 X0 给 w...<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">29</span><span class="hljs-number">0x10949c7</span>488b442450<span class="hljs-keyword">MOVQ</span> <span class="hljs-number">0x50</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span>// 读取 对象地址 到寄存器 <span class="hljs-built_in">AX</span> <span class="hljs-symbol">data_access.go:</span><span class="hljs-number">29</span><span class="hljs-number">0x10949cc</span><span class="hljs-number">8400</span>TESTB <span class="hljs-built_in">AL</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">AX</span>)<span class="hljs-symbol">data_access.go:</span><span class="hljs-number">29</span><span class="hljs-number">0x10949ce</span>f30f104004<span class="hljs-keyword">MOVSS</span> <span class="hljs-number">0x4</span>(<span class="hljs-built_in">AX</span>), X0// 从对象起始地址偏移<span class="hljs-number">4</span>字节读取数据到寄存器 X0 <span class="hljs-symbol">data_access.go:</span><span class="hljs-number">29</span><span class="hljs-number">0x10949d3</span>f30f11442440<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x40</span>(<span class="hljs-built_in">SP</span>)// 赋值 寄存器 X0 给 w</code></pre><p>可以看到，每个成员变量的偏移量在编译时即可获知，不管其有多么复杂的继承，都是一样的。通过对象存取一个data member，其效率和存取一个非成员变量是一样的。</p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>前面的例子提过，对象的总大小刚好等于所有的成员变量之和，也就意味着成员函数并不占用对象的内存大小。那成员函数的调用是怎么实现的呢？我们通过一段代码看下</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> point3d <span class="hljs-keyword">struct</span> &#123;X, Y, Z <span class="hljs-keyword">float32</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *point3d)</span> <span class="hljs-title">Println</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">"%v,%v,%v\n"</span>, p.X, p.Y, p.Z)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;p := point3d&#123;X: <span class="hljs-number">1</span>, Y: <span class="hljs-number">2</span>, Z: <span class="hljs-number">3</span>&#125; <span class="hljs-comment">// L14</span>p.Println()                   <span class="hljs-comment">// L15</span>&#125;</code></pre><p>同样使用 go tool获取对应的汇编代码</p><pre><code class="hljs x86asm"><span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094a7d</span>0f57c0<span class="hljs-keyword">XORPS</span> X0, X0<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094a80</span>f30f1144240c<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0xc</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094a86</span>f30f11442410<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x10</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094a8c</span>f30f11442414<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x14</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094a92</span>f30f100592b30400<span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.</span>3f800000(SB), X0<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094a9a</span>f30f1144240c<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0xc</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094aa0</span>f30f100588b30400<span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.40000000</span>(SB), X0<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094aa8</span>f30f11442410<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x10</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094aae</span>f30f10057eb30400<span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.40400000</span>(SB), X0<span class="hljs-symbol">call.go:</span><span class="hljs-number">14</span><span class="hljs-number">0x1094ab6</span>f30f11442414<span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x14</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">call.go:</span><span class="hljs-number">15</span><span class="hljs-number">0x1094abc</span>488d44240cLEAQ <span class="hljs-number">0xc</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span> //将对象 q 的起始地址保存到寄存器<span class="hljs-built_in">AX</span><span class="hljs-symbol">call.go:</span><span class="hljs-number">15</span><span class="hljs-number">0x1094ac1</span><span class="hljs-number">48890424</span><span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">SP</span>)  //将对象 q 的起始地址 压栈<span class="hljs-symbol">call.go:</span><span class="hljs-number">15</span><span class="hljs-number">0x1094ac5</span>e8d6fdffff<span class="hljs-keyword">CALL</span> main.(*point3d).Println(SB)  // 调用 struct point 的 Println() 函数</code></pre><p>可以看到成员函数的调用都是先把参数压栈，然后调用对应的的函数。可见，成员函数与普通的函数调用并无不同。那么函数的内存在哪里呢？</p><p>还记得进程的内存分布么？</p><p><img src="/images/go-object-model/process-memory.png" alt="process-memory.png"></p><p>没错，所有的函数都在进程的代码段（Text Segment）</p><h3 id="Interface-语意学"><a href="#Interface-语意学" class="headerlink" title="Interface 语意学"></a>Interface 语意学</h3><p>第一部分讲了，封装和继承的影响，剩下这部分会讲清楚 Go 如何使用 interface 实现<code>多态</code>和<code>反射</code>。其中interface又有两种形式，一种是有函数的非空interface，一种是空的interface（interface{}）。话不多说，直接上代码，看下这两种类型的interface的变量在内存大小上有何区别：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">interface</span> &#123;Println()&#125;<span class="hljs-keyword">type</span> point <span class="hljs-keyword">struct</span> &#123;X <span class="hljs-keyword">float32</span>&#125;<span class="hljs-keyword">type</span> point2d <span class="hljs-keyword">struct</span> &#123;pointY <span class="hljs-keyword">float32</span>&#125;<span class="hljs-keyword">type</span> point3d <span class="hljs-keyword">struct</span> &#123;point2dZ <span class="hljs-keyword">float32</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPolymorphism</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">var</span> (p Point)p = &amp;point&#123;X: <span class="hljs-number">1</span>&#125;fmt.Printf(<span class="hljs-string">"point size:%v\n\n"</span>, unsafe.Sizeof(p))p = &amp;point2d&#123;point: point&#123;X: <span class="hljs-number">1</span>&#125;, Y: <span class="hljs-number">2</span>&#125;fmt.Printf(<span class="hljs-string">"point2d size:%v\n\n"</span>, unsafe.Sizeof(p))p = &amp;point3d&#123;point2d: point2d&#123;point: point&#123;X: <span class="hljs-number">1</span>&#125;, Y: <span class="hljs-number">2</span>&#125;, Z: <span class="hljs-number">3</span>&#125;fmt.Printf(<span class="hljs-string">"point3d size:%v\n\n"</span>, unsafe.Sizeof(p))&#125;</code></pre><p>执行程序输出为：</p><pre><code class="hljs sh">$ go <span class="hljs-built_in">test</span> -v -run TestPolymorphism=== RUN   TestPolymorphismp size:16, nilP size:16p size:16, nilP size:16p size:16, nilP size:16</code></pre><p>可以看到两种类型的interface 变量大小并无不同，均为16字节。可以明确一点：interface 变量中存储的并非对象的指针，而是特殊的定义类型的变量。那么 interface 是怎么支持<code>多态</code>和<code>反射</code>的呢？</p><p>通过 <code>reflect</code> 包，我们找到了答案。原来，针对以上两种类型的interface， Go 语言底层定义了两个结构分别为 iface 和 eface。两者实现是类似的，以下我们仅针对非空interface进行分析</p><h4 id="interface-底层"><a href="#interface-底层" class="headerlink" title="interface 底层"></a>interface 底层</h4><pre><code class="hljs go"><span class="hljs-keyword">type</span> iface <span class="hljs-keyword">struct</span> &#123;    tab  *itab          <span class="hljs-comment">// 类型信息</span>    data unsafe.Pointer  <span class="hljs-comment">// 接口指向对象的指针</span>&#125;<span class="hljs-comment">// 类型信息</span><span class="hljs-keyword">type</span> itab <span class="hljs-keyword">struct</span> &#123;    inter  *interfacetype    <span class="hljs-comment">// 接口的类型信息</span>    _type  *_type           <span class="hljs-comment">// 接口指向对象的类型信息</span>hash  <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// copy of _type.hash. Used for type switches.</span>_     [<span class="hljs-number">4</span>]<span class="hljs-keyword">byte</span>    fun    [<span class="hljs-number">1</span>]<span class="hljs-keyword">uintptr</span>       <span class="hljs-comment">// 接口方法实现列表，即函数地址列表，按字典序排序</span>&#125;<span class="hljs-comment">// 接口类型信息</span><span class="hljs-keyword">type</span> interfacetype <span class="hljs-keyword">struct</span> &#123;   typ     _type   pkgpath name   mhdr    []imethod      <span class="hljs-comment">// 接口方法声明列表，按字典序排序</span>&#125;</code></pre><p>通过代码，可以看到，iface 类型包含两个指针，刚好为16字节（64位机器）。iface 不但包含了<code>指向对象</code>、<code>指向对象的类型</code>，还包含了<code>接口类型</code>。如此</p><ol><li>iface 就可以在其中扮演粘结剂的角色，通过 reflect 包在对象、接口、类型之间进行转换了。</li><li>iface 的变量可以在<code>编译</code>阶段，在变量赋值处，增加拷贝指向对象（父类或者子类）的类型信息的指令，就可以在运行期完成多态的支持了</li></ol><p><img src="/images/go-object-model/interface.png" alt="interface.png"></p><h4 id="理论验证"><a href="#理论验证" class="headerlink" title="理论验证"></a>理论验证</h4><p>下面我们还是通过测试代码来验证我们的理论，我们自己定义底层的相关类型，然后通过强制类型转换，来尝试解析interface变量中的数据：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Iface <span class="hljs-keyword">struct</span> &#123;Tab *ItabData unsafe.Pointer&#125;<span class="hljs-keyword">type</span> Itab <span class="hljs-keyword">struct</span> &#123;Inter <span class="hljs-keyword">uintptr</span>Type <span class="hljs-keyword">uintptr</span>Hash <span class="hljs-keyword">uint32</span>_ [<span class="hljs-number">4</span>]<span class="hljs-keyword">byte</span>Fun [<span class="hljs-number">1</span>]<span class="hljs-keyword">uintptr</span>&#125;<span class="hljs-keyword">type</span> Eface <span class="hljs-keyword">struct</span> &#123;Type <span class="hljs-keyword">uintptr</span>Data unsafe.Pointer&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestInterface</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">var</span> (p    PointnilP <span class="hljs-keyword">interface</span>&#123;&#125;)point := &amp;point3d&#123;X: <span class="hljs-number">1</span>, Y: <span class="hljs-number">2</span>, Z: <span class="hljs-number">3</span>&#125;nilP = pointfmt.Printf(<span class="hljs-string">"eface size:%v\n"</span>, unsafe.Sizeof(nilP))eface := (*face.Eface)(unsafe.Pointer(&amp;nilP))spew.Dump(eface.Type)spew.Dump(eface.Data)fmt.Printf(<span class="hljs-string">"eface offset: eface._type = %v, eface.data = %v\n\n"</span>,unsafe.Offsetof(eface.Type), unsafe.Offsetof(eface.Data))p = pointfmt.Printf(<span class="hljs-string">"point size:%v\n"</span>, unsafe.Sizeof(p))iface := (*face.Iface)(unsafe.Pointer(&amp;p))spew.Dump(iface.Tab)spew.Dump(iface.Data)fmt.Printf(<span class="hljs-string">"Iface offset: iface.tab = %v, iface.data = %v\n\n"</span>,unsafe.Offsetof(iface.Tab), unsafe.Offsetof(iface.Data))&#125;</code></pre><p>执行程序输出为：</p><pre><code class="hljs sh">$ go <span class="hljs-built_in">test</span> -v -run TestInterface=== RUN   TestInterfaceeface size:16(uintptr) 0x111f2c0(unsafe.Pointer) 0xc00008e250eface offset: eface._type = 0, eface.data = 8point size:16(*face.Itab)(0x116ec40)(&#123; Inter: (uintptr) 0x1122680, Type: (uintptr) 0x111f2c0, Hash: (uint32) 960374823, _: ([4]uint8) (len=4 <span class="hljs-built_in">cap</span>=4) &#123;  00000000  00 00 00 00                                       |....| &#125;, Fun: ([1]uintptr) (len=1 <span class="hljs-built_in">cap</span>=1) &#123;  (uintptr) 0x10fce20 &#125;&#125;)(unsafe.Pointer) 0xc00008e250Iface offset: iface.tab = 0, iface.data = 8</code></pre><p>下面我们再通过汇编代码看下，赋值操作做了什么？</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">interface</span> &#123;Println()&#125;<span class="hljs-keyword">type</span> point3d <span class="hljs-keyword">struct</span> &#123;X, Y, Z <span class="hljs-keyword">float32</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *point3d)</span> <span class="hljs-title">Println</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">"%v,%v,%v\n"</span>, p.X, p.Y, p.Z)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;point := point3d&#123;X: <span class="hljs-number">1</span>, Y: <span class="hljs-number">2</span>, Z: <span class="hljs-number">3</span>&#125; <span class="hljs-comment">// L18</span><span class="hljs-keyword">var</span> (nilP <span class="hljs-keyword">interface</span>&#123;&#125;   <span class="hljs-comment">// L20</span>p    Point        <span class="hljs-comment">// L21</span>)nilP = &amp;point         <span class="hljs-comment">// L23</span>p = &amp;point            <span class="hljs-comment">// L24</span>fmt.Println(nilP, p) &#125;</code></pre><p>通过 go tool 查看汇编代码如下：</p><pre><code class="hljs x86asm">TEXT main<span class="hljs-number">.</span>main(SB) /Users/cyningsun/Documents/go/src/github<span class="hljs-number">.</span>com/cyningsun/go-<span class="hljs-keyword">test</span>/<span class="hljs-number">20200102</span>-inside-golang-object-model/main/build<span class="hljs-number">.</span>go<span class="hljs-symbol">  build.go:</span><span class="hljs-number">17</span><span class="hljs-number">0x1094de0</span>65488b0c2530000000      <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">GS</span>:<span class="hljs-number">0x30</span>, <span class="hljs-built_in">CX</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">17</span><span class="hljs-number">0x1094de9</span>488d4424b0              LEAQ -<span class="hljs-number">0x50</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">17</span><span class="hljs-number">0x1094dee</span>483b4110                CMPQ <span class="hljs-number">0x10</span>(<span class="hljs-built_in">CX</span>), <span class="hljs-built_in">AX</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">17</span><span class="hljs-number">0x1094df2</span>0f86b9010000            <span class="hljs-keyword">JBE</span> <span class="hljs-number">0x1094fb1</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">17</span><span class="hljs-number">0x1094df8</span>4881ecd0000000          SUBQ <span class="hljs-number">$0</span>xd0, <span class="hljs-built_in">SP</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">17</span><span class="hljs-number">0x1094dff</span>4889ac24c8000000        <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">BP</span>, <span class="hljs-number">0xc8</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">17</span><span class="hljs-number">0x1094e07</span>488dac24c8000000        LEAQ <span class="hljs-number">0xc8</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">BP</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e0f</span>488d05ea1e0200          LEAQ type.*+<span class="hljs-number">137216</span>(SB), <span class="hljs-built_in">AX</span>   // point := point3d&#123;X: <span class="hljs-number">1</span>, Y: <span class="hljs-number">2</span>, Z: <span class="hljs-number">3</span>&#125;<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e16</span><span class="hljs-number">48890424</span>                <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e1a</span>e81160f7ff              <span class="hljs-keyword">CALL</span> runtime<span class="hljs-number">.</span>newobject(SB)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e1f</span>488b442408              <span class="hljs-keyword">MOVQ</span> <span class="hljs-number">0x8</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e24</span><span class="hljs-number">4889442458</span>              <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0x58</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e29</span>0f57c0                  <span class="hljs-keyword">XORPS</span> X0, X0<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e2c</span>f30f11442434            <span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x34</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e32</span>f30f11442438            <span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x38</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e38</span>f30f1144243c            <span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x3c</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e3e</span>f30f1005a6b80400        <span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.</span>3f800000(SB), X0<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e46</span>f30f11442434            <span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0x34</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e4c</span>f30f100d9cb80400        <span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.40000000</span>(SB), X1<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e54</span>f30f114c2438            <span class="hljs-keyword">MOVSS</span> X1, <span class="hljs-number">0x38</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e5a</span>f30f101592b80400        <span class="hljs-keyword">MOVSS</span> $f32<span class="hljs-number">.40400000</span>(SB), X2<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e62</span>f30f1154243c            <span class="hljs-keyword">MOVSS</span> X2, <span class="hljs-number">0x3c</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e68</span>488b442458              <span class="hljs-keyword">MOVQ</span> <span class="hljs-number">0x58</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e6d</span>f30f1100                <span class="hljs-keyword">MOVSS</span> X0, <span class="hljs-number">0</span>(<span class="hljs-built_in">AX</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e71</span>f30f114804              <span class="hljs-keyword">MOVSS</span> X1, <span class="hljs-number">0x4</span>(<span class="hljs-built_in">AX</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">18</span><span class="hljs-number">0x1094e76</span>f30f115008              <span class="hljs-keyword">MOVSS</span> X2, <span class="hljs-number">0x8</span>(<span class="hljs-built_in">AX</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">20</span><span class="hljs-number">0x1094e7b</span>0f57c0                  <span class="hljs-keyword">XORPS</span> X0, X0 // nilP interface&#123;&#125;<span class="hljs-symbol">  build.go:</span><span class="hljs-number">20</span><span class="hljs-number">0x1094e7e</span>0f11442470              <span class="hljs-keyword">MOVUPS</span> X0, <span class="hljs-number">0x70</span>(<span class="hljs-built_in">SP</span>)// nilP 开始地址为<span class="hljs-number">0x70</span><span class="hljs-symbol">  build.go:</span><span class="hljs-number">21</span><span class="hljs-number">0x1094e83</span>0f57c0                  <span class="hljs-keyword">XORPS</span> X0, X0 // p Point<span class="hljs-symbol">  build.go:</span><span class="hljs-number">21</span><span class="hljs-number">0x1094e86</span>0f11442460              <span class="hljs-keyword">MOVUPS</span> X0, <span class="hljs-number">0x60</span>(<span class="hljs-built_in">SP</span>)<span class="hljs-symbol">  build.go:</span><span class="hljs-number">23</span><span class="hljs-number">0x1094e8b</span>488b442458              <span class="hljs-keyword">MOVQ</span> <span class="hljs-number">0x58</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span>// nilP = &amp;point  ；<span class="hljs-number">0x58</span>(<span class="hljs-built_in">SP</span>) 为 point 的地址<span class="hljs-symbol">  build.go:</span><span class="hljs-number">23</span><span class="hljs-number">0x1094e90</span><span class="hljs-number">4889442448</span>              <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0x48</span>(<span class="hljs-built_in">SP</span>) // <span class="hljs-built_in">SP</span> 指向 point 地址<span class="hljs-symbol">  build.go:</span><span class="hljs-number">23</span><span class="hljs-number">0x1094e95</span>488d0da4860100          LEAQ type.*+<span class="hljs-number">98368</span>(SB), <span class="hljs-built_in">CX</span> // ；从内存加载 Point类型地址 到 <span class="hljs-built_in">CX</span> 寄存器<span class="hljs-symbol">  build.go:</span><span class="hljs-number">23</span><span class="hljs-number">0x1094e9c</span>48894c2470              <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">CX</span>, <span class="hljs-number">0x70</span>(<span class="hljs-built_in">SP</span>) // ；将 Point类型地址（<span class="hljs-number">8</span>字节） 保存到 <span class="hljs-number">0x70</span>（即eface<span class="hljs-number">.</span>_type）<span class="hljs-symbol">  build.go:</span><span class="hljs-number">23</span><span class="hljs-number">0x1094ea1</span><span class="hljs-number">4889442478</span>              <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0x78</span>(<span class="hljs-built_in">SP</span>) // ；将 point 对象地址（<span class="hljs-number">8</span>字节） 保存到 <span class="hljs-number">0x78</span>（即eface<span class="hljs-number">.</span>data）<span class="hljs-symbol">  build.go:</span><span class="hljs-number">24</span><span class="hljs-number">0x1094ea6</span>488b442458              <span class="hljs-keyword">MOVQ</span> <span class="hljs-number">0x58</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span>// p = &amp;point<span class="hljs-symbol">  build.go:</span><span class="hljs-number">24</span><span class="hljs-number">0x1094eab</span><span class="hljs-number">4889442448</span>              <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0x48</span>(<span class="hljs-built_in">SP</span>)// ；<span class="hljs-built_in">SP</span> 指向 point 地址<span class="hljs-symbol">  build.go:</span><span class="hljs-number">24</span><span class="hljs-number">0x1094eb0</span>488d0d09d50400          LEAQ go<span class="hljs-number">.</span>itab.*main<span class="hljs-number">.</span>point3d,main<span class="hljs-number">.</span>Point(SB), <span class="hljs-built_in">CX</span>// ；从内存加载 Point类型 itab 地址 到 <span class="hljs-built_in">CX</span> 寄存器<span class="hljs-symbol">  build.go:</span><span class="hljs-number">24</span><span class="hljs-number">0x1094eb7</span>48894c2460              <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">CX</span>, <span class="hljs-number">0x60</span>(<span class="hljs-built_in">SP</span>)// ；将 Point类型地址（<span class="hljs-number">8</span>字节） 保存到 <span class="hljs-number">0x70</span>（即iface<span class="hljs-number">.</span>tab）<span class="hljs-symbol">  build.go:</span><span class="hljs-number">24</span><span class="hljs-number">0x1094ebc</span><span class="hljs-number">4889442468</span>              <span class="hljs-keyword">MOVQ</span> <span class="hljs-built_in">AX</span>, <span class="hljs-number">0x68</span>(<span class="hljs-built_in">SP</span>)// ；将 point 对象地址（<span class="hljs-number">8</span>字节） 保存到 <span class="hljs-number">0x78</span>（即iface<span class="hljs-number">.</span>data）<span class="hljs-symbol">  build.go:</span><span class="hljs-number">25</span><span class="hljs-number">0x1094ec1</span>488b442468              <span class="hljs-keyword">MOVQ</span> <span class="hljs-number">0x68</span>(<span class="hljs-built_in">SP</span>), <span class="hljs-built_in">AX</span>// fmt<span class="hljs-number">.</span>Println(nilP, p)  ...</code></pre><p>事实正如理论一般，在<code>编译</code>阶段，赋值命令被转化为类型信息和对象指针的拷贝，保存下来执行期转换所需要的一切信息。</p><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p>从底层代码和汇编出发，分析 struct 和 interface 的 对象模型，理清了Go 语言高级特性的底层机制。再去学习反射等表层细节，事半功倍。</p><p>参考链接：</p><ul><li><a href="https://www.cnblogs.com/qcrao-2018/p/11124360.html" target="_blank" rel="noopener">https://www.cnblogs.com/qcrao-2018/p/11124360.html</a></li><li><a href="https://yougg.github.io/2017/03/27/%E7%90%86%E8%A7%A3go%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B1interface%E5%BA%95%E5%B1%82%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">https://yougg.github.io/2017/03/27/理解go语言模型1interface底层详解/</a></li><li><a href="https://wudaijun.com/2018/01/go-interface-implement/" target="_blank" rel="noopener">https://wudaijun.com/2018/01/go-interface-implement/</a></li><li><a href="https://chai2010.cn/advanced-go-programming-book/ch3-asm/readme.html" target="_blank" rel="noopener">https://chai2010.cn/advanced-go-programming-book/ch3-asm/readme.html</a></li><li><a href="https://www.cnblogs.com/lsgxeva/p/8948153.html" target="_blank" rel="noopener">https://www.cnblogs.com/lsgxeva/p/8948153.html</a></li></ul><p><em>源代码：<a href="https://github.com/cyningsun/go-test" target="_blank" rel="noopener">https://github.com/cyningsun/go-test</a></em></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/01-12-2020/inside-the-go-object-model.html">https://www.cyningsun.com/01-12-2020/inside-the-go-object-model.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;了解一门语言的高级特性，仅仅从浮于表面，是无法把握住语言的精髓的。学习过 C++ 的高阶开发者，一定读过神书《Inside The C++ Object Model》，本文的目标是一样的：通过对象模型，掌握 Go 语言的底层机制，从更深层次解释语言特性。&lt;/p&gt;
&lt;h3 i
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Object model" scheme="https://www.cyningsun.com/tag/Object-model/"/>
    
  </entry>
  
  <entry>
    <title>译 | Concurrency is not Parallelism</title>
    <link href="https://www.cyningsun.com/12-09-2019/concurrency-is-not-parallelism.html"/>
    <id>https://www.cyningsun.com/12-09-2019/concurrency-is-not-parallelism.html</id>
    <published>2019-12-08T16:00:00.000Z</published>
    <updated>2020-02-03T06:53:29.645Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Concurrency-vs-Parallelism"><a href="#Concurrency-vs-Parallelism" class="headerlink" title="Concurrency vs Parallelism"></a>Concurrency vs Parallelism</h3><p><img src="/images/concurrency-is-not-parallelism/F684CB18-B7F7-4F72-937B-AB9486A9DD17.png" alt=""><br>如果你看看今天的编程语言，可能会发现这个世界是面向对象的，但实际上并非如此，世界是并行的。你通过网络等等，从最底层（例如：多核计算机）获取所有的东西，一路攀升到了解星球、宇宙。世界上所有的东西都在同时发生，但我们拥有的计算工具实际上并不擅长表达这种世界观。看起来似乎是一种失败，如果我们了解什么是并发性，以及如何使用它，就可以解决这个问题。</p><p><img src="/images/concurrency-is-not-parallelism/0B4B7CFD-C8F6-47F5-A1E6-88D65BB85FE9.png" alt=""><br>我将假设你们中的大多数人至少听说过 Go 编程语言，它也是我最近几年在 Google 工作的内容。Go 是一种并发语言，也就是说它使并发性有用，有像上帝一样同时执行事物的能力；有在同时执行的事物之间进行通信的能力；有叫做 <code>select</code> 语句的东西，它是一个多路并发控制开关。如果你搞不懂是怎么回事，不用担心。</p><p><img src="/images/concurrency-is-not-parallelism/E38701F9-2700-4C07-B65D-A29D775B97C6.png" alt=""><br>在大约两年前，当我们发布 Go 时，在场的程序员都说：”哦，并发工具，我知道做什么的，并行运行，耶“。但实际并非如此，并发性和并行性是不一样的，这是个常被误解的问题。我在这里试图解释原因，并向您展示并发性实际上更好。那些困惑的人会碰到什么事情：他们执行的程序，在更多的处理器上会变得更慢。他们会认为有问题，不管用，想要逃开。但真正有问题的是世界观，我希望我能改正它。</p><p><img src="/images/concurrency-is-not-parallelism/4F88E118-687C-4F42-8BE2-2D5580831530.png" alt=""><br>什么是并发性？并发性，如我当前使用的一样，用于计算机科学领域，是一种构建事物的方法。它是由独立执行的事物组成，通常是 <code>function</code>，虽然不一定必须如此。我们通常称之为交互式进程。称其为进程，并不是指 Linux 进程，指的是一种普遍的概念，它包括线程、协程、进程等等，所以尽可能抽象的理解。并发性由独立执行的进程组成；</p><p><img src="/images/concurrency-is-not-parallelism/ED376883-6235-46F5-91CA-37BCC88A753C.png" alt=""><br>另一方面，并行性是同时执行多个事物，可能相关，也可能无关。</p><p><img src="/images/concurrency-is-not-parallelism/7C6D5DA7-C6F2-4225-AA5B-23BCE7004567.png" alt=""><br>如果你用语焉不详的方式思考，并发性是指同时负责很多事情；并行性是指同时做很多事情。它们显然是相关的，但实际上是不同的概念，如果没有合适的工具包，尝试思考它们会有些困惑。一个是关于结构并发性，另一个是关于执行并行性。我会告诉你为什么这些概念很重要。并发性是一种构造事物的方法，以便可以使用并行性更好地完成工作。但并行性不是并发性的目标，并发性的目标是好的结构。</p><h4 id="An-analogy"><a href="#An-analogy" class="headerlink" title="An analogy"></a>An analogy</h4><p><img src="/images/concurrency-is-not-parallelism/9F2DC49E-17EB-4AA6-9BEB-5B7572D57E3B.png" alt=""><br>如果你在运行一个操作系统的话，会很熟悉的一个类比。操作系统可能有鼠标驱动程序、键盘驱动程序、显示驱动程序、网络驱动程序等等，都是由操作系统管理的，内核中的独立事物。它们都是并发的事物，却不一定是并行的。如果只有一个处理器，同一时间其中只有一个处于运行。I/O 设备具有一个并发模型，但本质不是并行的，它不需要是并行的。并行的事物可能类似向量点积，可以分解为微观操作，以使得可以在一些精美的计算机上并行执行。非常不同的概念，完全不是同一个东西。</p><h4 id="Cocurrency-plus-communication"><a href="#Cocurrency-plus-communication" class="headerlink" title="Cocurrency plus communication"></a>Cocurrency plus communication</h4><p><img src="/images/concurrency-is-not-parallelism/2D14E937-5A14-45E8-BDAC-7C62467C07F0.png" alt=""><br>为了能利用并发性，必须添加 <code>communication</code> 的概念。我今天不会聚焦于该概念太多，但一会儿你会看到一点点。并发性提供了一种将程序构造为独立块的方法，然后，必须使这些块协调一致。要使之工作，需要某种形式的 <code>communication</code>。<code>Tony Hoare</code> 在1978年写了一篇论文叫做 <code>《communicating sequential processes》</code>，实在是计算机科学中最伟大的论文之一。如果你还没读过，要是从本次演讲中真有什么领悟的话，回家你应该读读那篇论文。它太不可思议了，基于此论文，很多人未进行太多考虑就遵循、并构建工具，以将其思想运用到并发语言中，比如另一种很棒的语言Erlang。GO 中也有其一些思想，关键点都在原稿中，除了稍后会提到的几个小例外。</p><h4 id="Gophers"><a href="#Gophers" class="headerlink" title="Gophers"></a>Gophers</h4><p><img src="/images/concurrency-is-not-parallelism/C9C673A4-F191-49EA-9B1B-1BB894D5D75C.png" alt=""><br>但，你看这一切太抽象了。我们需要 Gopher 的帮忙，来一些 Gopher。</p><p><img src="/images/concurrency-is-not-parallelism/FD9C0294-1503-471E-B9D8-59696940C557.png" alt=""><br>有一个真正的问题我们要解决。有一堆过时的手册，可以是 C++98 手册，现在已经是 C++11；或许是 C++11 书籍，但不再需要了。关键是我们想要清理掉它们，它们占用了大量空间。所以我们的 Gopher 有一个任务，把书从书堆里取出来，放到焚化炉里清理掉。但是，如果是一大堆书，只有一个 Gopher 需要很长时间。Gopher 也不擅长搬运书籍，尽管我们提供了小车。</p><p><img src="/images/concurrency-is-not-parallelism/AA95F628-5041-42A0-B149-482B966B7D43.png" alt=""><br>所以再增加一个 Gopher 来解决这个问题，只有 Gopher 不会好起来，对吧？</p><p><img src="/images/concurrency-is-not-parallelism/E12F9D73-BF48-4C56-9AB6-A61B421B8464.png" alt=""><br>因为它需要工具，无可厚非，我们需要提供所有它需要的东西。Gopher 不仅需要作为 Gopher 的能力，也需要工具来完成任务。再给它一辆车，现在这样应该会更快。在两个 Gopher 推车的情况下，肯定能更快地搬运书。但可能存在一个小问题，因为我们必须使它们同步。来回奔波中，书堆互相妨碍，它们可能会被困在焚化炉里，所以它们需要协调一点。所以你可以想象 Gopher 们发送 <code>Tony Hoare</code> 的短信息，说：我到了，我需要空间把书放进焚化炉。不管是什么，但你明白了，这很傻。但我想解释清楚，这些概念并不深刻，它们非常好。</p><p><img src="/images/concurrency-is-not-parallelism/2EEF58D1-D127-441E-8DF4-EF08E1C6CBAD.png" alt=""><br>如何让它们搬运得更快，我们把一切都增加一倍。我们提供两个 Gopher，把书堆，焚化炉和 Gopher 一样也增加一倍。现在我们可以在相同的时间里搬运两倍的书，这是并行，对吧？</p><p><img src="/images/concurrency-is-not-parallelism/90B02D9C-3BE5-419A-82C5-2EAB915CBA46.png" alt=""><br>但是，想象它不是并行，而是两个 Gopher 的并发组合。并发性是我们表达问题的方式，两个 Gopher 可以做到这一点。我们通过实例化 Gopher 程序的更多实例来并行，这被称为进程（在此情况下称为 Gopher）的并发组合。</p><p><img src="/images/concurrency-is-not-parallelism/B71AB8B0-A361-4E9C-92CB-75437AF18B2B.png" alt=""><br>现在这种设计不是自动并行的。确实有两个 Gopher，但是谁说它们必须同时工作呢？我可以说，同时只有一个 Gopher 可以移动，就像单核计算机，此设计仍然是并发的，很好很正确，但它本质上不是并行的，除非让两个 Gopher 同时搬运。当并行出现时，有两个事物同时执行，而不仅仅是拥有两个事物。这是一个非常重要的模型，一旦断定理解了它，我们就会明白可以把问题分解成并发的块。</p><p><img src="/images/concurrency-is-not-parallelism/157116FA-6AF0-4F38-9F1A-7E59FE41A390.png" alt=""><br>我们可以想出其他模型，下面有一个不同的设计。在图中有三个 Gopher，同一堆书，同一个焚化炉，但是现在有三个 Gopher。有一个 Gopher，它的工作就是装车；有一个 Gopher，它的工作就是推车，然后再把空的还回去；还有一个 Gopher，它的工作就是装入焚化炉。三个 Gopher，速度理应会更快。但可能不会快多少，因为它们会被阻塞。书可能在错误的地方，在那里没有什么需要用车来做的。</p><p><img src="/images/concurrency-is-not-parallelism/2493625A-CFD7-4F6C-913D-4EAE6CA70EA5.png" alt=""><br>让我们处理下这个问题，另外增加一个Gopher归还空车，这明显很傻。但我想指出一个相当深刻的问题，这个版本的问题实际上会比之前版本的问题执行得更好。尽管为了完成更多的工作，增加了一个 Gopher 来回奔波。因此，一旦我们理解了并发性的概念，就可以向图片增加 Gopher，真的可以做更多的工作，使之运行得更快。因为管理的更好的块的并发组合真的可以运行得更快。工作可能不会恰好完美地进行，但是可以想象如果所有的 Gopher 的时间都恰到好处，它们知道每次搬运多少书。并发组合真的可以让4个 Gopher 都一直在忙碌。事实上，此版本可能比原来的版本快四倍。虽然可能性不大，但是我想让你理解，是可能的。</p><p><img src="/images/concurrency-is-not-parallelism/74721CF7-F9B0-4CEE-98F2-3495E0A5F8B7.png" alt=""><br>此时有一个发现，它非常重要而且很微妙，有些柔性。我们在现有的设计中通过添加并发程序来提高程序的性能。我们真的添加了更多的东西，整个过程变得更快了。如果仔细想想，有点奇怪，也有点不奇怪。因为额外添加了一个 Gopher，而且 Gopher 确实工作。但是如果你忘记了它是个 Gopher 的事实，并认为只是增加了东西，设计确实可以使它更高效。并行性可以出自于对问题更好的并发表达，这是一个相当深刻的见解。因为 Gopher 们的参与所以看起来不像。但是没关系。</p><p><img src="/images/concurrency-is-not-parallelism/92E07F4D-25AE-4575-819E-9992C18E7C26.png" alt=""><br>此时有四个进程并发运行。一个 Gopher 将东西装到车中；一个 Gopher 把车运到焚化炉；还有另一个 Gopher 将车中的物品卸到焚化炉中；第四个 Gopher 把空车还回来。您可以将它们视为独立的进程，完全独立运行的进程，我们只是将它们并行组合以构建完整的程序解决方案。这不是我们唯一可以构造的方案，以下是一个完全不同的设计。</p><p><img src="/images/concurrency-is-not-parallelism/4C538C68-A0E3-4EBA-AB71-7CC7FCA76F81.png" alt=""><br>通过增加另外一个堆书、焚化炉、和4个 Gopher，可以使该设计更加并行。但关键是，采用已有概念以分解问题。一旦清楚这是并发分解，就可以在不同的纬度上使其并行化。无论能否获得更好的吞吐量，但是至少，我们得以更细粒度的理解问题，可以控制这些块。在此情况下，如果一切刚好，会有8个 Gopher 努力以烧掉那些C++手册。</p><p><img src="/images/concurrency-is-not-parallelism/23DD3245-CDD7-49FF-8004-B8E3785CE7FD.png" alt=""><br>当然，也许根本没有发生并行，谁说这些 Gopher 必须同时工作，我可能每次只能运行一个 Gopher。在这种情况下，该设计只能像原始问题一样，以单个 Gopher 的速率运行。它执行时，其他7个将全部空闲。但该设计仍然是正确的。这很了不得，因为意味着我们在保证并发性时不必担心并行性。如果并发性正确，并行性实际上是一个自由变量，决定有多少个 Gopher 处于忙碌。我们可以为整个事情做一个完全不同的设计。</p><p><img src="/images/concurrency-is-not-parallelism/94750AF1-3D35-43D8-A44F-0A5BCE4CDC19.png" alt=""><br>让我们忘记将旧模式投入到新模式。在故事中有两个 Gopher，不再让一个 Gopher 从书堆一直运到焚化炉，而是在中间加入暂存区。因此，第一个 Gopher 将书籍搬运到暂存区，将它们丢下，跑回去再运另外一些。第二个 Gopher 坐在那里等待书达到暂存区，并把书从该位置搬运到焚化炉。如果一切良好，则有两个 Gopher 进程运行。它们是相同的类型，但有些细微不同，参数略有不同。如果系统将正常运行，一旦启动，其运行速度就会是原始模式的两倍。即使某些方面说它是完全不同的设计。一旦我们有了这个组合，我们可以采取另外的做法。</p><p><img src="/images/concurrency-is-not-parallelism/9622DA01-FA9C-4EC1-BE6A-AF554458F36C.png" alt=""><br>将以惯常的做法使其并行，同时运行整个程序的两个版本。翻倍之后，有了4个 Gopher，吞吐量将高达四倍。</p><p><img src="/images/concurrency-is-not-parallelism/CD8E183B-0510-485A-BD2D-27AD65026A1D.png" alt=""><br>或者，我们可以采用另一种做法，在刚才的并发多 Gopher 问题中，在中间加入暂存区。因此，现在我们有8个 Gopher 在运行，书籍非常快的速度被焚烧。</p><p><img src="/images/concurrency-is-not-parallelism/0524DA9D-3545-4F1C-B1A7-E8CB6F9B81C3.png" alt=""><br>但这样还不够好，因为我们可以在另一个维度并行，运力全开。此时，有16个 Gopher 将这些书搬运到焚化炉中。显然，增加 Gopher 使问题解决的更好，是非常简单和愚蠢的。但我希望您了解，从概念上讲，这真的就是您考虑并行运行事物的方式。您无需考虑并行运行，而是考虑如何将问题以可分解、可理解、可操作的方式，分解为独立的块，然后组合起来以解决整个问题。</p><h4 id="Lesson"><a href="#Lesson" class="headerlink" title="Lesson"></a>Lesson</h4><p><img src="/images/concurrency-is-not-parallelism/6FB652B7-954B-424E-8063-88E31B9B50B6.png" alt=""><br>以上就是的所有例子有什么意义呢？</p><p>首先，有很多方法可以做到这一点，我刚刚展示了一些。如果你坐在那里拿着一本速写册，你可能会想出另外50种让 Gopher 搬运书的方法。有很多不同的设计,它们不必都相同，但它们都能工作。然后，您可以对这些并发设计进行重构、重新排列、按不同的维度进行缩放，得到不同的功能以处理问题。真是太好了，因为不管你怎么做，处理这个问题的算法的正确性很容易保证。这样做不会搞砸，我的意思它们只是 Gopher，你知道这些设计本质上是安全的，因为你是那样做的。但是，这无疑是一个愚蠢的问题，与实际工作无关。嗯，事实上确实有关。</p><p><img src="/images/concurrency-is-not-parallelism/5E0FB781-8D54-40A7-8C96-1BFC52045109.png" alt=""><br>因为如果你拿到这个问题，把书堆换成一些网络内容；把 Gopher 换成 CPU，把推车换成网络或编码代码等等；把问题变成你需要移动数据；焚化炉是网络代理，或是浏览器，你想到的任何的数据使用者。您刚刚构建了一个 Web 服务体系结构的设计。你可能不认为你的 Web 服务架构是这样的，但事实上差不多就是这样。你可以把这两块替换掉看看，这正是你想的那种设计。当你谈论代理、转发代理和缓冲区之类会，扩容更多的实例的东西时，它们都在这个图上，只是不被这么想。本质上并不难理解它们，Gopher 能做到，我们也能。</p><h3 id="A-little-background-about-Go"><a href="#A-little-background-about-Go" class="headerlink" title="A little background about Go"></a>A little background about Go</h3><p><img src="/images/concurrency-is-not-parallelism/7754106E-933B-4A4B-9749-B234117F4857.png" alt=""><br>现在让我来展示如何在使用Go构建东西时采用这些概念。我不打算在这次演讲中教你 Go，希望你们有些人已经知道它，希望大家在之后能去更多了解它。但我要教一点点 Go，希望其他人也能像我们一样融入其中。</p><h4 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h4><p><img src="/images/concurrency-is-not-parallelism/4C5DDD77-2B78-4649-81B9-EFC7FF60BB4A.png" alt=""><br>Go 有叫做 goroutine 的东西，可以认为有点像线程，但实际上是不同的。与其详细地谈有什么不同，不如说说它是什么吧。假设我们有一个函数，函数有两个参数。如果在程序中调用该函数 F，则在执行下一条语句之前要等待该函数完成。很熟悉，大家都知道。但是，如果在调用该函数之前放置关键字 go。你调用该函数，函数开始运行，虽然不一，至少在概念上可以立即继续运行。想想并发与并行，从概念上讲，当 F 不在时，程序一直在运行，你在做 F 的事情，不用等 F 回来。如果你觉得很困惑，那就把它想象成一个很像 shell 里的 &amp; 符号。这就像在后台运行 F &amp;，确切地说是一个 goroutine。</p><p><img src="/images/concurrency-is-not-parallelism/4A73A123-176A-4751-BCAC-07B7CF11988C.png" alt=""><br>它有点像线程，因为一起运行在同一个地址空间中，至少在一个程序中如此。但 goroutine 要廉价得多，创建很容易，创建成本也很低。然后根据需要，goroutine 动态地多路映射到执行中的操作系统线程上，所以不必担心调度、阻塞等等，系统会帮你处理。当 goroutine 确实需要阻塞执行像 read 之类的系统调用时，其他 goroutine 不需要等待它，它们都是动态调度的。所以 goroutine 感觉像线程，却是更轻量版本的线程。这不是一个原始的概念，其他语言和系统已经实现了类似的东西。我们给它起了自己的名字来说明它是什么。所以称之为 goroutine。</p><h4 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h4><p><img src="/images/concurrency-is-not-parallelism/796A1563-AE4E-4143-AFF2-2E880045C514.png" alt=""><br>刚刚已经提到需要在 goroutine 之间通信。为了做到这一点，在 Go 中，称之为 channel。它有点像 shell 中的管道，但它有类型，还有其他一些很棒的特性，今天就不深入了。但以下有一个相当小的例子。我们创建了一个<code>timer channel</code>，显然它是一个时间值的 channel；然后在后台启动这个函数；sleep 一定的时间 deltaT，然后在 <code>timer channel</code> 上发送当时的时间 <code>time.now()</code>。因为此函数是用 go 语句启动的，不需要等待它。它可以做任何想做的事情，当需要知道其他 goroutine 完成时，它说我想从 <code>timer channel</code> 接收那个值。该 goroutine 会阻塞直到有一个值被传递过来。一旦完成，它将设置为得到的时间，即其他 goroutine 完成的时间。小例子，但你需要的一切都在那张小幻灯片里。</p><h4 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h4><p><img src="/images/concurrency-is-not-parallelism/DA19096F-B0A1-4C7B-9CD6-CE1D77E3F7C2.png" alt=""><br>最后一部分叫做 <code>select</code>。它让你可以通过同时监听多个 channel 控制程序的行为。一旦就能看出谁准备好通信了，你就可以读取。在这种情况下，<code>channel 1</code> 或 <code>channel 2</code>，程序的行为将不同，取决于 <code>channel 1</code> 或 <code>channel 2</code> 是否准备就绪。在这种情况下，如果两个都没有准备好，那么 <code>default</code> 子句将运行，这意味着，如果没有人准备好进行通信，那么你会 <code>fall through</code>。如果 <code>default</code> 子句不存在，执行 <code>select</code>，需要等待其中一个或另一个 channel 就绪。如果它们都准备好了，系统会随机挑选一个。所以这种要晚一点才能结束。像 <code>switch</code> 语句，但用于通信场景。如果你知道 <code>Dijkstra</code> 的监督命令，应该会很熟悉</p><p><img src="/images/concurrency-is-not-parallelism/7C761468-B2E1-4D42-AE2F-CA64A57D3D11.png" alt=""><br>当我说 Go 支持并发，是说它确实支持并发，在 Go 程序中创建数千个 goroutine 是常规操作。我们曾经在会议现场调试一个go程序，它运行在生产环境，已经创建了130万个 goroutine，并且在调试它的时候，有1万个活跃的。当然，要做到如此，goroutine 必须比线程廉价得多，这是重点。goroutine 不是免费的，涉及到内存分配，但不多。它们根据需要增长和缩小，而且管理得很好。它们非常廉价，你可以认为和 Gopher 一样廉价。</p><h4 id="Closures"><a href="#Closures" class="headerlink" title="Closures"></a>Closures</h4><p><img src="/images/concurrency-is-not-parallelism/AF92253B-DC36-4493-B4EC-325838093F68.png" alt=""><br>你还需要闭包，我刚在前面的页面展示过闭包，这只是在 Go 语言中可以使用它的证据。因为它们是非常方便的并发表达式，可以创建匿名的 <code>procedure</code>。因此，您可以创建一个函数，在本例中，组合多个函数返回一个函数。这只是一个有效的证明，它是真正的闭包，可以使用 go 语句运行。</p><p><img src="/images/concurrency-is-not-parallelism/6EED864D-47F1-4FC1-9792-E1EDAEB3912E.png" alt=""><br>让我们使用这些元素来构建一些示例。我希望你能潜移默化的学习一些 Go 并发编程，这是最好的学习方法。</p><h3 id="Some-examples"><a href="#Some-examples" class="headerlink" title="Some examples"></a>Some examples</h3><h4 id="Launching-daemons"><a href="#Launching-daemons" class="headerlink" title="Launching daemons"></a>Launching daemons</h4><p><img src="/images/concurrency-is-not-parallelism/098D8054-EFAC-4326-9323-A1174FA5C93B.png" alt=""><br>从启动一个守护进程开始，您可以使用闭包来包装一些您希望完成但不想等待的后台操作。在这种情况下，我们有两个 channel 输入和输出，无论出于什么原因，我们需要将输入传递到输出，但不想等到复制完成。所以我们使用 go func 和 闭包，然后有一个 for 循环，它读取输入值并写入输出，Go 中的 for range 子句将耗尽 channel。它一直运行直到 channel 为空，然后退出。所以这一小段代码会自动耗尽 channel。因为在后台运行，所以你不需要等待它。这是一个小小的范例，但你知道它还不错，而且已经习惯了。</p><h4 id="A-simple-load-balancer"><a href="#A-simple-load-balancer" class="headerlink" title="A simple load balancer"></a>A simple load balancer</h4><p><img src="/images/concurrency-is-not-parallelism/3A5AF902-C3FB-4985-B416-67BABA8D15F1.png" alt=""><br>现在让我向您展示一个非常简单的 <code>Load Balancer</code>。如果有时间的话，我会给你看另一个例子。这个例子很简单，想象一下你有一大堆工作要完成。我们将它们抽象出来，将它们具体化为一个包含三个整数值的 <code>Work</code> 结构体，您需要对其执行一些操作。</p><p><img src="/images/concurrency-is-not-parallelism/71E08B08-D525-4B69-9014-EE148E8D1FC3.png" alt=""><br><code>worker</code> 要做的是根据这些值执行一些计算。然后我在此处加入 <code>Sleep</code>，以保证我们考虑阻塞。因为 <code>worker</code> 可能会被阻塞的一定的时间。我们构造它的方式是让 <code>worker</code> 从 input channel 读取要做的工作，并通过 output channel 传递结果，它们是这个函数的参数。在循环中，遍历输入值，执行计算，sleep 一段任意长的时间，然后将响应传递给输出，传递给等待的任务，所以我们得操心阻塞。那一定很难，对吧，以下就是全部的解决方案。</p><p><img src="/images/concurrency-is-not-parallelism/FC1A9044-A2B3-4407-961A-45F7FAEF062F.png" alt=""><br>之所以如此简单，是因为channel 以及它与语言的其他元素一起工作的方式，让您能够表达并发的东西，并很好地组合它们。做法是创建两个 channel， input channel 和 output channel，连接到 <code>worker</code>。 所有 <code>worker</code> 从 input channel 读取，然后传输到 output channel；然后启动任意数量的 <code>worker</code>。注意中间的 go 子句，所有 <code>worker</code> 都在并发运行，也许是并行运行；然后你开始另一项工作，如屏幕显示为这些 <code>worker</code> 创造大量的工作，然后在函数调用中挂起，接收大量的结果，即从 ouput channel 中按照结果完成的顺序读取其值。因为作业结构化的方式，不管是在一个处理器上运行还是在一千个处理器上运行，都会正确而完整地运行。任何人使用该资源都可以同样完成，系统已经为你做好了一切。如果你思考这个问题，它很微不足道。但实际上，在大多数语言中，如果没有并发性，很难简洁地编写。并发性使得做这种事情，可以非常紧凑。</p><p><img src="/images/concurrency-is-not-parallelism/B77B1881-167C-48E2-ACC2-EC139D5C9351.png" alt=""><br>更重要的是，它是隐式并行性的（尽管不是，如果你不想，可以不必考虑该问题），它也能很好地扩展。没有同步或不同步。<code>worker</code> 数量可能是一个巨大的数字，而且它仍然可以高效地工作，因此并发工具使得为较大问题构建此类解决方案变得很容易。</p><p><img src="/images/concurrency-is-not-parallelism/C6C11FC2-52F1-4FD4-8398-213CBE16B4F7.png" alt=""><br>还要注意，没有锁了，没有互斥锁了，所有这些都是在考虑旧的并发模型时需要考虑的，新模型没有了，你看不到它们的存在。然而，一个正确的无锁的并发、并行算法，一定很好，对吧？</p><p><img src="/images/concurrency-is-not-parallelism/3E039CA6-0811-43CD-8810-EECBFFDBFEA7.png" alt=""><br>但这太容易了，我们有时间看一个更难的。</p><h4 id="Load-balancer"><a href="#Load-balancer" class="headerlink" title="Load balancer"></a>Load balancer</h4><p><img src="/images/concurrency-is-not-parallelism/FF2107A6-2CC9-484A-969D-1E3617BE6D3B.png" alt=""><br>此例子有点棘手，相同的基本概念，但做的事情更符合现实。假设我们要写一个 <code>Loader Balancer</code>，有一堆 <code>Requester</code> 生成实际的工作，有一堆工作任务。希望将所有这些 <code>Requester</code> 的工作负载分配给任意数量的 <code>Worker</code>，并使其达到某种负载平衡，所以工作会分配给负荷最少的<code>Worker</code>。 所以你可以认为 <code>Worker</code> 们一次可能有大量的工作要做。他们可能同时要做的不止一个，可能有很多。因为有很多请求在处理，所以这会是一个很忙碌的系统。正如我演示的一样，它们也许是在同一台机器上。您也可以想象，其中一些线代表了正在进行适当负载均衡的网络连接，从结构上讲，我们的设计仍然是安全的。</p><p><img src="/images/concurrency-is-not-parallelism/67B02F3A-722F-45D5-8F00-03A490D582BD.png" alt=""><br><code>Request</code> 现在看起来很不一样了。有一个任意数量函数的闭包，表示我们要做的计算；有一个 channel 可以返回结果。请注意，不像其他一些类似 Erlang 的语言，在 Go 中 channel 是 <code>Reuqest</code> 的一部分，channel 的概念就在那里，它是语言中 <code>first-class</code> 的东西，使得可以到处传递 channel。它在某种意义上类似于文件描述符，持有 channel 的对象就可以和其他对象通信，但没有 channel 的对象是做不到的。就好像打电话给别人，或者通过文件描述符传递文件一样，是一个相当有影响的概念。想法是，要发送一个需要计算的请求，它包含一个计算完成返回结果的 channel。</p><p><img src="/images/concurrency-is-not-parallelism/1F452F0A-0A0C-47B2-811C-24556D5D107A.png" alt=""><br>以下是一个虚构但能起到说明作用的版本的 <code>Requester</code>。所做的是，有一个请求可以进入的 channel，在这个 <code>work channel</code> 上生成要做的要做的任务；创建了一个 channel，并放入每个请求的内部，以便返回给我们答案。做了一些工作，使用 <code>Sleep</code> 代表（谁知道实际上在做什么）。你在 <code>work channel</code> 上发送一个带有用于计算的函数的请求对象，不管是什么，我不在乎；还有一个把答案发回去的 channel；然后你在那个 channel 等待结果返回。一旦你得到结果，你可能得对结果做些什么。这段代码只是按照一定速度生成工作。它只是产生结果，但是通过使用 input 和 output channel 通信来实现的。</p><p><img src="/images/concurrency-is-not-parallelism/1F23ED56-4E01-4ABE-8998-B8B6B2620F0C.png" alt=""><br>然后是 <code>Worker</code>，在前面的页面，记得么？有一些 <code>Requester</code>，右边的是<code>Worker</code>，它被提供给 balancer，是我最后要给你看的。<code>Worker</code> 拥有一个接收请求的 channel；一个等待任务的计数，<code>Worker</code> 拥有任务的数量代表其负载，它注定很忙；然后是一个 index，是堆结构的一部分，我们马上展示给你看。<code>Worker</code> 所做的就是从它的 <code>Requester</code> 那里接收工作。<code>Request</code> channel 是 <code>Worker</code> 对象的一部分。</p><p><img src="/images/concurrency-is-not-parallelism/3A18168E-B383-4CED-A796-99E3C8784A79.png" alt=""><br>调用 <code>Worker</code> 的函数，把请求传递给它，把从 <code>Requester</code> 生成的实际的函数通过均衡器传递给  <code>Worker</code>。<code>Worker</code> 计算答案，然后在 channel 上返回答案。请注意，与许多其他负载均衡架构不同，从  <code>Worker</code> 返回给 <code>Requester</code> 的 channel 不通过 <code>Loader Balancer</code>。一旦 <code>Requester</code> 和 <code>Worker</code> 建立连接，图中的“中介”就会消失，请求上的工作直接进行通信。因为在系统运行时，系统内部可以来回传递 channel。如果愿意，也可以在里面放一个 <code>goroutine</code>，在这里放一个 go 语句，然后在 <code>Worker</code> 上并行地处理所有的请求。如果这样做的话，一样会工作的很好，但这已经足够了。</p><p><img src="/images/concurrency-is-not-parallelism/B8215781-BFD9-4512-B40A-2ABB67B82675.png" alt=""><br><code>Balancer</code> 有点神奇，你需要一个 <code>Worker</code> 的 <code>pool</code>； 需要一些 <code>Balancer</code> 对象，以绑定一些方法到 <code>Balancer</code>。<code>Balancer</code> 包含一个 <code>pool</code>；一个 <code>done channel</code>，用以让  <code>Worker</code> 告诉  <code>Loader Balancer</code> 它已经完成了最近的计算。</p><p><img src="/images/concurrency-is-not-parallelism/EA2A6D83-4160-4367-8CB4-FD3FD9D0447A.png" alt=""><br>所以 <code>balance</code> 很简单，它所做的只是永远执行一个 <code>select</code> 语句，等待做更多来自 <code>Requester</code> 的工作。在这种情况下，它会分发请求给负载最轻的 <code>Worker</code>；或者 <code>Worker</code> 告知，它已经完成计算，在这种情况下，可以通过更新数据结构表明 <code>Worker</code> 完成了它的任务。所以这只是一个简单的两路 <code>select</code>。然后，我们需要增加这两个函数，而要做到这一点，实际上要做的就是构造一个堆。</p><p><img src="/images/concurrency-is-not-parallelism/C20CFC3C-72AB-43A9-A102-B6C6438D736C.png" alt=""><br>我跳过这些令人很兴奋的片段，你们已经知道什么意思。</p><p><img src="/images/concurrency-is-not-parallelism/A17A867D-76BE-4B60-B158-2B77CA7406A4.png" alt=""><br><code>Dispatch</code>, <code>dispatch</code> 要做的就是找到负载最少的 <code>Worker</code>，它是基于堆实现的一个标准优先级队列。所以你把负载最少的 <code>Worker</code> 从堆里取出来，通过将请求写入 request channel 来发送任务。因为增加了一个任务，需要增加负载，这会影响负载分布。然后你把它放回堆的同一个地方，就这样。你刚刚调度了它，并且在结构上进行了更新，这就是可执行代码行的内容。</p><p><img src="/images/concurrency-is-not-parallelism/2CD0909F-3050-4154-9233-D0823A98CD99.png" alt=""><br>然后是 <code>complete</code> 的任务，也就是工作完成后，必须做一些相反的事情。 <code>Worker</code> 的队列中减少了一个任务，所以减少了它的等待计数。从堆里弹出 <code>Worker</code>，然后把它放回堆中，优先级队列会把它放回中它所属的位置，这是一个半现实的 <code>Loader Balancer</code> 的完整实现。此处的关键点是数据结构使用的是 channel 和 goroutine 来构造并发的东西。</p><h4 id="Lesson-1"><a href="#Lesson-1" class="headerlink" title="Lesson"></a>Lesson</h4><p><img src="/images/concurrency-is-not-parallelism/0A7657F5-CDCA-41C7-B39A-08FB257670C5.png" alt=""><br>结果是可伸缩的，是正确的，很简单，没有显式的锁，而架构让它得以实现。因此，并发性使此例子的内在并行性成为可能。你可以运行这个程序，我有这个程序，它是可编译、可运行的，而且工作正常，负载均衡也做得很好。物体保持在均匀的负载下，按照模块量化，很不错。我从来没说过有多少 <code>Worker</code>，有多少问题。可能每个都有一个，另一个有数10个；或者每个都有一千，或者每个都有一百万，扩缩容仍然有效，并且仍然高效。</p><h4 id="One-more-example"><a href="#One-more-example" class="headerlink" title="One more example"></a>One more example</h4><p><img src="/images/concurrency-is-not-parallelism/77A4B1D5-95A2-40E7-8D13-F6862E6E0285.png" alt=""><br>再举一个例子，这个例子有点令人惊讶，但它适合一张幻灯片就可以完成。</p><p><img src="/images/concurrency-is-not-parallelism/19E4D7F9-D39C-4CBF-A8ED-B3444351AF58.png" alt=""><br>想象一下如何复制数据库，你得到了几个数据库，每个数据库中有相同的数据，谷歌称之为分片，称呼相同的实例。您要做的是向所有数据库传递一个请求，一个查询，并返回结果。结果会是一样的，你选择第一个应答请求来加快速度，因为首先要回来的是你想要的答案。如果其中一个坏了，断开了或者什么的，你不在乎。因为会有其他响应回来，这就是如何做到这一点。这就是它的全部实现。您有一些连接数组和一些要执行的查询，您创建一个 channel，该 channel 缓冲查询数据库中的元素数、副本内的副本数大小的内容，然后您只需在数据库的所有连接上执行。对于其中的每一个，您启动一个 goroutine 以将查询传递到该数据库，然后获取答案。但是通过这个 DoQuery 调用，将答案传递到唯一的 channel，这个 channel 保存所有请求的结果。然后，在你执行之后，所有的 goroutine 都只需在底部这行等待。我们等待第一个回到 channel 的请求，就是你想要的答案。返回它，就完成了。这看起来像个玩具，而且有点像。但这实际上是一个完全正确的实现，唯一缺少的是干净的回收。你想告诉那些还没回来的服务器关闭。当你已经得到答案，不再需要它们。你可以做，增加更多且合理的代码，但那就不适合放在幻灯片上了。所以我只想告诉你，在很多系统中，这是一个相当复杂的问题，但在这里，它只是自然地脱离了架构。因为你已经有了并发工具来表示一个相当大的复杂的分布式问题，它运行得非常好。</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p><img src="/images/concurrency-is-not-parallelism/758B1387-AEFE-4250-8442-9DDD1A725127.png" alt=""><br>还剩五秒钟，很好。结论：并发性是强大的，但它不是并行性的，但它支持并行性，而且它使并行性变得容易。如果你明白了，那我就完成了我的工作。</p><h3 id="For-more-information"><a href="#For-more-information" class="headerlink" title="For more information"></a>For more information</h3><p><img src="/images/concurrency-is-not-parallelism/C4DE1ADD-6DF7-4C0D-B96F-409F4BB5DD9B.png" alt=""><br>如果你想看更多，这里有很多链接。<code>golang.org</code> 有关于 GO 你想知道的一切。有一份很好的历史 paper，链接如上。几年前我做了一个演讲，让我们真正开始开发Go语言，你可能会觉得很有趣。CMU 的 Bob Harper 有一篇非常不错的博客文章，叫做“并行不是并发”，这与“并发不是并行”的观点非常相似，虽然不完全一样。还有一些其他的东西，最令人惊讶的是，道格·马图尔（Doug Mathur）,我在贝尔实验室（Bell Labs）的老板，所做的并行幂级数的工作，这是一篇了不起的论文。但如果你想与众不同的话。幻灯片上的最后一个链接是到另一种语言 sawzall，我从贝尔实验室（Bell Labs）来到谷歌后不久做的，这很了不起，因为它是不可思议的并行的语言，但它绝对没有并发性。现在我想你可能明白了这是可能的，所以非常感谢你的倾听和感谢 Hiroko 给我写信。我想是时候喝点什么了。</p><p><em>视频：<a href="https://vimeo.com/49718712" target="_blank" rel="noopener">https://vimeo.com/49718712</a></em><br><em>Slide：<a href="https://talks.golang.org/2012/waza.slide#1" target="_blank" rel="noopener">https://talks.golang.org/2012/waza.slide#1</a></em><br><em>源代码：<a href="https://github.com/golang/talks/tree/master/content/2012/waza" target="_blank" rel="noopener">https://github.com/golang/talks/tree/master/content/2012/waza</a></em>       </p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/12-09-2019/concurrency-is-not-parallelism.html">https://www.cyningsun.com/12-09-2019/concurrency-is-not-parallelism.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Concurrency-vs-Parallelism&quot;&gt;&lt;a href=&quot;#Concurrency-vs-Parallelism&quot; class=&quot;headerlink&quot; title=&quot;Concurrency vs Parallelism&quot;&gt;&lt;/a&gt;Concurre
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Concurrency" scheme="https://www.cyningsun.com/tag/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>译 | Share Memory By Communicating</title>
    <link href="https://www.cyningsun.com/09-29-2019/share-memory-by-communicating-cn.html"/>
    <id>https://www.cyningsun.com/09-29-2019/share-memory-by-communicating-cn.html</id>
    <published>2019-09-28T16:00:00.000Z</published>
    <updated>2020-02-03T06:53:29.645Z</updated>
    
    <content type="html"><![CDATA[<p>传统的线程模型（例如，通常在编写Java，C++ 和 Python 程序时使用）要求程序员使用共享内存在线程之间进行通信。通常，共享数据结构受锁保护，线程争夺这些锁以访问数据。在某些情况下，通过使用线程安全的数据结构可以使操作变得更容易，例如 Python 的 Queue。</p><p>Go的并发原语 — goroutine 和 chan nel— 提供了一种优雅而独特的方式来构造并发软件（ 这些概念有一个<a href="https://swtch.com/~rsc/thread/" target="_blank" rel="noopener">有趣的历史</a>，始于 C. A. R. Hoare 的 <a href="http://www.usingcsp.com/" target="_blank" rel="noopener">Communicating Sequential Processes</a> ）。Go 并未显式地使用锁来达成对共享数据的访问，而是鼓励使用 channel 在goroutine 之间传递对数据的引用。该方法可确保在给定时间只有一个 goroutine 可以访问数据。该概念在<a href="https://golang.org/doc/effective_go.html" target="_blank" rel="noopener">Effective Go</a>（Go程序员必读）中进行了总结：</p><blockquote><p>Do not communicate by sharing memory; instead, share memory by communicating.<br>不要通过共享内存进行通信；而是通过通信共享内存。</p></blockquote><p>考虑一个轮询 URL 列表的程序。在传统的线程环境中，人们可能会如下构造其数据：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Resource <span class="hljs-keyword">struct</span> &#123;    url        <span class="hljs-keyword">string</span>    polling    <span class="hljs-keyword">bool</span>    lastPolled <span class="hljs-keyword">int64</span>&#125;<span class="hljs-keyword">type</span> Resources <span class="hljs-keyword">struct</span> &#123;    data []*Resource    lock *sync.Mutex&#125;</code></pre><p>然后，Poller 函数（许多类似的函数会运行在单独的线程中）如下：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Poller</span><span class="hljs-params">(res *Resources)</span></span> &#123;    <span class="hljs-keyword">for</span> &#123;        <span class="hljs-comment">// get the least recently-polled Resource</span>        <span class="hljs-comment">// and mark it as being polled</span>        res.lock.Lock()        <span class="hljs-keyword">var</span> r *Resource        <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> res.data &#123;            <span class="hljs-keyword">if</span> v.polling &#123;                <span class="hljs-keyword">continue</span>            &#125;            <span class="hljs-keyword">if</span> r == <span class="hljs-literal">nil</span> || v.lastPolled &lt; r.lastPolled &#123;                r = v            &#125;        &#125;        <span class="hljs-keyword">if</span> r != <span class="hljs-literal">nil</span> &#123;            r.polling = <span class="hljs-literal">true</span>        &#125;        res.lock.Unlock()        <span class="hljs-keyword">if</span> r == <span class="hljs-literal">nil</span> &#123;            <span class="hljs-keyword">continue</span>        &#125;        <span class="hljs-comment">// poll the URL</span>        <span class="hljs-comment">// update the Resource's polling and lastPolled</span>        res.lock.Lock()        r.polling = <span class="hljs-literal">false</span>        r.lastPolled = time.Nanoseconds()        res.lock.Unlock()    &#125;&#125;</code></pre><p>此功能大约一页纸长，并且需要更多细节才能完成。它甚至不包括 URL 轮询逻辑（它本身只有几行），也不能优雅地应对资源池耗尽。</p><p>让我们看一下使用 Go 风格实现的相同功能。在此示例中，Poller 函数从输入 channel 接收要轮询的资源，并在完成后将其发送到输出 channel。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Resource <span class="hljs-keyword">string</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Poller</span><span class="hljs-params">(in, out <span class="hljs-keyword">chan</span> *Resource)</span></span> &#123;    <span class="hljs-keyword">for</span> r := <span class="hljs-keyword">range</span> in &#123;        <span class="hljs-comment">// poll the URL</span>        <span class="hljs-comment">// send the processed Resource to out</span>        out &lt;- r    &#125;&#125;</code></pre><p>前一个例子中的微妙逻辑显然没有了，并且 Resource 数据结构不再包含记账数据。实际上，剩下的都是重要的部分。以上应该使您对这些简单的语言功能的威力有所了解。</p><p>上面的代码片段有很多遗漏之处。如需走读使用以上想法的，完整的、惯用的 Go 程序，请参阅 Codewalk <a href="https://golang.org/doc/codewalk/sharemem/" target="_blank" rel="noopener">Share Memory By Communicating</a>。</p><p><em>原文：<a href="https://blog.golang.org/share-memory-by-communicating" target="_blank" rel="noopener">https://blog.golang.org/share-memory-by-communicating</a></em><br><em>源代码：<a href="https://github.com/cyningsun/go-test" target="_blank" rel="noopener">https://github.com/cyningsun/go-test</a></em></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/09-29-2019/share-memory-by-communicating-cn.html">https://www.cyningsun.com/09-29-2019/share-memory-by-communicating-cn.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;传统的线程模型（例如，通常在编写Java，C++ 和 Python 程序时使用）要求程序员使用共享内存在线程之间进行通信。通常，共享数据结构受锁保护，线程争夺这些锁以访问数据。在某些情况下，通过使用线程安全的数据结构可以使操作变得更容易，例如 Python 的 Queue。
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Concurrency" scheme="https://www.cyningsun.com/tag/Concurrency/"/>
    
  </entry>
  
  <entry>
    <title>译｜Let’s talk about logging</title>
    <link href="https://www.cyningsun.com/09-27-2019/lets-talk-about-logging-cn.html"/>
    <id>https://www.cyningsun.com/09-27-2019/lets-talk-about-logging-cn.html</id>
    <published>2019-09-26T16:00:00.000Z</published>
    <updated>2020-02-03T06:53:29.644Z</updated>
    
    <content type="html"><![CDATA[<p>本文受 <a href="https://forum.golangbridge.org/t/whats-so-bad-about-the-stdlibs-log-package/1435/" target="_blank" rel="noopener">Nate Finch started on the Go Forum</a> 的一个话题启发。本文专注于 Go，但是如果你能看透，我认为这里提出的想法是广泛适用的。</p><h3 id="Why-no-love"><a href="#Why-no-love" class="headerlink" title="Why no love ?"></a>Why no love ?</h3><p>Go 的 <a href="https://golang.org/pkg/log/" target="_blank" rel="noopener">log package</a> 没有日志级别，你必须自己手动添加 debug、info、warn 和 error 等前缀。另外，Go 的 日志类型无法以包为基础打开或者关闭这些不同级别。通过比较，让我们看一些第三方的替代品：</p><p>Google 的 <a href="https://godoc.org/github.com/golang/glog" target="_blank" rel="noopener">glog</a> 提供以下级别：</p><ul><li>Info</li><li>Warning</li><li>Error</li><li>Fatal (终止程序)</li></ul><p>看看另外一个库， 我们为 Juju 开发的 <a href="https://godoc.org/github.com/juju/loggo" target="_blank" rel="noopener">loggo</a>，提供以下级别：</p><ul><li>Trace</li><li>Debug</li><li>Info</li><li>Warning</li><li>Error</li><li>Critical</li></ul><p>Loggo 还提供了根据每个包调整日志的详细程度的功能。</p><p>因此，以上两个示例显然受到其他语言的其他日志库的影响。实际上，它们的命令行可以追溯到 syslog(3)，甚至更早。我认为他们是错的。</p><p>我站相反的立场。我认为_所有_日志库都不好，因为它提供了_太多_的功能。一系列令人困惑的选择，使程序员必须清楚地思考如何与未来的读者沟通，而读者将要使用他们的日志。</p><p>我认为成功的日志包需要的功能要少得多，当然需要的级别也更少。</p><h3 id="Let’s-talk-about-warnings"><a href="#Let’s-talk-about-warnings" class="headerlink" title="Let’s talk about warnings"></a>Let’s talk about warnings</h3><p>我们从最简单的一个开始。没有人需要 warning 的日志级别。</p><p>没有人阅读 warning，因为按照定义，没有出错。也许将来会出问题，但这听起来像是别人的问题。</p><p>此外，如果你在使用某种分级日志，那么为什么将级别设置为 warning? 你可以将级别设置为 info 或 error。将级别设置为 warning 是承认你可能正在以 warninng 级别打印错误日志</p><p>消除 warning 级别，因为它既可能是信息性的消息，也可能是错误的情况。（潜台词：语义不明确）</p><h3 id="Let’s-talk-about-fatal"><a href="#Let’s-talk-about-fatal" class="headerlink" title="Let’s talk about fatal"></a>Let’s talk about fatal</h3><p>Fatal 级别，有效打印消息日志，然后调用 <code>os.Exit(1)</code>。原则上，这意味着：</p><ul><li>其他goroutines中的defer语句不会运行。</li><li>缓冲区不刷新。</li><li>临时文件和目录不会被删除。</li></ul><p>实际上，<code>log.Fatal</code> 的详细程度要比 <code>panic</code> 少，但在语义上却等同于它。</p><p>普遍认为，库不应该使用 panic<sup>1</sup>，但是如果调用 log.Fatal<sup>2</sup> 具有相同的效果，那么当然也应该将其定为非法。</p><p>解决此清理问题的建议是，可以通过在日志系统中注册 shutdown handler，但如此导致日志系统与发生清理操作的每个位置之间紧密耦合。它也违反了关注点分离。</p><p>不要以 <code>Fatal</code> 级别写日志，而要将错误返回给调用方。如果错误一直冒泡到 <code>main.main</code>, 那么退出之前，是处理所有清理操作的正确位置。</p><h3 id="Let’s-talk-about-error"><a href="#Let’s-talk-about-error" class="headerlink" title="Let’s talk about error"></a>Let’s talk about error</h3><p>错误处理和日志密切相关，因此从表面上看，以 error 级别进行日志打印应该很容易解释。但，我不同意。</p><p>在 Go 中，如果函数或方法调用返回错误值，实际上您有两个选择：</p><ul><li>处理错误</li><li>将错误返回给您的呼叫者（您可以选择包装错误，但这对于本次讨论并不重要）</li></ul><p>如果您选择通过打印日志来处理错误，那么按照定义，你已经处理了它，错误就不存在了。打印错误处理错误的行为，意味着不再适合将其打印为错误日志。</p><p>让我尝试用以下代码片段说服您：</p><pre><code class="hljs go">err := somethingHard()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;        log.Error(<span class="hljs-string">"oops, something was too hard"</span>, err)        <span class="hljs-keyword">return</span> err <span class="hljs-comment">// what is this, Java ?</span>&#125;</code></pre><p>您永远不应该在 error 级别打印任何内容的日志，因为您应该处理错误，或者将其传递回调用方。</p><p>准确地说，我并不是说您不应该将发生的情况打印日志</p><pre><code class="hljs code">if err :&#x3D; planA(); err !&#x3D; nil &#123;        log.Infof(&quot;could&#39;t open the foo file, continuing with plan b: %v&quot;, err)        planB()&#125;</code></pre><p>但实际上 <code>log.Info</code> 和 <code>log.Error</code> 有异曲同工之妙。</p><p>我并不是说不要打印错误日志！相反，问题是，最小的日志API是什么？当提到错误时，我相信绝大多数打印日志为 error 级别的项目，都是通过这种简单地方式完成的，因为它们与错误相关。实际上，它们只是提供信息，意味着可以从API中删除以 error 级别打印日志。</p><h3 id="What’s-left"><a href="#What’s-left" class="headerlink" title="What’s left ?"></a>What’s left ?</h3><p>我们已经排除了 warning，认为不应该以 error 级别打印任何内容的日志，并且表明只有应用程序的顶层应该具有某种 <code>log.Fatal</code> 行为。还剩什么 ？</p><p>我认为只有两种东西您应该打印日志：</p><ol><li>开发人员在开发或调试软件时会关心的东西。</li><li>用户在使用您的软件时关心的东西。</li></ol><p>显然，分别是 debug 和 info 级别。</p><p><code>log.Info</code> 应该简单地将该行写入日志输出。不应有将其关闭的选项，因为仅应告知用户对他们有用的事情。如果发生<em>无法_处理的错误，它将冒泡到 <code>main.main</code>， 程序终止的地方。必须在最后一条日志消息前面插入 _FATAL</em> 前缀，或直接用 <code>fmt.Fprintf</code> 写入 <code>os.Stderr</code> 所带来的小小不便，不足以解释日志包需要添加 <code>log.Fatal</code> 方法。</p><p><code>log.Debug</code>，则完全不同。由开发人员或支持工程师控制。在开发过程中，调试语句应足够多，而不必求助于 trace 或 debug<sup>2</sup> 级别。日志包应支持细粒度的控制，以启用或禁用调试，并且仅在该包或可能更精细的范围内的语句调试。</p><h3 id="Wrapping-up"><a href="#Wrapping-up" class="headerlink" title="Wrapping up"></a>Wrapping up</h3><p>如果这是推特民意调查，请您选择</p><ul><li>打印日志很重要</li><li>打印日志很难</li></ul><p>但是事实是，打印日志是两者兼而有之。解决这个问题的方法_必须_是解构和残酷地消除不必要的干扰。</p><p>你怎么看？这仅仅是疯狂到足以工作，还是纯粹是疯狂的？</p><h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h3><ol><li>一些库可能使用 <code>panic</code>/<code>recover</code> 作为内部控制流机制，但最重要的原则是它们一定不能让这些控制流操作泄漏到程序包边界之外。</li><li>具有讽刺意味的是，尽管缺少 debug 级别的输出，但 Go 标准日志包同时具有 <code>Fatal</code> 和 <code>Panic</code> 功能。在此程序包中，导致程序突然退出的功能数量超过了没有退出功能的数量。</li></ol><p><em>原文：<a href="https://dave.cheney.net/2015/11/05/lets-talk-about-logging" target="_blank" rel="noopener">https://dave.cheney.net/2015/11/05/lets-talk-about-logging</a></em></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/09-27-2019/lets-talk-about-logging-cn.html">https://www.cyningsun.com/09-27-2019/lets-talk-about-logging-cn.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文受 &lt;a href=&quot;https://forum.golangbridge.org/t/whats-so-bad-about-the-stdlibs-log-package/1435/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nate Finch
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://www.cyningsun.com/category/Golang/"/>
    
    
      <category term="Logging" scheme="https://www.cyningsun.com/tag/Logging/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus Client定制</title>
    <link href="https://www.cyningsun.com/09-15-2019/micro-service-monitor-prometheus-client.html"/>
    <id>https://www.cyningsun.com/09-15-2019/micro-service-monitor-prometheus-client.html</id>
    <published>2019-09-14T16:00:00.000Z</published>
    <updated>2020-04-25T01:36:45.886Z</updated>
    
    <content type="html"><![CDATA[<p>Prometheus提供的Client无法直接使用到生产环境，需要根据需求进行定制，以下为Client中的主要概念。<br><img src="/images/micro-service-monitor/prometheus-client.png" alt=""></p><ul><li>Desc：该结构是图中最关键的结构体，需要详细说明。<blockquote><ul><li>fqName：由Namespace、Subsystem和metric的Name组成。相同fqName的监控指标在整个系统中需要保证唯一(dimhash, label dimensions hash)，包括：type、labels(顺序无关)、help。</li><li>labels：包含该metric的label列表</li></ul></blockquote></li><li>Metric：Desc相同，但label值不同的指标定义为Metric，即LabelPair列表+Desc确定一个Metric，每个Metric都有其type（counter、gauge、summary、histogram）和vaule</li><li>MetricVec：相同fqName的Metric会存放在同一个MetricVec</li><li>Collector：任何可以被收集监控指标的接口（MetricVec、Metric均实现了该接口）；通常在使用时类似Package，自定义的Collector将多个相关的MetricVec打包，以供收集，例如：goCollector、processCollector。</li><li>Registry：实现了Gatherer(数据收集)和Registerer（指标注册）接口，并提供了以上功能。</li></ul><p>在生产环境使用的之前需要考虑以下问题：</p><ul><li>如何分配和包装好fqName，fqName至关重要，将会影响整套监控系统的维护难度。</li><li>如何定义框架指标和业务指标接口</li><li>是否为指标添加固定的label，如：服务名、环境、IDC等</li><li>Client不会自动剔除不再使用的Metric(除非服务重启)，是否需要提供Metric <a href="https://github.com/armon/go-metrics/blob/master/prometheus/prometheus.go" target="_blank" rel="noopener">Sink</a>的功能</li></ul><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/09-15-2019/micro-service-monitor-prometheus-client.html">https://www.cyningsun.com/09-15-2019/micro-service-monitor-prometheus-client.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Prometheus提供的Client无法直接使用到生产环境，需要根据需求进行定制，以下为Client中的主要概念。&lt;br&gt;&lt;img src=&quot;/images/micro-service-monitor/prometheus-client.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="SRE" scheme="https://www.cyningsun.com/category/SRE/"/>
    
    
      <category term="数据收集" scheme="https://www.cyningsun.com/tag/%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>高可用Prometheus集群</title>
    <link href="https://www.cyningsun.com/09-13-2019/micro-service-monitor-prometheus-ha.html"/>
    <id>https://www.cyningsun.com/09-13-2019/micro-service-monitor-prometheus-ha.html</id>
    <published>2019-09-12T16:00:00.000Z</published>
    <updated>2020-04-25T01:36:45.885Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>一个应用于生产环境的监控服务，单机Promtheus往往是无法满足需求的，此时就要搭建一套Prometheus集群，此时就需要考虑：<br>服务高可用：服务要冗余备份，以消除单点故障。<br>数据一致性：冗余结点之间数据需要保证一致性。<br>水平可扩展：可以通过增加服务数量，线性提高服务能力。<br>数据持久化：节点故障数据不丢失、海量历史数据存储</p><h3 id="服务高可用"><a href="#服务高可用" class="headerlink" title="服务高可用"></a>服务高可用</h3><p>Prometheus采用Pull模型收集监控数据，服务高可用意味着同一个服务需要至少两个节点同时拉取<br><img src="/images/micro-service-monitor/1-prometheus-replica.png" alt=""></p><p>或者切换为Push模型，使用一致性哈希，将不同实例的Metrics推送到固定推送到其中一台服务<br><img src="/images/micro-service-monitor/2-prometheus-push.png" alt=""></p><p>此模式优势是，在保障服务可用性的同时，资源消耗量少一半；新节点不需要重新配置抓取规则，可以做到快速平行扩容。但缺点是，节点故障将导致历史数据丢失。</p><h3 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h3><p>Pull模式下，冗余节点存在以下两个问题：<br>两个数据源（Prometheus）的metrics是重复的<br>两个数据源的同样的metrics有细微差异（两次抓取）</p><p>解决这些问题有两种方案：<br>方案一：使用HA Proxy保证同时只有一个数据数据源提供服务，另外一个节点作为备份，当检测故障时接管主节点提供服务。<br><img src="/images/micro-service-monitor/3-promtheus-ha.png" alt=""></p><p>方案二：使用Thanos来接管Prometheus提供服务，将Thanos Sidecar与Prometheus同机部署，Thanos Query可以调用Sidecar获取metrics，并且进行去重。此时 Thanos Query代替Prometheus对外提供Http API接口<br><img src="/images/micro-service-monitor/4-thanos.png" alt=""></p><p>相反，Push模式下，所有节点都可以提供服务，数据没有重复，所以不存在数据一致性的问题。</p><h3 id="水平可扩展"><a href="#水平可扩展" class="headerlink" title="水平可扩展"></a>水平可扩展</h3><p>Prometheus解决水平扩展的方式是：Sharding。当单台Promthues Server无法处理大量的采集任务时，用户可以考虑基于Prometheus联邦集群的方式将监控采集任务划分到不同的Promthues实例。<br><img src="/images/micro-service-monitor/5-scale-out.png" alt=""></p><p>可以根据场景选择根据Sharding的方式<br>按照功能分区：例如一个Promthues Server负责采集基础设施相关的监控指标，另外一个Prometheus Server负责采集应用监控指标<br>按照实例分区：当单个采集任务的Target数也变得非常巨大。简单通过联邦集群进行功能分区，Prometheus也无法有效处理时。需要考虑继续在实例级别进行功能划分</p><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>Prometheus的本地存储设计可以减少其自身运维和管理的复杂度，同时能够满足大部分用户监控规模的需求。但是本地存储也意味着Prometheus无法持久化数据，无法存储大量历史数据。Prometheus并没有尝试在自身中解决以上问题，而是让用户可以通过接口将数据保存到任意第三方的分布式存储中，即：Remote Storage。<br><img src="/images/micro-service-monitor/5.1-remote-storage.png" alt=""></p><p>一旦开始查询历史数据，我们很快便意识到，在我们检索几周，几个月，乃至最终数年的数据时，这里存在的大O复杂度会让查询变得越来越慢。Prometheus暂时并未提供完整的方案来解决该问题，此时需要依靠Thanos解决方案的 <code>Downsampling</code>了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综上所述，根据不同的业务场景，选择合适的高可用部署方案，并根据自身需求进行灵活调整。下面列出来的是三套完整的高可用的方案：<br><img src="/images/micro-service-monitor/6-prometheus-pull.png" alt=""></p><p><img src="/images/micro-service-monitor/7-thanos-pull.png" alt=""></p><p><img src="/images/micro-service-monitor/8-thanos-push.png" alt=""></p><p><strong>本文作者</strong>：cyningsun<br /><strong>本文地址</strong>： <a href="https://www.cyningsun.com/09-13-2019/micro-service-monitor-prometheus-ha.html">https://www.cyningsun.com/09-13-2019/micro-service-monitor-prometheus-ha.html</a> <br /><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/cn/" target="_blank" rel="noopener">CC BY-NC-ND 3.0 CN</a> 许可协议。转载请注明出处！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;一个应用于生产环境的监控服务，单机Promtheus往往是无法满足需求的，此时就要搭建一套Prometheus集群，此时就需要考虑：&lt;br&gt;
      
    
    </summary>
    
    
      <category term="SRE" scheme="https://www.cyningsun.com/category/SRE/"/>
    
    
      <category term="HA" scheme="https://www.cyningsun.com/tag/HA/"/>
    
  </entry>
  
</feed>
